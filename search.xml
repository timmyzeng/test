<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[参考一：全面的排序总结(动图来源之一) 参考二：画图的部分排序总结(代码参考，总结参考) 参考三：十大经典排序算法（动图演示)(动图来源之二) 排序的分类有很多种，有很多的排序方法，这里只列举了七八种常见的排序算法。 交换排序冒泡排序冒泡排序的思路(升序)： 比较相邻的两个元素，如果第一个比第二个元素值要大，交换两者位置。 指向第二个元素。 一趟比较下来，最大的元素应该位于序列的最尾端 进行下一趟比较，此时就不需要将最大的元素纳入范围，因为它已经在适合的位置了。 重复直到全部完成。 如图： 代码如下：1234567891011void BubbleSort(int arr[], int size)&#123; for(int i = size; i &gt; 0; -- i)&#123; for(int j = 0; j &lt; i-1; ++ j)&#123; if(arr[j] &gt; arr[j+1])&#123; int tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; &#125;&#125; 优化： 1、记住最后一次的交换位置因为每一趟的最后一次交换，证明这个位置之后的数据都是大于当前的。同时我们还可以通过标志来记录是否发生了交换，如果有一趟没有发生交换，说明序列已经有序。 代码如下： 1234567891011121314151617181920void BubbleSort(int arr[], int size)&#123; int index = size; int flag = 1; int change = 1; for(int i = size; i &gt; 0; -- i)&#123; for(int j = 0; j &lt; index-1; ++ j)&#123; if(arr[j] &gt; arr[j+1])&#123; int tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; change = j+1; flag = 0; &#125; &#125; index = change; if(flag)&#123; break; &#125; &#125;&#125; 2、改变冒泡的方向因为之前冒泡的方向是固定的，但是如果出现了不对称的情况，有的时候反过来冒泡可以减少大量的时间。 比如：1 2 3 4 5 0；如果是从前向后冒泡，需要n-1次，但是如果是从后往前冒泡，只需要一次。反过来：5 0 1 2 3 4；如果从前向后只需要一次，从后向前需要n-1次。所以为了解决这种不对称性的问题，我们可以每走一趟，就将方向反过来冒泡。 如图(这种改进也称为鸡尾酒排序)： 代码如下： 123456789101112131415161718192021222324252627282930313233void BubbleSortOP(int arr[], int size)&#123; int high = size - 1; int low = 0; while(low &lt; high)&#123; bool flag = true; //从左向右 for(int i = low; i &lt; high; ++ i)&#123; if(arr[i] &gt; arr[i+1])&#123; int tmp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = tmp; flag = false; &#125; &#125; if(flag)&#123; break; &#125; -- high; //从右向左 for(int i = high; i &gt; low; -- i)&#123; if(arr[i] &lt; arr[i-1])&#123; int tmp = arr[i]; arr[i] = arr[i-1]; arr[i-1] = tmp; flag = false; &#125; &#125; if(flag)&#123; break; &#125; ++ low; &#125;&#125; 复杂度： 时间复杂度：平均复杂度：O(n²)；最坏情况：O(n²)；最好情况：O(n)； 空间复杂度：O(1) 虽然我们进行了优化，但是总的来说，并没有很大的提升空间。对于完全逆序的序列，依然是最坏的情况。 快速排序快速排序是冒泡的升级版本，我们冒泡的时候，是每次将最大值或最小值放入合适的位置。其实我们可以选准一个基准值，然后把比他小的放到左边，比他大的放到右边，这样我们就缩小的范围。即基准值左边的值一定比他小，右边的值一定比他大。然后利用这个性质，分为左右两个区间，这里使用了分治的思想。 快速排序思路(升序)： 从序列中选出一个基准值。 将序列之后的每一个成员和基准值比较，实现比基准值小的在左边，大的在右边。这一趟结束之后，基准值位于两者之间。 根据基准值的位置缩小区间，分为左边和右边区间，递归左右区间。 一直到最后的区间只有一个元素或者区间左边大于右边结束。 如图：(上图是左右指针法，下图是前后指针法) 快速排序的方法： 一般来说，我们将快速排序分为三种方法，分别是挖坑法、左右指针法、前后指针法。其中左右指针法和挖坑法很相似，前后指针法有点绕。 挖坑法(此处选择基准值从最右端选取)： 步骤如下： 选取基准值，用变量保存，同时此处作为第一个坑。 此时从最左端开始寻找第一个比基准值大或等于的元素，找到就将值填入第一个坑。将该位置作为第二个坑 此时从右向左寻找第一个比基准值小或者等于的元素，找到就将值填入第二个坑。将该位置作为第三个坑。 一直到左右指向同一个元素，将该值和基准值交换，同时划分左右区间，递归左右区间的元素。 挖坑法代码如下： 1234567891011121314151617181920212223void QuickSort(int arr[], int low, int high)&#123; int key = arr[high]; //第一个坑处于high处 if(low &gt;= high)&#123; return; &#125; int left = low; int right = high; while(left &lt; right)&#123; while(left &lt; right &amp;&amp; arr[left] &lt;= key)&#123; ++ left; &#125; arr[right] = arr[left]; //将左边的元素填入右边的坑中 while(left &lt; right &amp;&amp; arr[right] &gt;= key)&#123; -- right; &#125; arr[left] = arr[right]; //将右边的元素填入左边的坑中 &#125; arr[left] = key; //将基准值填入最后一个坑中 QuickSort(arr, low, left-1); QuickSort(arr, left+1, high);&#125; 左右指针法(选择最右元素为基准值)： 步骤如下： 从最左边开始找到第一个比基准值大的元素，然后再从最右边找到第一个比基准值小的元素。交换两者，此时完成第一次交换。 只要左边的指针没有等于右边的指针，循环继续。 一直到两者相等，此时指针指向的元素肯定比基准值大，因为是左边先走的，相等的时候肯定是大的。交换此值和基准值。 划分区间，递归左右区间。 左右指针代码如下： 12345678910111213141516171819202122232425void QuickSort2(int arr[], int low, int high)&#123; int key = arr[high]; if(low &gt;= high)&#123; return; &#125; int left = low; int right = high; while(left &lt; right)&#123; while(left &lt; right &amp;&amp; arr[left] &lt;= key)&#123; ++ left; &#125; while(left &lt; right &amp;&amp; arr[right] &gt;= key)&#123; -- right; &#125; if(left != right)&#123; swap(arr[left], arr[right]); &#125; &#125; //此处交换的时候，不要和key交换，应该是序列中与基准值相同的值。也就是这里的最右元素。 swap(arr[left], arr[high]); QuickSort2(arr, low, left-1); QuickSort2(arr, left+1, high);&#125; 前后指针法： 前后指针法的思想见下图：(前后指针法比较绕，如果不理解，可以画图验证，就懂了。) 前后指针法代码如下： 12345678910111213141516171819202122void QuickSort3(int arr[], int low, int high)&#123; if(low &gt;= high)&#123; return; &#125; int key = arr[high]; int cur = low; int prev = cur-1; while(cur &lt;= high)&#123; //cur找小于key的值，找到了停下。 while(cur &lt;= high &amp;&amp; arr[cur] &gt; key)&#123; ++ cur; &#125; //cur跟++ prev的值进行比较，如果相同，证明没有拉开距离，就不需要交换 //也就是cur的下一个就遇到了小于key的值，所以跟prev的距离为一 if(++ prev != cur)&#123; swap(arr[prev], arr[cur]); &#125; ++ cur; &#125; QuickSort3(arr, low, prev-1); QuickSort3(arr, prev, high);&#125; 优化1： 快速排序是一个很优的算法，但是如果遇到某些特殊情况，基准值每次选到的都是最小或者最大的值，就会出现退化的情况。比如：使用左右指针法，基准值从最右选取，序列为升序。此时每次选到的基准值都是最大的，产生的两个区间，有一个必然为空，而且每次都需要遍历整个区间。这时候的时间复杂度就是O(n²)。 解决这个问题的一种方法是三数取中法。所谓三数取中法指的是，在序列中选出最左，中间，最右的三个位置的元素进行比较，然后取出值在中间的那个元素，跟基准值的选取值进行交换。比如三数取中法取出的中间元素是arr[mid]，基准值的取值是arr[end]，交换这两者。这样就不会出现每次选到的都是最大的元素值，或者最小的元素值了。 三数取中法代码如下： 12345678910111213141516171819202122232425int Mid(int *arr, int low, int high)&#123; int middle = low + (high-low)/2; if(arr[low] &lt; arr[high])&#123; if(arr[high] &lt; arr[middle])&#123; return high; &#125; else if(arr[middle] &lt; arr[low])&#123; return low; &#125; else&#123; return middle; &#125; &#125; else&#123; if(arr[low] &lt; arr[middle])&#123; return low; &#125; else if(arr[middle] &lt; arr[high])&#123; return high; &#125; else&#123; return middle; &#125; &#125;&#125; 使用三数取中法的时候，只需要在选取key值得时候替换就可以，如下： 123int index = Mid(arr, low, high);swap(arr[index], arr[high]);int key = arr[high]; 这样我们的基准值就不会是一直是大的或者一直是小的这种情况，从而导致效率的大大降低。 优化2： 其实，当我们的数据处于比较小的情况，我们使用快速排序不如使用插入排序。因为我们划分子区间的时候，使用的是递归(当然可以使用非递归的形式，利用栈模拟)。十几个元素划分的递归有点多，这样是一种浪费。我们可以直接使用插入排序实现，可以减少栈桢的开销。修改代码如下： 1234567//这个小区间一般是10~20之间。if(high - low &gt; 15)&#123; //QuickSort();&#125;else&#123; //InsertSort();&#125; 复杂度： 快速排序的时间复杂度：平均情况和最好情况都是O(nlog₂n)；最坏的情况是O(n²)； 空间复杂度是：O(nlog₂n)； 时间复杂度为什么是O(nlog₂n)；因为递归的时间复杂度的计算是递归的深度*每次递归的复杂度。我们递归的深度是log₂n，因为我们每次都是取一半去进行下次递归，好比有n个元素，每次只看一半的元素，这样一直到只剩下一个元素，我们需要看多少次。也就是2的m次方等于n，求m是多少。这跟求二叉树的深度，二分查找等问题是一样的思路。然后每次递归我们都需要对当前区间的每一个元素进行比较，复杂度是O(n)。所以最后的时间复杂度是O(nlog₂n)；至于最坏的情况，是因为快速排序退化成了冒泡排序。 时间复杂度的简易分析 选择排序选择排序选择排序的思路(升序) 顾名思义，通过选择获得最小的元素，将其放入到序列起始位置。 将剩下的元素以此类推。 直到结束。 如图： 代码如下： 1234567891011121314void SelectSort(int arr[], int size)&#123; int min = 0; for(int i = 0; i &lt; size; ++ i)&#123; min = i; for(int j = i + 1; j &lt; size; ++ j)&#123; if(arr[j] &lt; arr[min])&#123; min = j; &#125; &#125; if(min != i)&#123; swap(arr[min], arr[i]); &#125; &#125;&#125; 优化 之前的选择排序只是从前向后排序，每次只排序一个最大值。我们可以同时排序最小值和最大值。这样当元素有n个的时候，我们可以优化最坏情况为循环n/2次。但是时间复杂度并没有减少，数量级还在同一个级别。 123456789101112131415161718192021222324252627void SelectSortOP(int arr[], int size)&#123; int begin = 0; int end = size - 1; for(; begin &lt; end; ++ begin, -- end)&#123; int min = begin; int max = begin; for(int i = begin; i &lt;= end; ++ i)&#123; if(arr[max] &lt; arr[i])&#123; max = i; &#125; if(arr[min] &gt; arr[i])&#123; min = i; &#125; &#125; if(max != end)&#123; swap(arr[max], arr[end]); &#125; //防止min在end，max在begin。 //然后出现交换两次的情况，这样就等于没有交换 if(end == min)&#123; min = max; &#125; if(min != begin)&#123; swap(arr[min], arr[begin]); &#125; &#125;&#125; 复杂度： 时间复杂度：最好、最坏、平均的时间复杂度都是O(n²)； 空间复杂度：O(1)； 堆排序堆排序的思路(升序)： 创建最大堆 开始堆排序：从堆顶获取最大值，取出来，跟序列的最后一个元素交换，这样就让最大的值处于序列的最后面。 进行堆调整，让他重新为最大堆。 一直到所有的值都被处理。 如图： 关于堆的知识点如下：堆的详细解释 代码如下： 12345678910111213141516171819202122232425262728293031323334void Down(int arr[], int index, int size)&#123; int parent = index; int child = parent*2 + 1; while(child &lt; size)&#123; if(child+1 &lt; size &amp;&amp; arr[child] &lt; arr[child+1])&#123; ++ child; &#125; if(arr[child] &gt; arr[parent])&#123; swap(arr[child], arr[parent]); parent = child; child = parent*2 + 1; &#125; else&#123; break; &#125; &#125;&#125;void HeadSort(int arr[], int size)&#123; //建堆 //为什么是size-1-1，因为size-1指的是最后一个的下标。 //再然后完全二叉树的最后一个父节点的计算式为最后一个孩子节点-1除于2。 for(int i = (size-1-1)/2; i &gt;= 0; -- i)&#123; Down(arr, i, size); &#125; int end = size - 1; while(end &gt; 0)&#123; swap(arr[0], arr[end]); //交换完之后，需要重新调整为最大堆，但是最需要调整一次， //因为此时只有堆顶元素不符合大堆的原则。 Down(arr, 0, end); -- end; &#125;&#125; 复杂度： 时间复杂度：平均、最好、最坏的情况都是O(nlog₂n)； 空间复杂度：O(1)； 时间复杂度分析：堆排序的消耗主要在于初始化创建堆和每次调整堆。创建堆的时间复杂度是：O(n)；调整堆的时间复杂度是：O(nlog₂n)；两者相加得到最终的时间复杂度为O(nlog₂n)； 堆排序的时间复杂度分析 插入排序直接插入排序插入排序的思路(升序)： 从序列的最左边选取第一个元素，以它为基准，从第二个开始跟第一个比较。 如果大，向前一个元素比较，一直到比较比前面一个小，插入到他的后面。 依次循环。 如图： 插入排序代码如下： 123456789101112131415161718void InsertSort(int arr[], int size)&#123; for(int i = 0; i &lt; size-1; ++ i)&#123; int j = i+1; //记录下来当前值 int tmp = arr[j]; while(j &gt; 0)&#123; if(tmp &lt; arr[j-1])&#123; arr[j] = arr[j-1]; -- j; &#125; else&#123; break; &#125; &#125; //将当前值赋给插入的位置 arr[j] = tmp; &#125;&#125; 优化 这个优化的方式叫做折半插入排序。也就是我们在进行插入排序的时候，进行到当前的值，说明前面区间肯定已经有序。所以就没有必要依次向前寻找，我可以通过二分查找的方式快速定位。但是实际上的时间复杂度并没有降低，而是稍微的提升了一些效率。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940//二分查找函数，如果arr中有跟key相同的元素，返回该元素的最后一个下标//如果没有，返回最后一个小于key的下一个下标。int BinarySearch(int arr[], int size, int key)&#123; int low = 0; int high = size - 1; //等于不能少 while(low &lt;= high)&#123; int mid = low + (high-low)/2; if(arr[mid] &lt; key)&#123; low = mid+1; &#125; else if(arr[mid] &gt; key)&#123; high = mid-1; &#125; else&#123; int next = mid+1; while(next &lt; size &amp;&amp; arr[next] == arr[mid])&#123; ++ next; ++ mid; &#125; return next; &#125; &#125; return low;&#125;void InsertSortBinary(int arr[], int size)&#123; for(int i = 0; i &lt; size-1; ++ i)&#123; int j = i+1; int tmp = arr[j]; if(tmp &lt; arr[j-1])&#123; int index = BinarySearch(arr, j, tmp); while(j &gt; index)&#123; arr[j] = arr[j-1]; -- j; &#125; arr[index] = tmp; &#125; &#125;&#125; 复杂度： 时间复杂度：平均、最坏情况是：O(n²)；最好的情况是：O(n)； 空间复杂度：O(1)； 最好情况的时间复杂度是有序的，因为不需要交换，只需要遍历一遍。最坏和平均情况的时间复杂度是逆序的情况，遍历一遍序列的同时，每一个都需要一直到序列的第一个进行插入，相当于二次遍历。 希尔排序希尔排序是针对于直接插入排序的一种优化方案。因为直接插入排序的最坏情况时间复杂度为O(n²)，我们通过取间隔的方法，让大数据很快的从最前面移动到后面，不像直插一样，移动n个。从而减小交换的次数。 希尔排序的思路(升序)： 选取步长，根据步长划分区间。同时保证步长最后可以为一。 交换间隔步长的元素，利用插入排序。 每次进行完一趟排序，将步长减小，直到步长为一。此时进行的就是直接插入排序。 代码如下： 1234567891011121314151617181920212223242526void ShellSort(int arr[], int size)&#123; int space = size; int low = 0; //space最后一直都是1 //当space为1的时候，进行的就是插入排序。只是此时的序列已经基本有序，大的成员都在后面。 while(space &gt; 1)&#123; space = space / 3 + 1; //让每一个元素都进行了排序。 for(int front = 0; front &lt; size-space; ++ front)&#123; low = front; int tmp = arr[low+space]; //跳跃式的插入排序，进行排序的元素之间隔了一个space的大小。 while(low &gt;= 0)&#123; if(arr[low] &gt; tmp)&#123; arr[low+space] = arr[low]; low -= space; &#125; else&#123; break; &#125; &#125; arr[low+space] = tmp; &#125; &#125;&#125; 复杂度： 时间复杂度：平均情况O(n^(1.3))；最好情况O(n)；最坏情况O(n²)； 空间复杂度：O(1)； 在这里来说，希尔排序的时间复杂度不好算，需要步长决定。希尔排序的最坏情况就是当序列有序的情况下。 归并排序归并排序归并排序的思路： 首先先执行划分区间，一直划分到区间只有一个元素为止。 在划分的区间内进行比较排序。 一直到结束为止。 归并排序代码如下： 归并函数有两种实现方式，递归是一种，非递归是一种。递归版本需要两个函数，一个用于递归划分区间，另一个用于两个区间的合并排序。这里需要一个辅助空间，防止将原来的数据被覆盖。非递归版本利用迭代 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//递归版本void Merge(int arr[], int* tmp, int left1, int right1, int left2, int right2)&#123; int i = left1; int front = left1; int end = right2; while(left1 &lt;= right1 &amp;&amp; left2 &lt;= right2)&#123; if(arr[left1] &lt;= arr[left2])&#123; tmp[i++] = arr[left1++]; &#125; else if(arr[left1] &gt; arr[left2])&#123; tmp[i++] = arr[left2++]; &#125; &#125; while(left1 &lt;= right1)&#123; tmp[i++] = arr[left1++]; &#125; while(left2 &lt;= right2)&#123; tmp[i++] = arr[left2++]; &#125; while(front &lt;= end)&#123; arr[front] = tmp[front]; front ++; &#125;&#125;void MergeSort(int arr[], int* tmp, int left, int right)&#123; if(left &gt;= right)&#123; return; &#125; int mid = left + (right - left) / 2; MergeSort(arr, tmp, left, mid); MergeSort(arr, tmp, mid+1, right); Merge(arr, tmp, left, mid, mid+1, right);&#125;int main()&#123; int arr[] = &#123;1, 3, 5, 3, 2, 8, 6, 0&#125;; int *tmp = new int[sizeof(arr)/sizeof(arr[0])]; Print(arr, sizeof(arr)/ sizeof(arr[0])); MergeSort(arr, tmp, 0, sizeof(arr)/sizeof(arr[0])-1); Print(arr, sizeof(arr)/ sizeof(arr[0])); delete[] tmp; return 0;&#125;//非递归版本//来源于网路void MergeSortNoR(int *list, int length)&#123; int i, left_min, left_max, right_min, right_max, next; int *tmp = (int*)malloc(sizeof(int) * length); for (i = 1; i &lt; length; i *= 2) for (left_min = 0; left_min &lt; length - i; left_min = right_max)&#123; right_min = left_max = left_min + i; right_max = left_max + i; if (right_max &gt; length) right_max = length; next = 0; while (left_min &lt; left_max &amp;&amp; right_min &lt; right_max) tmp[next++] = list[left_min] &gt; list[right_min] ? list[right_min++] : list[left_min++]; while (left_min &lt; left_max) list[--right_min] = list[--left_max]; while (next &gt; 0) list[--right_min] = tmp[--next]; &#125; free(tmp);&#125; 优化 归并排序的优化，第一，使用递归版本的时候，我们可以在当成员个数比较少的时候，转换为使用插入排序，这样可以减小栈桢的开销。第二，不使用递归版本，使用迭代版本。 复杂度： 时间复杂度：平均、最好、最坏情况都是：O(nlog₂n) 空间复杂度：O(n)或者是O(1)； 时间复杂度一直都是O(nlog₂n)；因为不管是什么情况都是要采取一样的步骤，不因为成员是否有序而改变。空间复杂度是因为使用了辅助空间。如果我们不使用辅助空间，直接在源数据空间内交换的话，就是O(1)。 分布排序基数排序基数排序其实是桶排序的扩展，对于整形来说，基数排序首先先从个位开始，根据个位的值大小放入指定的数组中，数组的大小是十，下表表示值。然后过渡到十位、百位。这样依次放入取出排序，就可以了。 计数排序计数排序适合于大于零并且数据之间都比较相近的情况，当确定数据的大小，开辟一个以最大值为下标的数组。将数组初始化为全0；然后依次遍历序列让数组对应的下标的值加一。最后将数组从头到尾扫描，数据是多少代表对应下标有多少个。 复杂度、稳定性集合]]></content>
      <categories>
        <category>knowledge</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决VMware 12安装VMware Tools后共享文件夹不出现的问题]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3VMware%2012%E5%AE%89%E8%A3%85VMware%20Tools%E5%90%8E%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[VMware Workstation Pro 12.0中centos 7安装VMware Tools的时候，发现安装完成，在/mnt/hgfs/目录下，没有自己显示与windows共享的文件夹。可以通过以下步骤修复。 一：升级VMware为14版本，问题解决二：通过修改VMware Tools的文件解决问题。安装VMware-Workstation-Pro 12.0的VMwar Tools步骤，看官方文档。按照官方文档一直到进入 cd vmware-tools-distrib/ 在按照官方文档执行./vmware-install.pl之前，对安装文件进行以下修改。 cd lib/modules/source/ tar xvf vmhgfs.tar 得到vmhgfs-only目录 cd vmhgfs-only vim page.c 将1639行(3, 19, 0)修改为(3, 10, 0) #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 19, 0) 改成下面的值 #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 10, 0) 这个原因是因为centos 7的内核版本是 3.10.0。 修改完成之后，请用:wq!强制保存只读文件。 删除之前的包，将vmhgfs-only重新打包 cd .. rm vmhgfs.tar tar cvf vmhgfs.tar vmhgfs-only/ rm -rf vmhgfs-only/ 回到 vmware-tools-distrib目录，执行安装 cd ../../.. ./vmware-install.pl 一路默认，完成VMware Tools的安装。参考文档]]></content>
      <categories>
        <category>Linux</category>
        <category>method</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[剑指offer]在旋转数组中找最小的值]]></title>
    <url>%2F%5B%E5%89%91%E6%8C%87offer%5D%E5%9C%A8%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E6%9C%80%E5%B0%8F%E7%9A%84%E5%80%BC.html</url>
    <content type="text"><![CDATA[题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个 非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路本题最简单的做法就是从头到尾的遍历。这样一定可以得到结果，只是这样操作的时间复杂度是O(n)。没有利用上旋转这个题目特性。正确的思路是，利用二分查找的思想。让一个begin下标表示数组的开始，一个end下标表示数组的结束，mid表示数组的中间值。通过三者值的比较得到范围。如果mid的值大于begin的值，说明最小值的范围在mid到end之间。反之在begin到mid之间。依次缩小范围，直到找到最小值。 注意1、存在一种情况，并没有旋转。也就是数组的第一个元素就是最小值。可以通过比较一开始begin和end的值判断，如果begin的值小于end的值，那么直接返回begin的值即可。2、判断停止的条件是当begin的下一个值就是end的时候，这个时候end一定是最小值。因为begin已经到达最大值，end自然是最小值了。3、判断的时候请注意重复值的情况。如果出现一种情况，begin、mid、end对应的值都一样。这个时候就需要用遍历的思路来执行查找。4、需要注意边界值的判断，如果边界值的判断出问题，可能会出现死循环。 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; if(rotateArray.size() == 0) return 0; int size = rotateArray.size(); int begin = 0; int end = size - 1; int mid = 0; while(rotateArray[begin] &gt;= rotateArray[end])&#123; if(begin+1 == end)&#123; mid = end; break; &#125; mid = begin + (end-begin)/2; if(rotateArray[mid] == rotateArray[begin] &amp;&amp; rotateArray[mid] == rotateArray[end]) return MinNumber(rotateArray, begin, end); else if(rotateArray[mid] &gt;= rotateArray[begin]) begin = mid; else if(rotateArray[mid] &lt;= rotateArray[end]) end = mid; &#125; return rotateArray[mid]; &#125; int MinNumber(const vector&lt;int&gt;&amp; arr, int begin, int end)&#123; int result = begin; for(int i = result+1; i &lt;= end; ++i)&#123; if(arr[i] &gt; arr[result]) break; result = i; &#125; return arr[result]; &#125;&#125;;]]></content>
      <categories>
        <category>practice</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二维数组中的查找]]></title>
    <url>%2F%5B%E5%89%91%E6%8C%87offer%5D%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html</url>
    <content type="text"><![CDATA[题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路：第一行到最后一行是递增，第一列到最后一列是递增，那么肯定会有四个特殊的点。分别是最小的，最大的，行最大列最小，列最大行最小。如果要入手解题从这四个点入手。1、最小的，如图中1。寻找的时候，如果target比1大，那么该往何处走？不清楚。所以最小点不适合，同理最大点。2、行最大列最小，如图左下角4。如果target比4大，那么向当前列右走。如果target跟他比4小，那么向当前行上走。同理列最大行最小。 代码：12345678910111213141516171819202122class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int size = array.size(); if(size != 0)&#123; int row = size - 1; int col = 0; while(row &gt;= 0 &amp;&amp; col &lt; array[0].size())&#123; if(array[row][col] == target)&#123; return true; &#125; else if(array[row][col] &lt; target)&#123; ++ col; &#125; else &#123; -- row; &#125; &#125; &#125; return false; &#125;&#125;; vector构成的二维数组创建二维数组赋值可以使用vector函数resize()和函数assign()对数组大小进行修改。1、利用构造函数直接创建。1234567//利用构造函数直接创建arr[2][3]vector&lt;vector&lt;int&gt; &gt;arr(2, vector&lt;int&gt;(3));for(int i = 0; i &lt; arr.size(); ++i)&#123; for(int j = 0; j &lt; arr[0].size(); ++j)&#123; arr[i][j] = i+j; &#125;&#125; 2、利用函数resize()或函数assign()1234567891011//利用创建的arr1[3][3]改变为arr1[3][4]vector&lt;vector&lt;int&gt; &gt;arr1(3, vector&lt;int&gt;(3));for(int i = 0; i &lt; arr1.size(); ++i)&#123; arr1[i].resize(4);&#125;for(int i = 0; i &lt; arr1.size(); ++i)&#123; for(int j = 0; j &lt; arr[0].size(); ++j)&#123; arr1[i][j] = i+j; &#125;&#125; 遍历二维数组1、获取下标，利用operator[]函数123456for(int i = 0; i &lt; arr.size(); ++i)&#123; for(int j = 0; j &lt; arr[i].size(); ++j)&#123; cout &lt;&lt; arr[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 2、利用迭代器。利用迭代器的时候，有点难理解。it1是二维vector迭代器，it2是一维vector迭代器。*it1得到的是一个一维vector。*it2得到的是int类型。 123456789vector&lt;vector&lt;int&gt; &gt;::iterator it1;vector&lt;int&gt;::iterator it2;for(it1 = arr1.begin(); it1 != arr1.end(); ++it1)&#123; for(it2 = (*it1).begin(); it2 != (*it1).end(); ++it2)&#123; cout &lt;&lt; *it2 &lt;&lt; " "; cout &lt;&lt; endl; &#125;&#125; 输出图示：]]></content>
      <categories>
        <category>practice</category>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[哈弗曼树及文件压缩]]></title>
    <url>%2F%E5%93%88%E5%BC%97%E6%9B%BC%E6%A0%91%E5%8F%8A%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9.html</url>
    <content type="text"><![CDATA[HuffmanTree定义哈弗曼树是一种优化的二叉树，称为最优二叉树，是加权路径长度最小的二叉树。所谓权值在这里指的是节点中的数据。本文的哈弗曼树用数组提供数据，例如：arr[]={1,2,3,4,5,6}创建的哈弗曼树见下图：图中蓝色的节点值是数组arr提供，红色节点值是两个孩子节点值相加得到。 名词解释节点的权值：权就相当于重要程度，通过一个具体的数字来表示路径：在树中从一个节点到另一个节点的分支。路径长度：一条路径上的分支数量。树的路径长度：从树的根节点到每个节点的路径长度之和。树的带权路径长度：树中各个叶子节点的路径长度*该叶子节点的权的和。 性质1、根节点值是所有的叶子节点值相加得到2、创建哈弗曼树的节点值全部在叶子节点上，而且只在叶子节点出现3、哈夫曼树的加权路径长度是最小的，这个是因为权值大的节点离根节点近，权值小的节点离根节点远。 创建HuffmanTree1、取出数组中最小的两个值，组成最小的一个分支，用两者的和作为两者的父亲节点并在原数组中替换两者。2、依次循环直到数组所有符合要求的值被使用。使用示例：arr[] = {1,2,3,4,5,6}; 节点定义哈弗曼树节点采用二叉链结构，包含关键值_val；指向左节点的指针_left；指向右节点的指针_right。123456789101112template &lt;class T&gt;struct HuffmanTreeNode&#123; T _val; HuffmanTreeNode&lt;T&gt;* _left; HuffmanTreeNode&lt;T&gt;* _right; HuffmanTreeNode(const T&amp; val) :_val(val) ,_left(NULL) ,_right(NULL) &#123;&#125;&#125;; 构造函数构造函数提供了两个，一个是空的构造函数，防止因为没有默认构造函数产生错误。另一个是带参的构造函数。 参数解释arr是一个数组名，用来提供创建哈弗曼树的数值来源；size是数组的大小，这个大小在构建最小堆的时候会用到；invalid指的是非法值，如果数组中有一些特定的值，不希望插入到哈弗曼树中，用这个值来判断。一般来说，所有的非法值是相同的。 构建的思想构建哈夫曼树的方式在上面已经提到，但是如何用代码来实现呢？这里可以借用最小堆来实现。如果不太熟悉最小堆可以看这个传送门%E7%9A%84%E5%AE%9E%E7%8E%B0.html)。每次取最小堆的堆顶元素第一次是作为左节点，第二次作为右节点。同时将两者出堆，接着用两者的关键值创建一个父亲节点入堆。利用循环就可以创建出来哈弗曼树了。至于为什么要用最小堆，根据前述的方法，我们需要每次取数组中的最小的两个值来构建新的节点，用最小堆的话可以分两次取堆顶数据，然后让创建的新的节点再入堆。最小堆会自动调整，不需要人为参与修改。而且堆的存储机制就是动态增长的数组，天然符合这里利用数组传参的要求。其中这里传入给最小堆的数据类型是节点指针，为什么是节点指针很好理解。如果是节点本身，那么我们就没有办法将之前创建的内容链接在一起，见下图：为什么不用节点的引用呢？引用的话不太好，如果是引用，可能出现节点结构太大的情况，这样开销有点大，不划算。这里还需要解释一下，需要自己创建一个比较仿函数，因为Node是一个自定义类型，在创建最小堆的时候是没有办法知道比较方式的，仿函数如下：(其中为了书写方便，在HuffmanTree类中定义了节点Node)123456789typedef HuffmanTreeNode&lt;T&gt; Node;struct NodeCompare&#123; //const Node* left, const Node* right //wrong bool operator()(Node* left, Node* right)&#123; return left-&gt;_val &lt; right-&gt;_val; &#125;&#125;; 这里需要注意的是，仿函数的参数不能够定义为const对象。需要修改。构建的代码如下：注意循环结束的条件是最小堆中只有一个元素，因为此时已经构建完成。12345678910111213141516171819202122232425HuffmanTree() :_root(NULL)&#123;&#125;HuffmanTree(T* arr, size_t size, const T&amp; invalid)&#123; //注意这里使用的是Node* Heap&lt;Node*, NodeCompare&gt; minheap; for(size_t i = 0; i &lt; size; ++i)&#123; if(arr[i] != invalid)&#123; //Node* minheap.Push(new Node(arr[i])); &#125; &#125; //minheap.Size()&gt;1 while(minheap.Size() &gt; 1)&#123; Node* left = minheap.Top(); minheap.Pop(); Node* right = minheap.Top(); minheap.Pop(); Node* parent = new Node(left-&gt;_val + right-&gt;_val); parent-&gt;_left = left; parent-&gt;_right = right; minheap.Push(parent); &#125; _root = minheap.Top();&#125; 析构函数析构函数通过递归实现，内部调用Destroy实现。123456789101112//destructor~HuffmanTree()&#123; Destroy(_root); _root = NULL;&#125;void Destroy(Node* root)&#123; if(root)&#123; Destroy(root-&gt;_left); Destroy(root-&gt;_right); delete root; &#125;&#125; 获取根节点函数1234//GetRootNode* GetRoot()&#123; return _root;&#125; 补充因为没有实现拷贝构造和赋值运算符的重载，所以将他们都声明为私有成员变量。防止错误使用导致未知错误 文件压缩及解压缩有了哈弗曼树，我们就可以利用哈弗曼树创建哈夫曼编码，通过哈夫曼编码可以实现文件压缩的功能。 哈夫曼编码所谓哈夫曼编码是在哈弗曼树的基础上，定义向左的路径为零，向右的路径为一。这样定义以后，每一个叶子节点都会有一个唯一的编码值。而重要的是，在哈弗曼树中，所有叶子节点就是我们用来构建哈弗曼树的原值。使用示例：arr[] = {1,2,3,4,5,6};如下图：需要注意的是，哈夫曼编码不是唯一的，就算是同样的原值，因为插入的顺序不一样会导致不同的编码，但是毋庸置疑的是，每一个叶子节点一定会有唯一的编码值。 压缩思路1、扫描文件内容，统计文件中字符出现的次数。2、利用文件出现次数构建哈弗曼树。3、创建哈夫曼编码。4、将创建哈弗曼树的字符及其对应出现次数写入压缩文件中，用于解压使用。5、将哈夫曼编码替换原子符写入压缩文件。 压缩原理举例：文件test.txt中内容：aaaaaabbbbbccccdddeef其中字符出现的次数统计：a-&gt;6；b-&gt;5；c-&gt;4；d-&gt;3；e-&gt;2；f-&gt;1。利用次数构建的哈弗曼树和编码如下：图中黑色字体是出现的字符，蓝色数字是对应出现的次数，红色字体是构建时两字符出现次数相加之和。为什么通过哈夫曼编码可以压缩文件？我们通过编码将原字符替换，只有当编码的长度超过一个字节的时候(也就是八个比特位)才会比替换之前的字符大小要大。但是出现次数多的字符的编码都十分的短，出现次数少的字符编码才会超过一个字节。这样抵消之下，肯定是相比于压缩之前文件大小要小。上例子中，写入压缩文件的压缩编码如下： 压缩与解压代码分析结构体分析结构体CharInfo是用来存储字符、字符出现的次数、字符的编码三者的结构类型。其中将_count定义为long long类型，防止字符出现的次数超过了整型表示范围。_code用string类型；通过这个结构体可以将三者紧紧地联系在一起。其中对该结构体重载了!=、+、&lt; 这三个运算符。在代码中都会用到。1234567891011121314151617181920212223typedef long long LongType;struct CharInfo&#123; char _ch; LongType _count; string _code; //for invalid bool operator!=(const CharInfo&amp; info)&#123; return _count != info._count; &#125; //for minheap.parent CharInfo operator+(const CharInfo&amp; info)&#123; CharInfo tmp; tmp._count = _count + info._count; return tmp; &#125; //for compare bool operator&lt;(const CharInfo&amp; info)&#123; return _count &lt; info._count; &#125;&#125;; 构造函数本文使用的文件压缩类类名为FileCompress。类的私有成员是一个CharInfo类型的数组。其大小是256,因为字符包括汉字一共只有256个。所以直接指定数组大小就好。1CharInfo _infos[256]; 构造函数直接将数组的下标赋值给结构体CharInfo的_ch成员，因为字符型数据就是通过整型转换过去的。这样就相当于给数组的每一个元素都指定好了对应字符。例如：_infos[97]对应字符’a’。1234567FileCompress()&#123; for(size_t i = 0; i &lt; 256; ++i)&#123; _infos[i]._ch = i; _infos[i]._count = 0; _infos[i]._code = " "; &#125;&#125; 压缩函数压缩函数分为五步，步骤在代码中详细的分析，这里分别说一下每个步骤注意的点：1、统计。统计时，要注意用二进制方式打开文件，用二进制模式打开的文件不会对任何字符有转义的动作，文本模式下，window操作系统会将’\n’和’\r’进行编码转换。而且写入的时候，也需要用二进制方式写入，否则会出现压缩没有问题，但是解压的时候提前结束的情况。2、构建哈弗曼树。定义非法值，其字符个数为零个。3、构建哈夫曼编码调用函数。4、写入构建哈弗曼树的字符和对出现次数。调用fopen函数，要将string类转换为char*格式；创建一个没有string类的临时结构体，因为构建哈弗曼树只需要ch和count；将构件用的源写入之后，再写入一个标志位，用字符个数为-1表示，用于跟替换的编码相互隔开。5、用编码将字符替换。在进行这一步之前，将文本指针指向文章开头。因为统计字数的时候，文本指针已经指向了文末。替换的步骤是：从源文件中获取一个字符，通过该字符获得之前已经编好的哈夫曼编码，获取编码的每一个位，如果编码为’1’，将value当前位置为1；反之，置为0。依次进行，当该字符的编码全部用完，获取下一个字符，一直到value的八个位都替换完成， 将value写入压缩文件中。为什么要到一个字节才写入，这个是因为函数能写入的最小的单位是字节。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void Compress(const char* file)&#123;//fopen的打开方式，用二进制方式打开 FILE* fout = fopen(file, "rb"); assert(fout); //1、统计文章字符出现的次数 //fgetc的返回值是整型 int ch = fgetc(fout); while(ch != EOF)&#123; ++ _infos[(unsigned char)ch]._count; ch = fgetc(fout); &#125; //2、构建哈夫曼树 CharInfo invilad; invilad._count = 0; HuffmanTree&lt;CharInfo&gt; tree(_infos, 256, invilad); //code不要初始化，不然会出现编码错误 string code; //3、构建哈夫曼编码 GenerateHuffmanTreeCode(tree.GetRoot(), code); //4、写入构建哈弗曼树的字符和对出现次数 string compressfile = file; compressfile += ".huffman"; FILE* fin = fopen(compressfile.c_str(), "wb"); assert(fin); for(int i = 0; i &lt; 256; ++i)&#123; if(_infos[i]._count != 0)&#123; TmpCharInfo info; info._ch = _infos[i]._ch; info._count = _infos[i]._count; fwrite(&amp;info, sizeof(info), 1, fin); &#125; &#125; //设置判断位，让其跟压缩内容分割开来 TmpCharInfo info; info._count = -1; fwrite(&amp;info, sizeof(info), 1, fin); //5、用编码将字符替换。 fseek(fout, 0, SEEK_SET); ch = fgetc(fout); //value是用来写入到压缩文件中的一个字节 char value = 0; //pos两个作用，一个是当前替换的位置，另一个是用来判断是不是已经满八个比特位 size_t pos = 0; while(ch != EOF)&#123; string&amp; code = _infos[(unsigned char)ch]._code; for(size_t i = 0; i &lt; code.size(); ++i)&#123; if(code[i] == '1')&#123; value |= (1 &lt;&lt; pos); &#125; else if(code[i] == '0')&#123; value &amp;= ~(1 &lt;&lt; pos); &#125; else&#123; assert(false); &#125; ++ pos; if(pos == 8)&#123; fputc(value, fin); value = pos = 0; &#125; &#125; ch = fgetc(fout); &#125; //特殊处理未满八个位也将剩下的字符全部写入。 //正是因为这一步，才会有说上图中用来填充的五个零的出现。 if(pos &gt; 0)&#123; fputc(value, fin); &#125; fclose(fout); fclose(fin);&#125; 构建哈夫曼编码函数这个函数利用递归实现，如果当前走向哈弗曼树的左子树code+0，如果是右子树code+1。如果当前节点是叶子节点那么修改对应字符的_code为code的值。因为这里用的code是值传递，当递归函数返回上一层的时候，当前层的修改不会被带回去。如上图中的根节点6，它的code是空字符，第一层递归的时候，进入节点3，此时的code是值传递，会进行一次值拷贝，节点3的code是“0”，再下一层，进入节点1，同样是值拷贝，节点1的code是“00”。此时节点1的叶子节点，写入字符’1’的_code为字符串”00”。这个就是它的编码。然后退回到节点3，它的code依然是“0”。然后再进入到节点2，它的code是“01”，叶子节点，写入字符’2’的_code是字符串”01”。这个是他的编码。123456789101112//GenerateHuffmanTreeCodevoid GenerateHuffmanTreeCode(const HTreeNode* root, string code)&#123; if(root == NULL) return; if(root-&gt;_left == NULL &amp;&amp; root-&gt;_right == NULL)&#123; //change _infos _infos[(unsigned char)(root-&gt;_val._ch)]._code = code; return; &#125; GenerateHuffmanTreeCode(root-&gt;_left, code+'0'); GenerateHuffmanTreeCode(root-&gt;_right, code+'1');&#125; 解压函数解压函数的思路：1、从压缩文件中读取构建哈弗曼树的字符和次数2、构建哈夫曼树3、从压缩文件中读取编码，结合哈弗曼树将编码翻译为字符写入解压文件中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//unCompressvoid UnCompress(const char* file)&#123; //获取压缩文件名字，同时设定解压文件的文件名 string uncompressfile = file; size_t pos = uncompressfile.rfind('.'); if(pos == string::npos)&#123; perror("pos wrong"); exit(1); &#125; uncompressfile.erase(pos); uncompressfile += ".unhuffman"; //解压 FILE* fin = fopen(uncompressfile.c_str(), "wb"); assert(fin); //从压缩文件中获取构建哈弗曼树的字符和对应的出现的次数。 FILE* fout = fopen(file, "rb"); assert(fout); TmpCharInfo info; fread(&amp;info, sizeof(info), 1, fout); while(info._count != -1)&#123; _infos[(unsigned char)info._ch]._ch = info._ch; _infos[(unsigned char)info._ch]._count = info._count; fread(&amp;info, sizeof(info), 1, fout); &#125; //创建哈弗曼树，用来翻译编码使用 CharInfo invalid; invalid._count = 0; HuffmanTree&lt;CharInfo&gt; tree(_infos, 256, invalid); HTreeNode* root = tree.GetRoot(); HTreeNode* cur = root; LongType num = root-&gt;_val._count; int ch = fgetc(fout); //解决文件中只有一个字符的情况 if(root-&gt;_left == NULL)&#123; while(num--)&#123; fputc(root-&gt;_val._ch, fin); &#125; &#125; else&#123; while(ch != EOF)&#123; for(size_t i = 0; i &lt; 8; ++i)&#123; //按照编码规则，遇到1向右走，遇到0向左走。 if(((unsigned char)ch &amp; (1 &lt;&lt; i)) == 0)&#123; cur = cur-&gt;_left; &#125; else&#123; cur = cur-&gt;_right; &#125; //叶子节点写入翻译字符 if(cur-&gt;_left == NULL &amp;&amp; cur-&gt;_right == NULL)&#123; //限制翻译的字符的个数，防止将补充的字符也翻译。 if(num-- == 0)&#123; break; &#125; fputc(cur-&gt;_val._ch, fin); //指向root，解压下一个字符 cur = root; &#125; &#125; //当前读取的一个字节已经用完，继续解压下一个字节 ch = fgetc(fout); &#125; &#125; fclose(fin); fclose(fout);&#125; 注意：1、读取编码转换字符的方法是：获取到的编码一定是一个字节的，但是其中可能包含了多个编码，此时结合哈弗曼树，如果编码遇到的是’1’，在哈弗曼树中向右子树中走，如果是’0’，在哈夫曼中向左子树走。一直遇到叶子节点的时候，表示此时已经翻译成功一个字符，将该字符写入解压文件中。同时将指向节点的指针重新指向根节点，此时需要解压下一个字符。2、如果原文件中只有一个字符，此时是构不成哈弗曼树的，需要特殊处理这种情况。3、需要控制翻译的字符的个数。因为压缩文件中最后几个位的字符可能是当初为了写入一个字节而填充的，这些并不是源文件中含有的字符。因此这些字符不能被翻译。根据哈弗曼树的性质可以知道，根节点的值就是所有叶子节点的关键值之和。所以可以获取根节点的关键值，每翻译一个字符，就将该关键值减一，当关键值为零的时候表示原文件中所有的字符都已经被翻译出来了，此时不管是否还能读取到字符，都应该直接跳出写入字符的循环，防止写入多余的无用值。 代码堆的代码%E7%9A%84%E5%AE%9E%E7%8E%B0.html)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291//Huffman.h#pragma once#include "Heap.h"template &lt;class T&gt;struct HuffmanTreeNode&#123; T _val; HuffmanTreeNode&lt;T&gt;* _left; HuffmanTreeNode&lt;T&gt;* _right; HuffmanTreeNode(const T&amp; val) :_val(val) ,_left(NULL) ,_right(NULL) &#123;&#125;&#125;;template &lt;class T&gt;class HuffmanTree&#123; typedef HuffmanTreeNode&lt;T&gt; Node; struct NodeCompare&#123; //const Node* left, const Node* right //wrong bool operator()(Node* left, Node* right)&#123; return left-&gt;_val &lt; right-&gt;_val; &#125; &#125;;public: //constructor HuffmanTree() :_root(NULL) &#123;&#125; HuffmanTree(T* arr, size_t size, const T&amp; invalid)&#123; Heap&lt;Node*, NodeCompare&gt; minheap; for(size_t i = 0; i &lt; size; ++i)&#123; if(arr[i] != invalid)&#123; //Node* minheap.Push(new Node(arr[i])); &#125; &#125; //minheap.Size()&gt;1 while(minheap.Size() &gt; 1)&#123; Node* left = minheap.Top(); minheap.Pop(); Node* right = minheap.Top(); minheap.Pop(); Node* parent = new Node(left-&gt;_val + right-&gt;_val); parent-&gt;_left = left; parent-&gt;_right = right; minheap.Push(parent); &#125; _root = minheap.Top(); &#125; //destructor ~HuffmanTree()&#123; Destroy(_root); _root = NULL; &#125; void Destroy(Node* root)&#123; if(root)&#123; Destroy(root-&gt;_left); Destroy(root-&gt;_right); delete root; &#125; &#125; //GetRoot Node* GetRoot()&#123; return _root; &#125;private: HuffmanTree(const HuffmanTree&lt;T&gt;&amp; huf); Node*&amp; operator=(const HuffmanTree&lt;T&gt;&amp; huf); Node* _root;&#125;;void TestHuffmanTree()&#123; int arr[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; size_t Size = sizeof(arr)/sizeof(arr[0]); HuffmanTree&lt;int&gt; hp(arr, Size, arr[0]); cout &lt;&lt; hp.GetRoot()-&gt;_val &lt;&lt; endl;&#125;//Compress.h#pragma once#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;assert.h&gt;#include "HuffmanTree.h"typedef long long LongType;struct CharInfo&#123; char _ch; LongType _count; string _code; //for invalid bool operator!=(const CharInfo&amp; info)&#123; return _count != info._count; &#125; //for minheap.parent CharInfo operator+(const CharInfo&amp; info)&#123; CharInfo tmp; tmp._count = _count + info._count; return tmp; &#125; //for compare bool operator&lt;(const CharInfo&amp; info)&#123; return _count &lt; info._count; &#125;&#125;;class FileCompress&#123; typedef HuffmanTreeNode&lt;CharInfo&gt; HTreeNode; struct TmpCharInfo&#123; unsigned char _ch; LongType _count; &#125;;public: //constructor FileCompress()&#123; for(size_t i = 0; i &lt; 256; ++i)&#123; _infos[i]._ch = i; _infos[i]._count = 0; _infos[i]._code = " "; &#125; &#125; //Compress void Compress(const char* file)&#123; FILE* fout = fopen(file, "rb"); assert(fout); int ch = fgetc(fout); while(ch != EOF)&#123; ++ _infos[(unsigned char)ch]._count; ch = fgetc(fout); &#125; //create HuffmanTree CharInfo invilad; invilad._count = 0; HuffmanTree&lt;CharInfo&gt; tree(_infos, 256, invilad); string code; GenerateHuffmanTreeCode(tree.GetRoot(), code); //write string compressfile = file; compressfile += ".huffman"; FILE* fin = fopen(compressfile.c_str(), "wb"); assert(fin); //write source for(int i = 0; i &lt; 256; ++i)&#123; if(_infos[i]._count != 0)&#123; TmpCharInfo info; info._ch = _infos[i]._ch; info._count = _infos[i]._count; fwrite(&amp;info, sizeof(info), 1, fin); &#125; &#125; //flag of the end of source TmpCharInfo info; info._count = -1; fwrite(&amp;info, sizeof(info), 1, fin); //write code fseek(fout, 0, SEEK_SET); ch = fgetc(fout); char value = 0; size_t pos = 0; while(ch != EOF)&#123; string&amp; code = _infos[(unsigned char)ch]._code; for(size_t i = 0; i &lt; code.size(); ++i)&#123; if(code[i] == '1')&#123; value |= (1 &lt;&lt; pos); &#125; else if(code[i] == '0')&#123; value &amp;= ~(1 &lt;&lt; pos); &#125; else&#123; assert(false); &#125; ++ pos; if(pos == 8)&#123; fputc(value, fin); value = pos = 0; &#125; &#125; ch = fgetc(fout); &#125; if(pos &gt; 0)&#123; fputc(value, fin); &#125; fclose(fout); fclose(fin); &#125; //GenerateHuffmanTreeCode void GenerateHuffmanTreeCode(const HTreeNode* root, string code)&#123; if(root == NULL) return; if(root-&gt;_left == NULL &amp;&amp; root-&gt;_right == NULL)&#123; //change _infos _infos[(unsigned char)(root-&gt;_val._ch)]._code = code; return; &#125; GenerateHuffmanTreeCode(root-&gt;_left, code+'0'); GenerateHuffmanTreeCode(root-&gt;_right, code+'1'); &#125; //unCompress void UnCompress(const char* file)&#123; //change the name of file string uncompressfile = file; size_t pos = uncompressfile.rfind('.'); if(pos == string::npos)&#123; perror("pos wrong"); exit(1); &#125; uncompressfile.erase(pos); uncompressfile += ".unhuffman"; //uncompress //open fin FILE* fin = fopen(uncompressfile.c_str(), "wb"); assert(fin); //read to get ch and count FILE* fout = fopen(file, "rb"); assert(fout); TmpCharInfo info; fread(&amp;info, sizeof(info), 1, fout); while(info._count != -1)&#123; _infos[(unsigned char)info._ch]._ch = info._ch; _infos[(unsigned char)info._ch]._count = info._count; fread(&amp;info, sizeof(info), 1, fout); &#125; //create HuffmanTree CharInfo invalid; invalid._count = 0; HuffmanTree&lt;CharInfo&gt; tree(_infos, 256, invalid); HTreeNode* root = tree.GetRoot(); HTreeNode* cur = root; LongType num = root-&gt;_val._count; int ch = fgetc(fout); //olny root if(root-&gt;_left == NULL)&#123; while(num--)&#123; fputc(root-&gt;_val._ch, fin); &#125; &#125; //more than root else&#123; while(ch != EOF)&#123; for(size_t i = 0; i &lt; 8; ++i)&#123; if(((unsigned char)ch &amp; (1 &lt;&lt; i)) == 0)&#123; cur = cur-&gt;_left; &#125; else&#123; cur = cur-&gt;_right; &#125; if(cur-&gt;_left == NULL &amp;&amp; cur-&gt;_right == NULL)&#123; if(num-- == 0)&#123; break; &#125; fputc(cur-&gt;_val._ch, fin); cur = root; &#125; &#125; ch = fgetc(fout); &#125; &#125; fclose(fin); fclose(fout); &#125;protected: CharInfo _infos[256];&#125;;void TestFileCompress()&#123; FileCompress fc; FileCompress fcu; fc.Compress("file"); fcu.UnCompress("file.huffman");&#125;]]></content>
      <categories>
        <category>knowledge</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[堆(heap)的实现]]></title>
    <url>%2F%E5%A0%86(heap)%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[定义最大堆和最小堆堆是一种完全二叉树数据结构。一般他的实现可以使用链表或者数组。因为是完全二叉树，所以使用数组作为存储结构更加方便。如果有一个数组a[]={2,3,1,5,6,4};可以创建两种堆，最大堆和最小堆。所谓最大堆指的是父亲节点的值比孩子节点的值要大，最小堆指的是父亲节点的值要比孩子节点的值要小。如下图：生成最大堆或最小堆实际上就是对数组中的数据，按照最大堆或最小堆的规则进行交换，这里的二叉树只不过是抽象出来的形式，其本质还是他的存储结构——数组。 完全二叉树用vector表示为什么完全二叉树用数组表示呢？这个是因为完全二叉树的特性决定的。由于是完全二叉树，所以在全部节点不是有两个孩子节点就是叶子节点。假设父亲节点的下标是n，那么用数组的方式，可以通过下标直接找到其孩子节点。(左孩子节点的下标是2*n+1,右孩子节点的下标是2*n+2。)比如上述例子中，父亲节点是a[1],那么左孩子节点是a[3]，右孩子节点是a[4]。同时如果知道孩子节点也可以知道父亲节点的下标，不管是左孩子还是右孩子节点，如果其下标是n，那么他父亲节点的下标是(n-1)/2取整。正是因为完全二叉树可以直接通过数组下标的方式很方便的确定父子节点，所以通过数组存储是很有效的。但是因为堆是动态增长的结构，所以采取vector为存储结构。 构造堆并调整123456789101112Heap()&#123;&#125;Heap(T* a, size_t n)&#123; //reserve _array.reserve(n); for(size_t i = 0; i &lt; n; ++i)&#123; _array.push_back(a[i]); &#125; for(int i = (_array.size()-2)/2; i &gt;= 0; --i)&#123; AdjustDwon(i); &#125;&#125; 这里提供了两个构造函数，一个是空构造函数，用来创建一个空的堆对象；一个是传参的构造函数，用来创建符合要求的堆对象。 空构造函数创建空的堆对象的构造函数，尽管函数体没有任何的执行语句，但是当该构造函数被调用的时候，类的私有成员vector&lt;T&gt; _array;会调用他的默认构造函数来构造一个_array对象。按道理来说这个构造函数有些画蛇添足，是因为一般来说，默认的构造函数就可以实现这个功能。可是由于有了自己定义的构造函数，编译器不会再创建默认的构造函数，所以还是需要自己显示的创建空构造函数，它的功能和默认的构造函数是一样的。 传参的构造函数带参的构造函数是我们主要用到的构造函数，这里有几个点需要说明一下 reserve()函数的使用reserve函数作为vector容器的内置函数，它的作用是开辟指定大小的空间。因为我们已经知道了需要开辟的空间大小，所以为了节省需要多次开辟空间的导致的消耗，就利用函数reserve一次性开辟好空间，这样会节省开销。 Adjustdown函数仿函数再说明Adjustdown函数之前，先解释一下仿函数。仿函数顾名思义就是类似函数。其本质是对运算符()的重载，通过对()的重载，就产生了类似于函数调用的感觉，比如上述代码实现中一样，调用的时候给人的感觉就是仿函数：上面这例子中定义了一个Less对象less，调用仿函数的时候就像调用了一个名为less的函数。下文代码实现了两个仿函数，分别用于创建最大堆和最小堆。在Adjustdown函数中会用到。123456789101112131415//仿函数//Lesstemplate &lt;class T&gt;struct Less&#123; bool operator()(const T&amp; left, const T&amp; right)&#123; return left &lt; right; &#125;&#125;;//Greatertemplate &lt;class T&gt;struct Greater&#123; bool operator()(const T&amp; left, const T&amp; right)&#123; return left &gt; right; &#125;&#125;; Adjustdown函数(一次向下调整函数)，本文用最大堆来讲解一次向下调整函数的出现，是为了保证插入的数据在数组中是维持了最大堆或最小堆的性质。向下调整的思路很简单，查看当前父亲节点的孩子节点，如果父亲节点比两个孩子节点都要大，那么不需要交换位置；如果父亲节点比孩子节点中较大的要小，那么交换两者。这时，再查看父亲节点是否比当前的两个孩子都要大。一次循环即可。流程见下图： 通过上图的调节，就完成了一次调整，起码保证了一条路径上的节点是维持了最大堆的特性。调整是利用循环实现的，循环结束的条件就是孩子节点的下标没有超过vector的大小或者父亲节点比孩子节点都要大。 小技巧因为parent替换的lchild和rchild中较大的一个，那么我们怎么确定较大的那一个呢。我们可以这样，不定义左右孩子节点，只定义一个孩子节点，这个孩子节点是左孩子节点。然后用这个child节点和下标比它大一个值的节点比较大小(因为下标比它大一个值的节点一定是右孩子)，让大的作为child的值，这样就保证了child一定是孩子节点中较大的那一个。注意的是，在比较大小之前先判断右孩子是不是存在。同时，循环结束的判断可以直接用child判断是否超过vector的大小。这里判断大小的时候，就利用到了仿函数。因为堆有最大堆和最小堆，如果是最大堆就利用上面的逻辑，如果是最小堆就反之。那么如何知道是最大堆还是最小堆，我们可以通过向heap类传入一个仿函数，然后在调用的时候定义是Less还是Greater仿函数即可实现比较的时候用的是大于比较还是小于比较。1234567891011121314151617181920//Adjustdown函数void AdjustDwon(size_t root)&#123; Compare com; size_t parent = root; size_t child = parent*2 + 1; while(child &lt; _array.size())&#123; if(child+1 &lt; _array.size() &amp;&amp; com(_array[child+1], _array[child]))&#123; ++ child; &#125; if(com(_array[child], _array[parent]))&#123; swap(_array[child], _array[parent]); parent = child; child = parent*2 + 1; &#125; else&#123; break; &#125; &#125;&#125; 补充但是一次向下调整函数毕竟只能改变一条路径，那么我们如何利用起来的呢。在构造函数中，我们找到堆的最后一个父亲节点，然后从这个元素依次向上调用向上调整函数就可以保证调整之后整个数组的元素符合最大堆或者最小堆的性质。带参的构造函数中是如下调用的：123for(int i = (_array.size()-2)/2; i &gt;= 0; --i)&#123; AdjustDwon(i);&#125; 寻找最后一个元素很简单，就是让vector的最后一个元素的下标减一除二取整就可以获取到最后一个父亲节点的下标。需要注意的是，vector的内置函数size()返回的元素个数，而数组的下标是从零开始的，所以需要多减去一个一才符合。 插入函数插入函数调用vector的push_back()函数进行尾插，然后从后向前调整，调用一次向上调整函数。 Push函数12345//Pushvoid Push(const T&amp; x)&#123; _array.push_back(x); AdjustUp(_array.size() - 1);&#125; AdjustUp函数(向上调整函数)有了向下调整函数的基础，这个向上调整函数是同理。这里只要调用一次就好，是因为插入一个元素只会影响一条路径上的元素大小是否符合规则。1234567891011121314void AdjustUp(size_t child)&#123; Compare com; int parent = (child - 1)/2; while(child &gt; 0)&#123; if(com(_array[child], _array[parent]))&#123; swap(_array[child], _array[parent]); child = parent; parent = (child - 1)/2; &#125; else&#123; break; &#125; &#125;&#125; 出堆函数Pop函数将堆顶的数据出堆，并保证堆的特征。如果我们是直接将堆顶的数据出堆，然后再进行调整的话，需要跟构造函数那样进行多次向下调整。那么整个堆的结构将会出现完全的改变。同时比较节点的大小的时候会十分混乱。为了解决这个矛盾，我们可以采用更巧妙的方式，通过将堆顶的数据和堆末的数据进行交换，交换之后通过vector的pop_back函数弹出，再用一次向下调整函数就可以了。12345void Pop()&#123; swap(_array[0], _array[_array.size() - 1]); _array.pop_back(); AdjustDwon(0);&#125; 判空，大小，堆顶元素这几个函数都是调用vector的内置函数封装而成。123456789101112//Emptybool Empty()&#123; return _array.empty();&#125;//Sizesize_t Size()&#123; return _array.size();&#125;//Topconst T&amp; Top()&#123; return _array[0];&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#pragma once//Lesstemplate &lt;class T&gt;struct Less&#123; bool operator()(const T&amp; left, const T&amp; right)&#123; return left &lt; right; &#125;&#125;;//Greatertemplate &lt;class T&gt;struct Greater&#123; bool operator()(const T&amp; left, const T&amp; right)&#123; return left &gt; right; &#125;&#125;;template &lt;class T, class Compare&gt;class Heap&#123;public: //constructor Heap() &#123;&#125; Heap(T* a, size_t n)&#123; //reserve _array.reserve(n); for(size_t i = 0; i &lt; n; ++i)&#123; _array.push_back(a[i]); &#125; for(int i = (_array.size()-2)/2; i &gt;= 0; --i)&#123; AdjustDwon(i); &#125; &#125; //Push void Push(const T&amp; x)&#123; _array.push_back(x); AdjustUp(_array.size() - 1); &#125; //Pop void Pop()&#123; swap(_array[0], _array[_array.size() - 1]); _array.pop_back(); AdjustDwon(0); &#125; //Empty bool Empty()&#123; return _array.empty(); &#125; //Size size_t Size()&#123; return _array.size(); &#125; //Top const T&amp; Top()&#123; return _array[0]; &#125; //Print for Test void Print()&#123; if(!_array.empty())&#123; for(size_t i = 0; i &lt; _array.size(); ++i)&#123; cout &lt;&lt; _array[i] &lt;&lt; " "; &#125; &#125; &#125;protected: vector&lt;T&gt; _array; void AdjustDwon(size_t root)&#123; Compare com; size_t parent = root; size_t child = parent*2 + 1; while(child &lt; _array.size())&#123; if(child+1 &lt; _array.size() &amp;&amp; com(_array[child+1], _array[child]))&#123; ++ child; &#125; if(com(_array[child], _array[parent]))&#123; swap(_array[child], _array[parent]); parent = child; child = parent*2 + 1; &#125; else&#123; break; &#125; &#125; &#125; void AdjustUp(size_t child)&#123; Compare com; int parent = (child - 1)/2; while(child &gt; 0)&#123; if(com(_array[child], _array[parent]))&#123; swap(_array[child], _array[parent]); child = parent; parent = (child - 1)/2; &#125; else&#123; break; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>knowledge</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BST二叉搜索树]]></title>
    <url>%2FBST%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</url>
    <content type="text"><![CDATA[性质二叉搜索树是一个优化的二叉树，也称作二叉排序树、二叉查找树、BST等。一般在每个节点定义一个关键值Key。插入的时候按照一定的规则使之有序插入，方便搜索。它可以是一颗空树，或者这棵树有着以下的性质：1、如果左子树不为空，那么左子树上的所有节点的值都小于根节点的值2、如果右子树不为空，那么右子树上的所有节点的值都大于根节点的值3、同时，左右子树也是二叉搜索树4、这棵二叉树没有相同关键值的节点，也就是每一个节点的值多不相同如果插入序列是：6,3,8,7,1,2,4,0,5,9,4图示如下： 节点二叉树用二叉链的形式实现。每个节点有一个关键值_key，指向左子树的指针_left，指向右子树的指针_right。123456789101112template &lt;class K&gt;struct BStreeNode&#123; K _key; BStreeNode&lt;K&gt;* _left; BStreeNode&lt;K&gt;* _right; BStreeNode(const K&amp; key) :_key(key) ,_left(NULL) ,_right(NULL) &#123;&#125;&#125;; 插入思路分为三个步骤，查找插入位置，利用key创建节点，跟二叉树连接起来1、插入函数接收一个关键值key，用这个key跟当前指针指向的节点(cur)的关键值(cur-&gt;_key)比较。2、如果key大，cur向右子树走；如果key小，cur向左子树走；如果相等，那么就不需要插入。这里利用一个循环就可以实现。一直到cur指向空节点，那么这个地方就是需要插入的位置。4、但是为了将新增节点和二叉树连接起来，还需要一个指针指向上一个节点(parent)，此时要分清楚链入parent节点的左子树上还是右子树上。 图示插入key为4的节点 代码实现代码分为递归写法和非递归写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//非递归bool Insert(const K&amp; key)&#123; //特殊处理插入空树的情况 if(_root == NULL)&#123; _root = new Node(key); return true; &#125; Node* cur = _root; Node* parent = NULL; //查找插入位置 while(cur)&#123; if(cur-&gt;_key &lt; key)&#123; parent = cur; cur = cur-&gt;_right; &#125; else if(cur-&gt;_key &gt; key)&#123; parent = cur; cur = cur-&gt;_left; &#125; //已经有相同关键值的节点，不插入 else&#123; return false; &#125; &#125; cur = new Node(key); //插入到parent的右子树上 if(parent-&gt;_key &lt; key)&#123; parent-&gt;_right = cur; &#125; else&#123; parent-&gt;_left = cur; &#125; return true;&#125;//递归写法bool InsertR(const K&amp; key)&#123; return _InsertR(_root, key);&#125;//root使用的是引用，解决了连接的问题bool _InsertR(Node*&amp; root, const K&amp; key)&#123; if(root == NULL)&#123; root = new Node(key); &#125; else if(root-&gt;_key &lt; key)&#123; _InsertR(root-&gt;_right, key); &#125; else if(root-&gt;_key &gt; key)&#123; _InsertR(root-&gt;_left, key); &#125; else return false; return true;&#125; 这里解释两个地方：1、递归为什么要调用一个内置函数，不直接递归。2、递归写法为什么不需要链接的过程。1、由于递归函数需要多次调用本身，考虑如果不调用内置函数，为了实现递归左右子树，需要传入参数如下：1bool InsertR(Node* root, const K&amp; key)&#123;&#125; 但是很尴尬的是，我们没有办法将根节点_root的左子树或者右子树进行调用。因为_root是私有的，我们在类的外面是没有办法直接调用的。2、递归写法不是不需要链接的过程，而是连接的过程在使用了引用root这个语法之后，隐式的完成了。一个例子：我们现在有一个关键值为6的节点，我们要插入关键值为3的节点。根据代码，代码会走到_InsertR(root-&gt;_left, key);这里。此时的root有两层含义：第一层，root是当前节点的位置，指向了NULL；第二层，root是上一层函数root-&gt;_left指向的位置。之所以会有这样的联系，是因为root参数是引用的原因，当前的root是上一层函数的root-&gt;_left的别名。这样我们就不需要考虑连接的问题了，只要将新增节点直接交给当前函数的root就已经和二叉树连接在一起了。 查找查找的思路十分简单，可以认为是插入的弱化版本。找到返回当前节点的指针，未找到返回空指针。 代码实现查找函数也有非递归和递归两个版本。1234567891011121314151617181920212223242526272829303132333435//FindNode* Find(const K&amp; key)&#123; if(_root)&#123; Node* cur = _root; while(cur)&#123; if(cur-&gt;_key &lt; key)&#123; cur = cur-&gt;_right; &#125; else if(cur-&gt;_key &gt; key)&#123; cur = cur-&gt;_left; &#125; else&#123; return cur; &#125; &#125; &#125; return NULL;&#125;//FindRNode* FindR(const K&amp; key)&#123; return _FindR(_root, key);&#125;Node* _FindR(Node* root, const K&amp; key)&#123; if(root == NULL) return NULL; else if(root-&gt;_key &lt; key)&#123; _FindR(root-&gt;_right, key); &#125; else if(root-&gt;_key &gt; key)&#123; _FindR(root-&gt;_left, key); &#125; else&#123; return root; &#125;&#125; 删除删除思路删除较为复杂，分析如下：1、当前树是否为空2、寻找需要删除节点的位置3、如果删除的节点是叶子节点或者有一个子树为空的情况，可以归为第一类4、如果删除的节点两个子树都存在，归为第二类使用示例： 第一类，叶子节点或者有一个子树为空为什么将叶子节点归为这一类，是因为可以将叶子节点看做是左子树为空或者右子树为空的情况。 左子树为空左子树为空分为两种情况，第一种上图中红色cur一样，是parent的左子树，需要用parent的左去链接cur的右子树；第二种是上图中橙色cur，是parent的右子树，需要用parent的右去链接cur的右子树。 右子树为空同理，右子树为空也分为两种情况，上图中红色cur和橙色cur。 注意需要特殊处理parent是NULL的情况。当左右子树为空的时候，还有一种特殊的情况需要处理，如果符合要求的节点是根节点，我们需要特殊处理。如下图： 第二类，两个子树都存在这个类型的节点，需要使用到处理堆的一个操作。如果有一个大堆，需要获取第二大的节点的时候。需要将最大的节点出堆，然后获取堆顶数据。但是出堆之后，如果需要堆还是符合大堆的性质。就需要特殊处理。处理方法是替换：将堆顶的最大元素和最小元素交换，然后再删除最后一个节点，最后使用向下调整就可以了。这里也是这样处理，当我们找到了需要删除的节点，我们就去找右子树中最小的节点，然后替换，替换之后再删除。如图所示：如果需要删除节点cur，这个时候找到右子树中最小的节点pos，将节点pos的值赋给节点cur，让parent-&gt;_left==NULL。再删除cur节点，就实现了删除了。但是为什么是节点pos呢？这是因为删除了两个子树都在的节点。还需要保持BST的特性：左右子树还是BST。这时，右子树的最左节点肯定是右子树中最小的，或者说是排序下，跟当前删除节点相邻的节点。用它来改变删除节点最合适了，而且不需要对树的结构有大的修改。注意：这里有一个特殊的点，比如删除下图中的根节点。特殊的地方是，没有办法找到子树中的最左节点，因为根本没有，所以就需要在使用上述交换的方法的时候，特殊处理一次，判断parent的指向的时候，到底是直接让parent-&gt;_left==NULL还是parent-&gt;_right==pos-&gt;_right。通过删除节点pos的右是否存在判定。 代码实现递归和非递归两种情况123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//Removebool Remove(const K&amp; key)&#123; if(_root)&#123; Node* cur = _root; Node* parent = NULL; while(cur)&#123; //寻找节点 if(cur-&gt;_key &lt; key)&#123; parent = cur; cur = cur-&gt;_right; &#125; else if(cur-&gt;_key &gt; key)&#123; parent = cur; cur = cur-&gt;_left; &#125; //找到节点开始删除 else&#123; Node* del = cur; //删除节点的左子树为空 if(cur-&gt;_left == NULL)&#123; //特殊处理parent为NULL的情况 if(parent == NULL)&#123; _root = cur-&gt;_right; &#125; else&#123; //分cur是parent的左还是右子树 if(parent-&gt;_left == cur)&#123; parent-&gt;_left = cur-&gt;_right; &#125; else&#123; parent-&gt;_right = cur-&gt;_right; &#125; &#125; &#125; //删除节点的右子树为空 else if(cur-&gt;_right == NULL)&#123; if(parent == NULL)&#123; _root = cur-&gt;_left; &#125; else&#123; if(parent-&gt;_left == cur)&#123; parent-&gt;_left = cur-&gt;_left; &#125; else&#123; parent-&gt;_right = cur-&gt;_left; &#125; &#125; &#125; //删除节点的两个子树都在 else&#123; parent = cur; Node* pos = cur-&gt;_right; //寻找右子树最左节点 while(pos-&gt;_left)&#123; parent = pos; pos = pos-&gt;_left; &#125; //赋值给cur cur-&gt;_key = pos-&gt;_key; del = pos; //特殊处理pos是不是找到的右子树中的最左节点 if(pos-&gt;_right)&#123; parent-&gt;_right = pos-&gt;_right; &#125; else&#123; parent-&gt;_left = NULL; &#125; &#125; //三种情况统一删除 delete del; return true; &#125; &#125; &#125; //没找到，返回错误 return false;&#125;//RemoveRbool RemoveR(const K&amp; key)&#123; return _RemoveR(_root, key);&#125;bool _RemoveR(Node*&amp; root, const K&amp; key)&#123; if(root)&#123; Node* cur = root; if(cur-&gt;_key &lt; key)&#123; _RemoveR(root-&gt;_right, key); &#125; else if(cur-&gt;_key &gt; key)&#123; _RemoveR(root-&gt;_left, key); &#125; else&#123; Node* del = root; if(root-&gt;_left == NULL)&#123; root = root-&gt;_right; &#125; else if(root-&gt;_right == NULL)&#123; root = root-&gt;_left; &#125; else&#123; Node* pos = root-&gt;_right; while(pos-&gt;_left)&#123; pos = pos-&gt;_left; &#125; root-&gt;_key = pos-&gt;_key; return _RemoveR(root-&gt;_right, pos-&gt;_key); &#125; delete del; return true; &#125; &#125; return false;&#125; 说明一下递归调用的思想，对于树来说，递归的调用就相当于子问题的调用，每次都将左右节点当做是下次的根节点，然后通过相同的处理方式，一直到遇到返回条件。在递归删除中，也利用了引用的关键作用。123456if(root-&gt;_left == NULL)&#123; root = root-&gt;_right;&#125;else if(root-&gt;_right == NULL)&#123; root = root-&gt;_left;&#125; 这一段中，因为引用的原因，当前的root除了是指向当前节点的指针，还是上一级root指针的_left或者_right。这样也就不需要考虑连接的问题。在递归中处理删除节点的左右子树都在的情况，还是寻找到右子树中key最小的节点，然后赋值给需要删除的节点，在通过调用函数来删除这个节点，这样就可以直接利用删除左节点为空或者右节点为空的情况来处理。 中序遍历二叉搜索树又叫做排序树，这个是因为他是排好序的。同时如果使用中序遍历的话，就可以得到这个排好序的序列。 代码实现利用中序的遍历，也有递归和非递归两种形式。非递归的形式，是借用了栈来模拟回退的功能。123456789101112131415161718192021222324252627282930313233//InOrdervoid InOrder()&#123; Node* root = _root; if(_root)&#123; Node* cur = root; stack&lt; Node* &gt; s; while(cur || !s.empty())&#123; while(cur)&#123; s.push(cur); cur = cur-&gt;_left; &#125; cur = s.top(); cout &lt;&lt; cur-&gt;_key &lt;&lt; " "; s.pop(); cur = cur-&gt;_right; &#125; cout &lt;&lt; endl; &#125;&#125;//InOrderRvoid InOrderR()&#123; _InOrderR(_root); cout &lt;&lt; endl;&#125;void _InOrderR(Node* root)&#123; if(root)&#123; _InOrderR(root-&gt;_left); cout &lt;&lt; root-&gt;_key &lt;&lt; " "; _InOrderR(root-&gt;_right); &#125; return;&#125;]]></content>
      <categories>
        <category>knowledge</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下简易彩色进度条]]></title>
    <url>%2Flinux%E4%B8%8B%E7%AE%80%E6%98%93%E5%BD%A9%E8%89%B2%E8%BF%9B%E5%BA%A6%E6%9D%A1.html</url>
    <content type="text"><![CDATA[前言在Linux下安装文件的时候，都会有个进度条来提示我们安装的进度是多少。这里我们模拟输出这个进度条。主要用到输出函数的操作、缓冲区的刷新、usleep函数、linux终端颜色的显示等知识。效果如下： 铺垫知识点缓冲区缓冲区分位三种：无缓冲，行缓冲，全缓冲。无缓冲：没有缓冲，也就是信息在输入输出的时候，立马输入或输出。典型的代表就是标准错误流stderr。行缓冲：当输入输出的时候，遇到换行才执行I/O操作。典型的代表是键盘的操作。全缓冲：当输入输出写满缓冲区才执行I/O操作。典型的代表是磁盘的读写。由于输出函数是行缓冲类型的。所以我们需要使用缓冲区刷新函数fflush来输出。否则我们看到的进度条将是一段一段输出的。补充：printf函数是一个行缓冲函数，先写到缓冲区，满足条件就将缓冲区刷到对应文件中。满足下列条件之一，缓冲区都会刷新：（1）缓冲区填满（2）写入的字符中有&#39;\n&#39;&#39;\r&#39;（3）调用fflush刷新缓冲区（4）调用scanf从缓冲区获取数据时，也会刷新新缓冲区。 换行符有两个符号需要区分：&#39;\n&#39;&#39;\r&#39;。他们有不同的含义。&#39;\n&#39;表示的是换行，将光标指向下一行的开头位置。’`r’`指的是回车，将光标回到当前行的开头位置。在这里我们要使用&#39;\r&#39;，否则我们的进度条将输出一个&#39;#&#39;就换一行。 usleep函数刷新了缓冲区之后，如果并没有加上睡眠函数，结果将一次性输出来。进度条应该是随着加载不停出现才对。这里统一总结一下Linux睡眠函数：头文件：#include &lt;unistd.h&gt;以 秒为单位：unsigned int sleep( unsigned int seconds );以 微秒为单位：int usleep ( useconds_t usec );以 四分之一毫秒为单位：extern void delay( unsigned int msec ); 以睡眠一秒为例:sleep(1); usleep(1000 000); delay(250); 输出颜色的设置printf函数可以通过输出特定的转义序列来实现输出字符的颜色和状态。转义序列以控制字符’ESC’开头。该字符的ASCII码十进制表示为27，十六进制表示为0x1B，八进制表示为033。多数转义序列超过两个字符，故通常以’ESC’和左括号’[‘开头。该起始序列称为控制序列引导符(CSI，Control Sequence Intro)，通常由’\033[‘或’\e[‘代替。一般格式如下：(显示方式指的是样式，前景色是30+颜色值，背景色是40+颜色值，字符m表示结束) \033[显示方式；前景色；背景色m + 输出字符串或者\e[显示方式；前景色；背景色m + 输出字符串 常见参数如下：显示方式：0(默认)、1(粗体/高亮)、22(非粗体)、4(单条下划线)、24(无下划线)、5(闪烁)、25(无闪烁)、7(反显、翻转前景色和背景色)、27(无反显)颜色：0(黑)、1(红)、2(绿)、 3(黄)、4(蓝)、5(洋红)、6(青)、7(白)见例子：123printf("\033[31mHello!\n\033[0m");printf("\033[4;32mHello!\n\033[0m");printf("\033[1;34;43mHello!\n\033[0m"); 其中：\033[0m用于恢复默认的终端输出属性，否则会影响后续的输出。颜色设置详细解析传送门 代码如下1234567891011121314151617181920212223242526272829#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main()&#123; int i = 0; int j = 0; char bar[102]; //color数组用来改变颜色的值，让进度条在七种颜色中变幻 int color[] = &#123;1, 2, 3, 4, 5, 6, 7&#125;; //设置状态，显示此时正在加载 const char *status = "|/-\\"; memset(bar, 0, siezof(bar)); while(i &lt;= 100)&#123; //无颜色版本 //printf("[%-100s][%d%%][%c]\r", bar, i, status[i%4]); printf("\033[3%dm[%-100s]\033[0m\033[33m[%d%%]\033[0m[%c]\r", color[j], bar, i, lable[i%4]); fflush(stdout); bar[i ++] = '#'; //每加载15%，就变换一次颜色 if(i%15 == 0)&#123; ++ j; &#125; //休眠0.03秒输出字符 usleep(30000); &#125; printf("\n"); return 0;&#125; 参考一参考二]]></content>
      <categories>
        <category>Linux</category>
        <category>practice</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C语言输入输出函数详解]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[总览12345678910111213141516171819202122232425262728293031323334353637383940414243//错误报告函数：void perror( char const* str );//终止执行函数：void exit (int status);//打开和关闭文件函数FILE * fopen ( const char * filename, const char * mode );int fclose ( FILE * stream );//字符输入函数int fgetc ( FILE * stream );int getc ( FILE * stream );int getchar ( void );//字符输出函数int fputc ( int character, FILE * stream );int putc ( int character, FILE * stream );int putchar ( int character );//撤销字符函数：int ungetc ( int character, FILE * stream );//文本行输入函数char * fgets ( char * str, int num, FILE * stream );char* gets( char* str );//文本行输出函数int fputs ( const char * str, FILE * stream );int puts ( const char * str );//格式化输入函数int fscanf( FILE* stream, const char* format, ... );int scanf( const char* format, ... );int sscanf( const char* s, const char* format, ... );//格式化输出函数int fprintf( FILE* stream, const char* format, ... );int printf( const char* format, ... );int sprintf( char* str, const char* format, ... );//二进制I/O函数size_t fread( void* ptr, size_t size, size_t count, FILE* stream );size_t fwrite( void* ptr, size_t size, size_t count, FILE* stream );//刷新缓冲区函数：int fflush ( FILE * stream );//文件流定位函数long int ftell( FILE* stream );int fseek( FILE* stream, long offset, int from );//流错误函数int feof( FILE* stream );int ferror( FILE* stream );void clearerr( FILE* stream ); 错误报告函数：void perror( char const* str );先解释一个整型变量errno，这个变量是错误码，当一个库函数失败的时候，errno会被设置。形参：str是一个字符串补充：当一个程序执行了错误的操作的时候，操作系统设置一个errno，perror函数首先会将str中的信息打印出来，后面跟上一个分号和空格，在打印出一条用于解释errno当前错误码的信息。例子：12345678910111213/* perror example */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; pFile=fopen ("unexist.ent","rb"); if (pFile==NULL) perror ("The following error occurred"); else fclose (pFile); return 0;&#125; 如果文件unexist.ent不存在，那么将会输出以下信息： 注意：只有当一个库函数失败的时候，errno才会被设定。当函数成功运行的时候，errno并不会被设定。所以我们不能通过测试errno的值来判断是否有错误发生。 终止执行函数：void exit( int status );头文件：stdlib.h形参：status参数返还给操作系统。预定符号是EXIT_SUCCESS和EXIT_FAILURE。通常用0和EXIT_SUCCESS表示程序正常退出，用除零以外的整数和EXIT_FAILURE表示程序退出异常。补充：我们经常将这个函数和perror配合起来使用，当我们发现了程序的错误的时候，用来终止程序的执行。例子：12345678910111213141516171819/* exit example */#include &lt;stdio.h&gt; /* printf, fopen */#include &lt;stdlib.h&gt; /* exit, EXIT_FAILURE */int main ()&#123; FILE * pFile; pFile = fopen ("myfile.txt","r"); if (pFile==NULL) &#123; printf ("Error opening file"); exit (EXIT_FAILURE); &#125; else &#123; /* file operations here */ &#125; return 0;&#125; 如果文件myfile.txt不存在 打开文件函数：FILE* fopen( char const* filename, const char* mode );形参：两个参数都是字符串，filename是希望打开的文件或者设备名字；mode是用来表示流是用于只读、只写、读和写，以及是文本流还是二进制流。返回值：如果成功打开文件，返回一个指向FILE类型的指针。失败返回一个NULL，并把错误码存入errno中。补充：以一定的模式打开文件或设备。模式常见如下：以下模式用文本流打开： 模式 功能 “r” read，只能读取，不能写入，同时要求文件必须存在。 “w” write，只能写入，不能读取。若文件存在，那么清空文件内容再写入；若文件不存在，创建文件再写入。 “a” append，只能写入，不能读取。若文件存在，在文件末尾添加内容；如果文件不存在，创建文件再写入。 “r+” read/update，可读可写，要求文件必须存在。 “w+” write/update，可读可写，如果文件存在，清空文件内容再写入；如果文件不存在，创建文件再写入。 “a+” append/update，可读可写，若文件存在，在文件末尾添加内容；若文件不存在，创建文件再写入。 以下模式用二进制流打开：“rb”, “wb”, “ab”, “r+b”, “w+b”, “a+b”或者”rb+”, “wb+”, “ab+”。功能和文本流一样，只是打开写入方式是二进制流。 二进制流和文本流的区别：文本流(text)：指的是在流中流动的数据是 以字符形式出现的。举个例子：输入的时候，’\n’这个符号会被替换为回车CR和换行的ASCII码0DH和0AH。输出的时候，0DH和0AH被替换为’\n’。二进制流(binary)：指的是在流中流动的数据是以 二进制数字序列出现的。说白了就是在内存中是怎么存储的，输入到文件中也是怎么样存储的。而且不会对’\n’进行替换。举个例子：对于2001这个数文本流用ASCII码表示：’2’’0’’0’’1’分别是：50,48,48,49一共是四个字节二进制流表示为：0000 0111 1101 0001转换为十六进制就是07D1，占用了两个字节。此例来源：http://blog.csdn.net/barryCG/article/details/7621097 例子：12345678910111213/* fopen example */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; pFile = fopen ("myfile.txt","w"); if (pFile!=NULL) &#123; fputs ("fopen example",pFile); fclose (pFile); &#125; return 0;&#125; 如果没有myfile.txt这个文件，将会创建一个myfile.txt文件，并写入内容fopen example。 关闭文件函数：int fclose( FILE* stream );形参：stram是一个FILE类型指针指向的流文件。返回值：当文件被正常关闭，返回一个整型的0；如果关闭异常，返回文件结束符EOF，通常被解释为整型的-1。补充：我们习惯于将fopen和fclose搭配使用。fclose会在文件关闭的之前刷新缓冲区，将缓冲区的数据存入文件中，否则会有数据丢失。必要的时候，我们需要检测fclose的返回值是否正确，以避免数据丢失或。 输入输出函数总览 家族名 目的 可用于所有的流 只用于stdin或stdout 内存中的字符串 getchar 字符输入 fget,getc getchar ① putchar 字符输出 fputc,putc putchar ① gets 文本行输入 fgets gets ② puts 文本行输出 fputs puts ② scanf 格式化输入 fscanf scanf sscanf printf 格式化输出 fprintf printf sprintf ①表示对指针使用下标引用或间接访问操作从内存中获得\写入一个字符②使用strcpy函数从内存读取\写入文本行 字符输入函数：fgetc、getc、getchar函数原型：int fgetc( FILE* stream ); 用于所有流宏原型：int getc(FILE* stream ); 用于所有流int getchar( void ); 只能用于stdin形参：stram是一个FILE类型指针指向的流文件。返回值：若读取成功，返回读取的一个字符，并实现整型提升。若到了文件的结束，返回EOF表示文本的结束。若读取失败，同样返回EOF并设置error变量。补充：1、函数作用是读取一个字符，同时文件指针向后指向下一个字符。2、返回值是整型，这是因为允许函数报告文件末尾(EOF)。如果返回值是char型，那么256个字符中肯定有一个被指用于表示EOF。如果这个字符在文件内部出现，这个字符以后的内容不会被读取。因为这个字符被解释为EOF。所以应该使用整型变量来接收这个字符3、fgetc是函数，getc和getchar是通过#define定义的宏。所以getc和getchar不能传入带有副作用的参数。同时，getc和getchar的效率会比fgetc快上一点。4、getchar始终从标准输入读取一个字符。例子：12345678910111213141516171819202122232425/* fgetc example: money counter */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //EXIT_FAILUREint main ()&#123; FILE * pFile; int c; int n = 0; pFile=fopen ("myfile.txt","r"); if (pFile==NULL) &#123; perror ("Error opening file"); exit(EXIT_FAILURE); &#125; else &#123; do &#123; c = fgetc (pFile); if (c == '$') n++; &#125; while (c != EOF); fclose (pFile); printf ("The file contains %d dollar sign characters ($).\n",n); &#125; return 0;&#125; 上面代码用来统计myfile.txt中$符号的个数，在文件中输入五个，最后得到结果正确。如果没有这个文件，将会执行perror程序，报错 字符输出函数：fputc、putc、putchar函数原型：int fputc( int character, FILE* stream ); 用于所有流宏原型：int putc( int character, FILE* stream ); 用于所有流int putchar( int character ); 只能用于stdout形参：character是将要被输出的字符；stram是一个FILE类型指针指向的流文件。返回值：若函数执行成功，返回被写入的字符；若失败，返回EOF。同时errno被设置。补充：1、参数character在输入的时候会被裁剪为无符号整型。2、fputc是真正的函数，putc和putchar是#define定义的宏函数。3、putchar始终将字符打印在标准输出流。例子：12345678910111213141516/* fputc example: alphabet writer */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; char c; pFile = fopen ("alphabet.txt","w"); if (pFile!=NULL) &#123; for (c = 'A' ; c &lt;= 'Z' ; c++) fputc ( c , pFile ); fclose (pFile); &#125; return 0;&#125; 上述代码将大写字符A~Z写入文件alphabet.txt中。 撤销字符函数 ：int ungetc( int character, FILE* stream );这个函数的作用是将先前读取到的字符返回到原来的流中，这样它可以在以后被重新读入。形参：character是要返回的字符，stram是一个FILE类型指针指向的流文件。返回值：若成功，返回被返回流中的字符；若失败，EOF被返回。补充：1、“退回”的字符和流当前的位置有关，所以如果用fseek、fsetpos、rewind函数改变了流的位置，所有退回的字符将被丢弃。2、把字符退回到流中和写入到流中是不一样的。也就是从文件中读取出来后的退回，并不会影响到物理存储上的内容。例子：12345678910111213141516171819202122/* ungetc example */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; int c; char buffer [256]; pFile = fopen ("myfile.txt","rt"); if (pFile==NULL) perror ("Error opening file"); else while (!feof (pFile)) &#123; c=getc (pFile); if (c == EOF) break; if (c == '#') ungetc ('@',pFile); else ungetc (c,pFile); if (fgets (buffer,255,pFile) != NULL) fputs (buffer,stdout); else break; &#125; return 0;&#125; 上述代码，将文件myfile.txt中每行开头的’#’替换为‘@’。如果打开失败，打印”Error opening file”。 文本行输入函数：fgets、gets函数原型：char* fgets( char* str, int num, FILE* stream );char* gets( char* str ); //一般不使用，不安全。完全可以用fgets代替。形参：str是目标字符串，num是一个整型参数；用来表示读取的字符个数,它包括了’\0’在内；stream是获取字符的流。返回值：如果读取失败，也就是在读取任何字符之前就到了文件的结束，缓冲区没有被修改，返回一个NULL指针；如果读取成功，返回str。补充：1、当fgets读取到一个换行符并存储到缓冲区之后，结束读取。2、如果读取的字符数量达到num-1个，结束读取。但是这种情况并不会出现数据丢失，因为下次调用fgets将从流的下一个字符开始读取。3、任何一种情况下，一个NUL字节将被添加到缓冲区所存储数据的末尾，让其成为一个字符串。例子：1234567891011121314151617/* fgets example */#include &lt;stdio.h&gt;int main()&#123; FILE * pFile; char mystring [100]; pFile = fopen ("myfile.txt" , "r"); if (pFile == NULL) perror ("Error opening file"); else &#123; if ( fgets (mystring , 100 , pFile) != NULL ) puts (mystring); fclose (pFile); &#125; return 0;&#125; 上述代码，获取文件myfile.txt中的第一行字符串最多获取99个字符。注意：1、fgets无法将字符串读取到一个长度小于两个字符的缓冲区，因为其中一个字符需要为NUL字节保留。2、gets和fgets的不同，在于gets读取一行输入是，它不在缓冲区中存储结尾的换行符。3、同时，应该注意的是，我们并不使用gets，因为它没有缓冲区长度参数，如果一个长输入行读到一个短缓冲区，多出来的字符将被写入到缓冲区后面的内存位置，这样会破坏此内存中的数据。 文本行输出函数：fputs、puts函数原型：int fputs( const char* str, FILE* stream );int puts( const char* str );形参：str是一个字符型指针，用来指向一个字符串，用来获取输入。返回值：如果函数调用失败，返回EOF；成功返回一个非负数的值。补充：1、fputs函数输出行的时候，不会将字符串的’\0’输出。123456789101112#include &lt;stdio.h&gt;int main ()&#123; FILE *pFile; pFile = fopen("file.txt", "a"); fputs("this is c", pFile); fputs("this is cpp", pFile); fclose(pFile); return(0);&#125; 上述代码可以证明，fputs不输出字符串结尾’\0’。2、puts函数会在读取的字符串后面自动加上一个结尾符号’\0’，并输出到stdin中。 格式化输入函数：fscanf、scanf、sscanf函数原型：int fscanf( FILE* stream, const char* format, … );int scanf( const char* format, … );int sscanf( const char* s, const char* format, … );形参：stream是一个FILE指针指向的流；format字符串是相应的格式。省略号表示一个可变长度的指针列代表。sscanf中的s指的是一个字符串，用来读取字符。返回值：当字符串到达末尾或读取的输入不再匹配字符串所指定的类型的时候，输入停止。同时，被转换的输入值的个数当成函数的返回值；如果在任何输入值被转换之前文件就已经到达了尾部，返回EOF。补充：1、输入源的区别：fscanf的输入源是stream；scanf的输入源是标准输入stdin；sscanf的输入源是字符串s。2、这些函数的正常运行依赖于格式代码。必须保证指针参数的类型必须是对应格式代码的正确类型。否则将会产生垃圾值。比如下面例子：123456789#include &lt;stdio.h&gt;int main ()&#123; float a; scanf("%d", &amp;a); printf("%f", a); return 0;&#125; 上述代码中a的类型是float，但是输入的时候指针参数的类型是整型，而格式代码是&amp;a，是float类型。输出的时候用的是float输出，最终得到了垃圾值。3、为什么scanf中需要用&amp;符号。这个是因为在c中是传值调用，如果需要修改当前值地址的内容就需要传递一个地址。否则将会程序崩溃。4、format字符串参数解析：(1)空白字符：它们与输入中的零个或多个空白字符匹配，在处理的过程中被忽略。(2)格式代码：它们指定函数如何解释接下来的输入字符。(3)其他字符：当任何其他字符出现在格式字符串时，下一个输入字符必须与之匹配。如果匹配，该字符被丢弃。如果不匹配，函数结束读取。5、格式代码解析：上述代码都是以%开头，接下来接：(1)星号：星号将转换后的值被丢弃而不是存储，可以用来跳过不需要输入的字符。(2)宽度：以一个非负整数给出，它限制被读取用于转换的输入字符个数。如果没有给出宽度，那么就连续读入字符直到遇到输入中的下一个空白字符。下面这个例子给出宽度的用法：12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int a = 0; int b = 0; int c = 0; FILE* input = fopen("input.txt", "r"); if (input == NULL) perror ("Error opening file"); else&#123; fscanf(input, "%4d %4d %4d", &amp;a, &amp;b, &amp;c); printf("a = %d\n", a); printf("b = %d\n", b); printf("c = %d\n", c); &#125; return 0;&#125; input.txt中存放如下：输出如下：只有a和b改变，c未改变。如果input.txt中存放如下；输出如下：a=1234，b=5，c=6789。0被舍弃注意：在使用fscanf函数的时候，文件中的换行符也被当成了空白字符跳过。(3)限定符：h,l,L；限定符的目的是为了指定参数的长度。具体见下表：(4)格式代码：就是单个字符，用于指定输入字符将被如何解析。上表中的第一列就是部分格式代码。具体见下表：例子：12345678910111213141516171819/* scanf example */#include &lt;stdio.h&gt;int main ()&#123; char str [80]; int i; printf ("Enter your family name: "); scanf ("%79s",str); printf ("Enter your age: "); scanf ("%d",&amp;i); printf ("Mr. %s , %d years old.\n",str,i); printf ("Enter a hexadecimal number: "); scanf ("%x",&amp;i); printf ("You have entered %#x (%d).\n",i,i); return 0;&#125; 上述例子就是对各种格式的输入。 格式化输出函数：fprintf、printf、sprintf函数原型：int fprintf( FILE* stream, const char* format, … );int printf( const char* format, … );int sprintf( char* str, const char* format, … );形参：stream是一个FILE指针指向的流；format字符串是相应的格式。省略号表示一个可变长度的指针列代表。sprintf中str是一个用来存储字符的指定字符串。返回值：返回值就是实际打印或者存储的字符个数。补充：1、sprintf是一个容易出错的函数，因为缓冲区的大小并没有作为一个形参被传入。函数并不知道该输入多少个字符是安全的。2、printf家族函数和scanf家族函数一样，必须保证值和格式码表示一致。3、format字符串中含有格式代码，格式代码由一个百分号开头，后面可以跟：(1)零个或者多个标志字符。(2)一个可选的最小字段宽度(3)一个可选的精度(4)一个可选的修改符(5)转换类型4、格式代码如下：5、格式标志如下： 二进制I/O函数：函数原型：size_t fread( void* ptr, size_t size, size_t count, FILE* stream );size_t fwrite( void* ptr, size_t size, size_t count, FILE* stream );形参：ptr是一个指向用于保存数据的内存位置的指针，至少有size*count个字节；size是缓冲区中每个元素的字节数；count是读取的元素数。返回值：实际读取的元素(非字节)的数目，如果过程中遇到了文件尾，这个数字可能比请求的元素数目小。补充：一般来说，二进制的写入效率比文件写入要高，因为二进制输出避免了在数值转换为字符串过程中所涉及的开销和精读损失。但是很遗憾的是，二进制的数据，不是我们人眼可以阅读的。文本写入的文件就可以很好的阅读。例子：123456789101112131415161718192021222324252627282930313233/* fread example: read an entire file */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main () &#123; FILE * pFile; long lSize; char * buffer; size_t result; pFile = fopen ( "myfile.bin" , "rb" ); if (pFile==NULL) &#123;fputs ("File error",stderr); exit (1);&#125; // obtain file size: fseek (pFile , 0 , SEEK_END); lSize = ftell (pFile); rewind (pFile); // allocate memory to contain the whole file: buffer = (char*) malloc (sizeof(char)*lSize); if (buffer == NULL) &#123;fputs ("Memory error",stderr); exit (2);&#125; // copy the file into the buffer: result = fread (buffer,1,lSize,pFile); if (result != lSize) &#123;fputs ("Reading error",stderr); exit (3);&#125; /* the whole file is now loaded in the memory buffer. */ // terminate fclose (pFile); free (buffer); return 0;&#125; 上述例子将文件myfile.bin中的数据，通过函数fread读取到数组buffer中去。 刷新缓冲区函数：int fflush( FILE* stream );返回值：若函数正确执行返回一个0，若失败，返回EOF同时error被设置。补充：这个函数会立刻刷新缓冲区，如果我们需要输入的字符立刻写入的话，我们可以调动这个函数。例子：1234567891011121314151617/* fflush example */#include &lt;stdio.h&gt;char mybuffer[80];int main()&#123; FILE * pFile; pFile = fopen ("example.txt","r+"); if (pFile == NULL) perror ("Error opening file"); else &#123; fputs ("test",pFile); fflush (pFile); // flushing or repositioning required fgets (mybuffer,80,pFile); puts (mybuffer); fclose (pFile); return 0; &#125;&#125; 上述例子，使用了fflush将缓冲区中的test立刻刷新到文件流pFile中，然后从pFile中获取最多80个字符到mybuffer中。并打印到屏幕上。example.txt存储内容如下：执行程序之后的输出：从被替换的第四个字符开始输出，这个是因为文本指针已经指向第四个字符。执行之后的example.txt内容：前四个字符被替换成text如果没有刷新函数fflush将会出现下面情况：输出如下：此时的缓冲区未刷新，内容并没有写入文本流pFile中。example.txt3内容：当调用puts函数的时候，缓冲区的内容被刷新，所有缓冲区的内容被写入pFile中 文件流定位函数：ftell、fseek函数原型：long int ftell( FILE* stream );int fseek( FILE* stream, long offset, int from );形参：参考下表：补充：1、ftell返回流的当前位置。这函数允许你保存一个文件的当前位置，可能在将来会返回到这个位置。在二进制流中，这个值就是当前位置距离文件起始位置之间的字节数。2、fseek允许你定位在流中的位置，用于下次的读取或写入。3、在二进制流中，从SEEK_END进行定位可能不被支持，应该避免。在文本流中，如果from是SEEK_CUR或SEEK_END，offset必须是零。如果from是SEEK_SET，offset必须是一个从同一个流中以前调用ftell所返回的值。4、这些限制的存在，部分原因是因为文本流所执行的行末字符映射。由于这个映射的存在，文本文件的字节数可能和程序写入的字节数不同。5、用fseek改变一个流的位置会带来三个副作用。第一个，行末指示字符会被清除；第二个，在fseek之前用ungetc退还给流的字符，会被丢失；第三个，定位允许你从写入切换到读取，或者回到打开的流用来更新。例子：12345678910111213141516171819/* ftell example : getting size of a file */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; long size; pFile = fopen ("myfile.txt","r"); if (pFile==NULL) perror ("Error opening file"); else &#123; fseek (pFile, 0, SEEK_END); // non-portable size=ftell (pFile); fclose (pFile); printf ("Size of myfile.txt: %ld bytes.\n",size); &#125; return 0;&#125; 上述程序就是通过利用fseek函数将文件指针定位到文本末，然后通过ftell函数获取当前位置。这样可以统计出文件字节数。下面这个例子说明了文本文件下，换行符被编译为两个字符，分别是&#39;\n&#39;&#39;\r&#39; 流错误函数：feof、ferror、clearerr函数原型：int feof( FILE* stream );int ferror( FILE* stream );void clearerr( FILE* stream );返回值：若到了文件的结束，返回一个非零的值；若不是文件结尾，返回一个零。补充：1、feof函数检查文件指针是否指向文本结束符。ferror函数报告流的错误状态。clearerr对指定流的错误标准进行重置。2、函数clearerr、rewind、fseek会清除文末指示符，当时下次有I/O函数操作这个流，文末指示符会被重新设定。例子：1234567891011121314151617181920212223/* feof example: byte counter */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; int n = 0; pFile = fopen ("myfile.txt","rb"); if (pFile==NULL) perror ("Error opening file"); else &#123; while (fgetc(pFile) != EOF) &#123; ++n; &#125; if (feof(pFile)) &#123; puts ("End-of-File reached."); printf ("Total number of bytes read: %d\n", n); &#125; else puts ("End-of-File was not reached."); fclose (pFile); &#125; return 0;&#125; 上述代码读取文件中的字符个数， 并在文件结束的时候，返回读取字符个数。 本文中的知识点来自于C和指针，代码例子绝大部分来自网站www.cplusplus.com]]></content>
      <categories>
        <category>knowledge</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[查看Linux系统版本信息]]></title>
    <url>%2F%E6%9F%A5%E7%9C%8BLinux%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF.html</url>
    <content type="text"><![CDATA[查看内核版本 cat /proc/version uname -a 查看系统版本 cat /etc/redhat-release lsb_release -a 这个命令需要安装，安装命令： yum install lsb -y cat /etc/issue 都说可以，这个我的查出来很奇怪 rpm -q centos-release 查看cpu相关信息，包括型号、主频、内核等信息 cat /proc/cpuinfo 参考地址1参考地址2]]></content>
      <categories>
        <category>Linux</category>
        <category>method</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux中时间的设置]]></title>
    <url>%2FLinux%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E8%AE%BE%E7%BD%AE.html</url>
    <content type="text"><![CDATA[test: CentOS Linux release 7.4.1708 (Core) 查看时区 data -R +0800 表示在东八区其中：CST：中国标准时间（China Standard Time），这个解释可能是针对RedHat Linux。UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。UTC较于GMT更准确。GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。 修改时区 tzselect 这个命令并不是用来修改时区的，这个命令可以通过你自己的选择然后清楚的知道每个时区的样式。然后你通过修改.progile、.bash_profile或者/etc/profile文件，设置正确的TZ环境变量并导出，可以成功改变时区。 tip：这些修改应该出现用户家目录下下面例子，我将时区由东八区改变为波兰的时区，东一区：先通过tzselect查询波兰的时区书写格式：然后通过修改文件.bash_profile并应用得以修改。 通过替换系统时区文件，或者创建链接文件 1、在目录/usr/share/zoneinfo中有所有的时区文件，通过复制替换到/etc/locatime即可但是有的时候会出现没有效果的情况，比如上例子。这是因为修改了在profile或.bash_profile中设置了TZ。这个时候就需要重新修改TZ。 2、创建链接文件这里如果出现修改失败，同上。 查看和修改时间和日期 datedate用于查看和设置 系统时间 如果不输入命令”hwclock -w”将时间写入硬件时间，电脑重启之后将会返回原样。 hwclockhwclock用来查看设置 硬件时间。 hwclock –hctosyshc代表硬件时间，sys代表系统时间，即用硬件时钟同步系统时钟 hwclock –systohc即用系统时钟同步硬件时钟,等于 hwclock -w 执行完这两个命令系统没有任何反馈。 解释一下硬件时钟和系统时钟的区别：硬件时钟指的是主板上由电池供电的那个时间，可以在BIOS中设置。Linux可以通过hwclock设置。当Linux启动的时候，硬件时钟会赋值给系统时钟。然后系统时钟会独立于硬件时钟工作。系统时钟指的是当前Linux Kernel中的时钟。Linux中的所有命令包括函数都是采用系统时钟设置的。这就是为什么当我们用date修改了时间，没有同步到硬件时钟的时候，这个修改是无效的。 时间自动同步 yum install -y ntpdate首先安装ntpdate软件，用来同步Linux时间服务。 ntpdate time.nist.gov 上面表示同步成功，调整时间为服务器129.6.15.29的时间，时间相差0.136318 sec hwclock -w调整硬件时间 crontab -e设定crontab计划任务自动校时，并添加下列内容0 1 * ntpdate time.nist.gov这样设定一个小时自动进行网络校时。 通过cat /etc/crontab 查看crontab的设置解释，如下：参考文章1参考文章2]]></content>
      <categories>
        <category>Linux</category>
        <category>method</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[判断元素的入栈和出栈顺序是否合法]]></title>
    <url>%2F%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%A5%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88%E9%A1%BA%E5%BA%8F%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4.html</url>
    <content type="text"><![CDATA[题目提供两个元素的集合，一个是元素入栈的顺序，另一个是元素出栈的顺序。设计一个函数，判断两个元素集合是否满足入栈出栈的规则。如：入栈顺序：“12345”，出栈顺序是：“54321”，这样就是符合要求的。如果出栈顺序是：“51234”，这样不符合要求。 思路根据题目的要求，就是判断两数组是否满足出栈入栈的顺序。可以这样做：1、先按照入栈顺序的集合进行入栈。2、在入栈的同时，跟出栈顺序的元素进行比较。如果相同就将入栈的元素pop出来。3、结束的时候，如果栈为空，说明两者的入栈顺序和出栈顺序可以匹配，那么就是符合要求的；如果栈不为空，那就是不符合要求。还有一点：如果两元素的个数不一样或者同时为空，直接判定不符合要求。 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;bool stack_io_right(char* src, char* dst)&#123; int src_len = sizeof(src); int dst_len = sizeof(dst); int i = 0; int j = 0; if(src_len == 0 || src_len != dst_len) return false; for(; i &lt; src_len; ++i)&#123; s.push(*(src+i)); while(s.size() &amp;&amp; s.top() == *(dst+j))&#123; ++j; s.pop(); &#125; &#125; if(s.empty()) return true; else return false;&#125;int main()&#123; system("clear"); char src[] = "12345"; char dst[] = "32145"; char dst1[] = "51243"; cout &lt;&lt; stack_io_right(src, dst) &lt;&lt; endl; cout &lt;&lt; stack_io_right(src, dst1) &lt;&lt; endl; return 0;&#125; 运行结果]]></content>
      <categories>
        <category>practice</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树的基本实现]]></title>
    <url>%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[二叉树本文将使用c++实现模板类的二叉树，内容包括创建、递归遍历、非递归遍历、结点个数、深度、叶子结点的个数、第K层结点个数等函数。 结点、二叉树结构二叉树的结点是一个结构体，包括值_data，指向左子树的指针和指向右子树的指针_left和_right。还有构造函数，用于创建结点。将BinaryTreeNode&lt;T&gt;typedef为Node,很多时候我会遗漏模板的类型名需要加上&lt;T&gt;，这样就会出错。为了减少这种错误，索性用typedef换名。&lt;12345678910111213141516171819202122template &lt;class T&gt;struct BinaryTreeNode&#123; BinaryTreeNode* _left; BinaryTreeNode* _right; T _data; BinaryTreeNode(const T&amp; data = T())&#123; _data = data; _left = NULL; _right = NULL; &#125;&#125;;template &lt;class T&gt;class BinaryTree&#123;typedef BinaryTreeNode&lt;T&gt; Node;public: //...protected: Node* _root;&#125;; 默认成员函数构造函数设置了两个构造函数，一个为空，用于创建一个空的二叉树；另一个参数为两个。const T* a 数组名const T&amp; invalid 非法值解释一下，这里我用一个数组创建二叉树，同时用’#’表示这个空。如这个例子： int a1[] = {1,2,3,&apos;#&apos;,&apos;#&apos;,4,&apos;#&apos;,&apos;#&apos;,5,6,&apos;#&apos;,&apos;#&apos;,&apos;#&apos;}; 如果a1[i] != &#39;#&#39;那么就创建，反之，表示这个位置没有结点。1234567891011121314151617//constructorBinaryTree()&#123; _root = NULL;&#125;BinaryTree(const T* a, const T&amp; invalid)&#123; size_t index = 0; _root = _CreateTree(a, invalid, index);&#125;Node* _CreateTree(const T* a, const T&amp; invalid, size_t&amp; index)&#123; Node* root = NULL; if(a[index] != invalid)&#123; root = new Node(a[index]); root-&gt;_left = _CreateTree(a, invalid, ++index); root-&gt;_right = _CreateTree(a, invalid, ++index); &#125; return root;&#125; 构造函数利用递归的思想，先跟的次序创建二叉树。由于要利用到递归，就没有办法直接用构造函数来实现，因为在class之外是没有办法访问到_root的。所以通过一个函数，利用这个函数来实现递归的过程。构造出来的二叉树关系图： 拷贝构造拷贝构造利用了一个_CopyTree函数。123456789101112BinaryTree(const BinaryTree&amp; tree)&#123; _root = _CopyTree(tree._root);&#125;Node* _CopyTree(Node* root)&#123; Node* node = root; if(node)&#123; node = new Node(root-&gt;_data); node-&gt;_left = _CopyTree(root-&gt;_left); node-&gt;_right = _CopyTree(root-&gt;_right); &#125; return node;&#125; 析构函数析构函数利用了一个Destroy函数1234567891011//destructor~BinaryTree()&#123; Destroy(_root);&#125;void Destroy(Node* root)&#123; if(root == NULL) return; Destroy(root-&gt;_left); Destroy(root-&gt;_right); delete root;&#125; operator=(赋值运算符的重载)先调用析构函数的Destroy销毁当前二叉树，然后调用_CopyTree重新构造当前二叉树。123456789101112131415//operator=BinaryTree&lt;T&gt;&amp; operator=(const BinaryTree&lt;T&gt;&amp; tree)&#123; if(this != &amp;tree)&#123; Destroy(_root); _root = _CopyTree(tree._root); return *this; &#125;&#125;//BinaryTree&lt;T&gt;&amp; operator=(BinaryTree&lt;T&gt; tree)&#123; //if(this != &amp;tree)&#123; //swap(_root, tree._root); //return *this; //&#125;//&#125; 赋值运算符的重载有两种实现方式，第一种是传统写法，第二种是现代写法。传统写法就是销毁原来的空间，然后重新开辟新的空间。对内存的操作比较多。现代写法是利用拷贝构造的方式，在传值进来的时候，生成一份临时拷贝，然后交换当前二叉树和临时拷贝的根节点，返回根节点，同时利用临时拷贝的作用域，交换后的二叉树在出了当前函数之后被销毁。相当于借用了系统的拷贝机制和自动析构机制来实现赋值的过程。 递归遍历先序遍历先序遍历：root left right12345678910111213//PrevOrdervoid PrevOrder()&#123; _PrevOrder(_root); cout &lt;&lt; endl;&#125;void _PrevOrder(Node* root)&#123; if(root)&#123; cout &lt;&lt; root-&gt;_data &lt;&lt; " "; _PrevOrder(root-&gt;_left); _PrevOrder(root-&gt;_right); &#125; return;&#125; 中序遍历中序遍历：left root right12345678910111213//InOrdervoid InOrder()&#123; _InOreder(_root); cout &lt;&lt; endl;&#125;void _InOreder(Node* root)&#123; if(root)&#123; _InOreder(root-&gt;_left); cout &lt;&lt; root-&gt;_data &lt;&lt; " "; _InOreder(root-&gt;_right); &#125; return;&#125; 后序遍历后序遍历：left root right12345678910111213//PostOrdervoid PostOrder()&#123; _PostOrder(_root); cout &lt;&lt; endl;&#125;void _PostOrder(Node* root)&#123; if(root)&#123; _PostOrder(root-&gt;_left); _PostOrder(root-&gt;_right); cout &lt;&lt; root-&gt;_data &lt;&lt; " "; &#125; return;&#125; 非递归遍历之所以要出现非递归遍历，是因为递归遍历有一定的缺陷。比如：当二叉树是一颗父节点只有一个子节点的树，那么对堆栈的使用就很大，有可能出现堆栈使用太深而栈溢出的情况。为了避免这种情况的出现，有必要使用非递归遍历。非递归遍历利用栈来实现对之前的结点的存储，因为每一颗二叉树都有可能有左右子树，所以需要在访问单边的子树的时候，将结点保存下来，这样是为了之后可以返回去访问结点的另一边的子树。 层次遍历层次遍历是一层一层的遍历结点的。它与之前三个的遍历方式都不一样。他利用的是队列，通过队列让父节点带动子节点。123456789101112131415161718192021//LevelOrdervoid LevelOrder()&#123; //不能是T，要用到root-&gt;_left; root-&gt;_right; //不好是Node，结构体太大; queue&lt;Node*&gt; q; if(_root)&#123; q.push(_root); while(!q.empty())&#123; Node* top = q.front(); //获取到队头之后，将当前结点pop q.pop(); cout &lt;&lt; top-&gt;_data &lt;&lt; " "; //如果左右子树存在，就入队列 if(top-&gt;_left) q.push(top-&gt;_left); if(top-&gt;_right) q.push(top-&gt;_right); &#125; &#125; cout &lt;&lt; endl;&#125; 先序遍历非递归根据先序遍历的特点，先输出当前结点，然后一路向左，访问完左边再返回访问上一个结点的右子树，这个就是子问题，利用上面一样的方法。1234567891011121314151617181920//PrevOrderNonRvoid PrevOrderNonR()&#123; //利用栈得以记录访问过的根，用来以后访问右子树 stack&lt;Node*&gt; s; Node* cur = _root; while(cur || !s.empty())&#123; //根据先根的次序，访问当前节点，并一路向左访问 while(cur)&#123; cout &lt;&lt; cur-&gt;_data &lt;&lt; " "; s.push(cur); cur = cur-&gt;_left; &#125; Node* top = s.top(); //pop表示左子树已经访问完，接下来访问右子树 s.pop(); //右子树的访问是子问题 cur = top-&gt;_right; &#125; cout &lt;&lt; endl;&#125; 中序遍历非递归中序遍历和先序遍历唯一的不同就是先序遍历是访问当前结点就打印当前结点，中序遍历就是先走完左边，再回来获取结点，这个时候再输出。12345678910111213141516//InOrderNonRvoid InOrderNonR()&#123; stack&lt;Node*&gt; s; Node* cur = _root; while(cur || !s.empty())&#123; while(cur)&#123; s.push(cur); cur = cur-&gt;_left; &#125; Node* top = s.top(); s.pop(); cout &lt;&lt; top-&gt;_data &lt;&lt; " "; cur = top-&gt;_right; &#125; cout &lt;&lt; endl;&#125; 后序遍历非递归后序遍历相比于之前的有一个转弯，看下图：所以为了区分这个点，先设立一个prev，prev指向当前结点cur的上一个结点。如果prev == cur-&gt;_right表示当前结点的右子树已经访问完成，那么就可以输出cur了。12345678910111213141516171819202122232425262728//PostOrderNonRvoid PostOrderNonR()&#123; stack&lt;Node*&gt; s; Node* cur = _root; Node* prev = NULL; while(cur || !s.empty())&#123; //一路向左走到底 while(cur)&#123; s.push(cur); cur = cur-&gt;_left; &#125; Node* top = s.top(); //访问当前结点的两个条件 //1、没有右子树 //2、右子树已经访问完成 if(top-&gt;_right == NULL || prev == top-&gt;_right)&#123; s.pop(); //此时的top成为过去式，将top设置为prev prev = top; cout &lt;&lt; top-&gt;_data &lt;&lt; " "; &#125; //此时表示右子树还没有访问 else&#123; cur = top-&gt;_right; &#125; &#125; cout &lt;&lt; endl;&#125; 结点个数函数以下函数都利用了递归的思想。 统计结点个数函数Size123456789//Sizesize_t Size()&#123; return _Size(_root);&#125;size_t _Size(Node* root)&#123; if(root == NULL) return 0; return _Size(root-&gt;_left) + _Size(root-&gt;_right) + 1;&#125; 统计深度函数Depth统计深度的时候，因为二叉树有左右子树，所以需要区分是左子树结点多还是右子树结点多。通过两个变量来记录，分别统计大小，然后再比较大小，大的是深度。这里默认根节点是第一层12345678910111213141516//Depthsize_t Depth()&#123; return _Depth(_root);&#125;size_t _Depth(Node* root)&#123; size_t leftnum = 0; size_t rightnum = 0; if(root == NULL) return 0; //如果存在就接着往下递归 if(root-&gt;_left) leftnum += _Depth(root-&gt;_left); if(root-&gt;_right) rightnum += _Depth(root-&gt;_right); return (leftnum &gt; rightnum ? leftnum : rightnum) + 1;&#125; 统计叶子结点个数的函数LeafSize叶子结点的统计是在当前结点都没有左右子树的时候返回个数1。1234567891011//LeafSizesize_t LeafSize()&#123; return _LeafSize(_root);&#125;size_t _LeafSize(Node* root)&#123; if(root == NULL) return 0; if(root-&gt;_left == NULL &amp;&amp; root-&gt;_right == NULL) return 1; return _LeafSize(root-&gt;_left) + _LeafSize(root-&gt;_right);&#125; 计算第K层的结点个数函数GetKLevel这个函数可以通过子问题的思想来解决。比如：我要计算第三层，当指针在第一层的时候，是计算K=3；当指针在第二层的时候，是计算K=2；当指针在第三层的时候，是计算K=1的结点个数。所以只要当K=1的时候返回计算值1就好了。12345678910111213//GetKLevelsize_t GetKLevel(size_t K)&#123; return _GetKLevel(_root, K);&#125;size_t _GetKLevel(Node* root, size_t K)&#123; if(K == 0 || root == NULL) return 0; if(K == 1) return 1; //不能使用--K，应该用K-1。 //不能返回除了K=1的其他情况。 return _GetKLevel(root-&gt;_left, K - 1) + _GetKLevel(root-&gt;_right, K - 1);&#125; 测试代码1234567891011121314151617181920212223242526272829303132int a1[] = &#123;1,2,3,'#','#',4,'#','#',5,6,'#','#','#'&#125;;int a2[] = &#123;1,2,'#',3,'#','#',4,5,'#',6,'#',7,'#','#',8,'#','#'&#125;;BinaryTree&lt;int&gt; tree(a1,'#');BinaryTree&lt;int&gt; tree1(a2, '#');BinaryTree&lt;int&gt; tree2(tree);tree2 = tree1;cout &lt;&lt; "tree.PrevOrder" &lt;&lt; endl;tree.PrevOrder();cout &lt;&lt; "tree1.InOrder" &lt;&lt; endl;tree1.InOrder();cout &lt;&lt; "tree2.PostOrder" &lt;&lt; endl;tree2.PostOrder();cout &lt;&lt; "tree.LevelOrder" &lt;&lt; endl;tree.LevelOrder();cout &lt;&lt; "tree.PrevOrderNonR" &lt;&lt; endl;tree.PrevOrderNonR();cout &lt;&lt; "tree1.InOrderNonR" &lt;&lt; endl;tree1.InOrderNonR();cout &lt;&lt; "tree2.PostOrderNonR" &lt;&lt; endl;tree2.PostOrderNonR();cout &lt;&lt; "tree.Size:" &lt;&lt; tree.Size() &lt;&lt; endl;cout &lt;&lt; "tree.Depth:" &lt;&lt; tree.Depth() &lt;&lt; endl;cout &lt;&lt; "tree.LeafSize:" &lt;&lt; tree.LeafSize() &lt;&lt; endl;cout &lt;&lt; "tree.GetKLevel(K=2):" &lt;&lt; tree.GetKLevel(2) &lt;&lt; endl;cout &lt;&lt; "tree1.Size:" &lt;&lt; tree1.Size() &lt;&lt; endl;cout &lt;&lt; "tree1.Depth:" &lt;&lt; tree1.Depth() &lt;&lt; endl;cout &lt;&lt; "tree1.LeafSize:" &lt;&lt; tree1.LeafSize() &lt;&lt; endl;cout &lt;&lt; "tree1.GetKLevel(K=3):" &lt;&lt; tree1.GetKLevel(3) &lt;&lt; endl; 截图如下：二叉树的实现，最重要的是要掌握子问题的思想，通过子问题的思想来解决左右子树，只需要一个递归就好了。]]></content>
      <categories>
        <category>knowledge</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[智能指针]]></title>
    <url>%2F%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.html</url>
    <content type="text"><![CDATA[智能指针是C++中一个编程技巧。它保证内存的正确释放，解决了内存泄漏的问题。有一个思想叫做RAII，RAII指的是资源分配即初始化。我们通常会定义一个类来封装资源的分配和释放，在构造函数中完成资源的分配和初始化，在析构函数中完成资源的清理。在C++中，我们一般是使用new和delete来实现内存的初始化和释放。正确的配对使用可以处理绝大部分问题，但是如果出现了执行流的跳转，比如：语句中间出现了return，break，continue，goto，等关键字，我们的delete可能没有执行，这样就导致了内存没有被释放。又或者我们的语句出现了错误，抛出异常导致程序结束，也有可能没有执行delete语句。这 些问题都导致了内存泄漏。智能指针的出现就是为了解决这些问题的。智能指针其实是一个类，它可以自动的处理指针指向的动态资源的释放。 发展历程 早期C++98：auto_ptr，最早出现的智能指针，拷贝机制是管理权转移，致命缺陷，不使用。 boost(非官方)： scoped_ptr/scoped_array：守卫指针，拷贝机制是不拷贝，简单粗暴 shared_ptr/shared_array：共享指针，拷贝机制是引用计数，比较复杂，会出现循环引用的问题。 weak_ptr：弱指针，不单独使用，辅助共享指针解决循环引用的问题 C++11：unique_ptr对应boost的scoped_ptr；shared_ptr对应boost的shared_ptr；weak_ptr对应boost的weak_ptr。 本文主要实现shared_ptr和weak_ptr的模拟，auto_ptr和scoped_ptr模拟拷贝相关的函数。 auto_ptr123456789101112131415161718192021222324252627282930313233343536//模拟主要函数：template &lt;class T&gt;class AutoPtr&#123;private: T* _ptr;public: AutoPtr(T* ptr)&#123; _ptr = ptr; &#125; ~AutoPtr()&#123; delete _ptr; &#125; T&amp; operator*()&#123; return *_ptr; &#125; T* operator-&gt;()&#123; return _ptr; &#125; AutoPtr(AutoPtr&lt;T&gt;&amp; ap)&#123; //管理权转移 _ptr = ap._ptr; ap._ptr = NULL; &#125; AutoPtr&lt;T&gt;&amp; operator=(AutoPtr&lt;T&gt;&amp; ap)&#123; //自己给自己赋值不作处理 if(this != &amp;ap)&#123; if(_ptr) delete _ptr; //管理权转移 _ptr = ap._ptr; ap_ptr = NULL; &#125; return *this; &#125;&#125;;int main()&#123; AutoPtr&lt;int&gt; ap1(new int(10)); AutoPtr&lt;int&gt;ap2 = ap1; //崩溃，因为ap1已经指向NULL *ap1 = 20; return 0;&#125; 图解如下：任何时候我们都不使用auto_ptr，因为管理权的转移是不符合我们正常指针的使用的，而且会引起程序崩溃，这个是不允许的。最后，解释一下，operator-&gt;()返回T*的原因：12345//设定一个类struct student&#123; int num; &#125;//调用AutoPtr&lt;student&gt; sp = new student;sp-&gt;num = 20; sp-&gt;num等价于sp.operator-&gt;()。sp.operaotr-&gt;()返回T*指针之后，编译器自动将原式优化为_ptr-&gt;num,从而实现对元素的访问。 scoped_ptr防拷贝的智能指针，boost版本相当于C++11的unique_ptr12345678//模拟拷贝的主要函数：template &lt;class T&gt;class ScopedPtr&#123;private: //与AutoPtr不同的就是这两个函数 ScopedPtr(const ScopedPtr&lt;T&gt;&amp; sp); ScopedPtr&lt;T&gt;&amp; operator= (const ScopedPtr&lt;T&gt;&amp; sp);&#125;; scoped_ptr通过将拷贝构造函数和赋值运算符重载定义为私有，同时只声明不定义，这样可以保证该类不能被拷贝。这就简单的解决了auto_ptr因为拷贝导致的管理权转移问题。 shared_ptr引用计数的智能指针，这个类除了有指针之外，再多开辟了一个内存空间，用于存放计数。这种智能指针是实现的最好的，在boost库中，实现起来很复杂，因为要考虑多线程等情况。12345678910111213141516171819202122232425262728293031323334353637383940414243//模拟主要函数template &lt;class T&gt;class SharedPtr&#123;private: T* _ptr; int* _refcount;public: //构造 SharedPtr(const T&amp; ptr)&#123; _ptr = ptr; _refcount = new int(1); &#125; //析构 ~SharedPtr()&#123; if(--_refcount == 0)&#123; delete _ptr; delete _refcount; &#125; &#125; //拷贝构造 SharedPtr(SharedPtr&lt;T&gt;&amp; sp)&#123; _ptr = sp._ptr; _refcount = sp._refcount; ++_refcount; &#125; //赋值运算符重载 SharedPtr&lt;T&gt;&amp; operator=(const SharedPtr&lt;T&gt;&amp; sp)&#123; if(*this != &amp;sp)&#123; if(--(*_refcount) == 0)&#123; delete _ptr; delete _refcount; &#125; _ptr = sp._ptr; _refcount = sp._refcount; (*_refcount)++; &#125; return *this; &#125; //*重载 T&amp; operator*()&#123; return *_ptr; &#125; //-&gt;重载 T* operator-&gt;()&#123; return _ptr; &#125;&#125;; 这个实现，将是比较实用的。但是依然有一个场景下，会出现问题。这个问题叫做循环引用，问题的根源是引用计数被循环使用，不能减为0，导致死循环。下面以双向链表作为例子：1234567891011121314151617//定义一个链表节点如下struct ListNode&#123; //构造函数... //为了方便调用，设为public int _data; SharedPtr&lt;ListNode&gt; _next; SharedPtr&lt;ListNode&gt; _prev;&#125;;//调用这个节点，设定这样一个场景int main()&#123; SharedPtr&lt;ListNode&gt; cur(new ListNode); SharedPtr&lt;ListNode&gt; next(new ListNode); cur-&gt;_next = next; next-&gt;_prev = cur;&#125; 创建模型如下：根据上面例子，_next和next都指向后面节点这个空间，next._refcount = 2。_prev和cur指向前面那个节点的空间，cur._refcount = 2。当程序结束的时候，next先被析构。若需要析构next就需要析构next._prev;要析构next._prev就需要析构cur;要析构cur就需要析构cur._next;要析构cur._next就需要析构next……这样就造成了死循环。为了解决这个循环引用的问题，引入了弱指针weak_ptr。 weak_ptr弱指针不单独使用，它的存在就是为了解决使用shared_ptr造成的循环引用问题。12345678910111213141516171819202122232425262728293031323334template &lt;class T&gt;class WeakPtr&#123;private: T* _ptr;public: WeakPtr()&#123; _ptr = NULL; &#125; WeakPtr(const SharedPtr&lt;T&gt;&amp; sp)&#123; _ptr = sp._ptr; &#125; T&amp; operator*()&#123; return *_ptr; &#125; T* operator-&gt;()&#123; return _ptr; &#125; WeakPtr&lt;T&gt;&amp; operator=(const SharedPtr&lt;T&gt;&amp; sp)&#123; _ptr = sp._ptr; return *this; &#125;&#125;;//还需要修改一下两处：//1、修改ListNode的结构struct ListNode&#123; int _data; WeakPtr&lt;ListNode&gt; _next; WeakPtr&lt;ListNode&gt; _prev;&#125;;//2、将WeakPtr定义为SharedPtr的友元，因为WeakPtr中需要访问SharedPtr的私有成员template &lt;class T&gt;class SharedPtr&#123; friend class WeakPtr; //...&#125;; 这样，上面那个例子中，next._refcount = 1，cur._refcount = 1,就不会出现循环引用的问题了。]]></content>
      <categories>
        <category>knowledge</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板的类型萃取]]></title>
    <url>%2F%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96.html</url>
    <content type="text"><![CDATA[类型萃取，是C++中的一种编程技术。当我们希望对模板传递的不同类型进行不同的操作的时候，同时我们又不希望改变该模板的封装方式。我们可以通过这种技术，对传入的不同类型进行不同的原理操作。 特化要明白类型萃取，首先要知道模板中的特化。一般来说，我们的模板是通用类型的，但是如果有一些类型，我们希望有不同的操作方式，我们就可以通过特化的方式。例子如下：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;//模板的一般版本template &lt;class T&gt;class number&#123;public: void show()&#123; cout &lt;&lt; "number" &lt;&lt; endl; &#125;&#125;;//模板的int类型特化版本template &lt;&gt;class number&lt;int&gt;&#123;public: void show()&#123; cout &lt;&lt; "int" &lt;&lt; endl; &#125;&#125;;int main()&#123; system("clear"); number&lt;int&gt; numint; numint.show(); number&lt;float&gt; numfloat; numfloat.show(); number&lt;char&gt; numchar; numchar.show(); return 0;&#125; 只有int类型才会输出int，其它的就像是float和char类型输出的都是number特化的方式，其实是十分冗余的。如果我的number类有很多的封装，那么实现它的特化，就需要将这些封装重新实现一遍。这样的复用性就十分低。 类型萃取TypeTraits关于类型萃取的知识，可以看看我的这篇读书笔记中的3.3和3.4我的个人博客文章地址我的CSDN博客文章地址这里我进行一个对于自创类SeqList类(对STL中vector的模拟)的类型萃取举例，情景说明：这里我想要对模板类SeqList进行拷贝，涉及到一个问题。如果我的元素类型是string的话，我必须进行深拷贝，否则就会出现奔溃的情况，这是对内存的使用出现问题。当我的元素类型是int、float、char等平凡类型(即POD:plain old data，基本类型，这些类型的拷贝不会涉及到内存的使用异常)，我就可以使用浅拷贝，这样比起深拷贝提高了效率。这个时候，我通过在SeqList类中进行类型萃取，就可以实现两种不同的拷贝方式：12345678910111213141516171819202122232425262728293031323334353637383940414243//定义两个空类struct __TrueType&#123;&#125;;struct __FalseType&#123;&#125;;//一般类型及特化(内嵌重定义IsPODType)template&lt;class T&gt;struct __TypeTraits&#123; typedef __FalseType IsPODType; &#125;;template&lt;&gt;struct __TypeTraits&lt;int&gt;&#123; typedef __TrueType IsPODType; &#125;;//实现功能函数(用__TrueType/__FalseType实现重载)template &lt;class T&gt;T* __TypeCopy(T* dst, const T* src, size_t n, __TrueType)&#123; //浅拷贝，调用memcpy return (T*)memcpy(dst, src, n*sizeof(T));&#125;template &lt;class T&gt;T* __TypeCopy(T* dst, const T* src, size_t n, __FalseType)&#123; //深拷贝，进行了 operator= 调用 for(size_t i = 0; i&lt;n; ++i)&#123; dst[i] = src[i]; &#125; return dst;&#125;//对外接口(实现IsPODType的__TrueType和__FalseType的转换)template &lt;class T&gt;T* TypeCopy(T* dst, const T* src, size_t n)&#123; return __TypeCopy(dst, src, n, __TypeTraits&lt;T&gt;::IsPODType);&#125;//调用int main()&#123; int a1[3] = &#123;1, 2, 3&#125;; int a2[2] = &#123;0, 0, 0&#125;; string s1[3] = &#123;"1", "2", "3"&#125;; string s2[3] = &#123;"0", "0", "0"&#125;; TypeCopy(a1, a2, 3); TypeCopy(s1, s2, 3); return 0;&#125; 这样，当传入的参数是s1,s2的时候，__TypeTraits调用的是一般版本，IsPODType为__FalseType,这样__TypeCopy调用的是__FalseType的重载版本，进行深拷贝。当传入的参数是a1，a2的时候，调用的是__TrueType的重载版本，进行浅拷贝。这里只对int进行了特化，所以只有int可以调用__TrueType的版本。但是我们可以对float、double等PODType进行特化，这样就大大提高了代码的复用性。]]></content>
      <categories>
        <category>knowledge</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板与分离编译]]></title>
    <url>%2F%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%88%86%E7%A6%BB%E7%BC%96%E8%AF%91.html</url>
    <content type="text"><![CDATA[分离编译模式一个项目如果有多个源文件组成，每个源文件单独编译，形成目标文件。最后通过链接器将所有的目标文件链接起来，形成一个可执行的文件。这个过程就叫做分离编译。 模板不能分离编译有一个项目，其中函数声明放在”test.h”中，函数实现放在”test.cpp”中，函数调用放在”main.cpp”中。如果没用使用模板，将不会有任何问题。而且这样是被推荐使用的。但是如果有函数的实现是模板函数或有模板类，将会出现链接错误。代码如下:1234567891011121314151617181920//test.h#pragma oncetemplate &lt;class T&gt;void print(T num);//test.cpptemplate &lt;class T&gt;void print(T num)&#123; cout &lt;&lt; num &lt;&lt; endl; &#125;//main.cpp#include &lt;iostream&gt;#include "test.h"using namespace std;int main()&#123; int number = 10; print(number); return 0;&#125; 这样的代码看起来是没有问题的。执行的时候并不会出现编译错误，但是会出现链接错误。这是因为采取了分离编译之后，我们的.cpp文件是独立编译的。test.cpp中的模板函数，由于没有被调用，所以它的T并没有被实例化相应的类型，比如例子中的int类型。main.cpp中调用了函数print，他需要实例print(int num)。在链接的时候，找不到需要的实例化函数，这样就产生了错误。 解决办法1-显示实例化在函数定义的时候，指定我们需要实例化的类型。在头文件定义中添加指定类型的定义：123456#pragma oncetemplate &lt;class T&gt;void print(T num);//添加int定义template void print&lt;int&gt;(int num); 这种方式是最简单，但是这样却是最麻烦的。如果我有多个不同类型，就需要有相应个数的特化。 解决办法2-不使用分离编译既然不能使用，那么我们不使用分离编译就是了。将我们的函数声明和函数定义放在test.h中。这样我们编译的时候，需要将头文件展开，这样就可以将模板函数在编译的时候实例化。123456//test.h//不需要test.cpp#pragma oncetemplate &lt;class T&gt;void print(T num)&#123; cout &lt;&lt; num &lt;&lt; endl; &#125; 这样解决了模板的分离编译的问题，但是这样也就暴露了我们的函数定义。]]></content>
      <categories>
        <category>knowledge</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅读《STL源码剖析》笔记 4章-vector和list]]></title>
    <url>%2F%E6%B5%85%E8%AF%BB%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0-4%E7%AB%A0-vector%E5%92%8Clist.html</url>
    <content type="text"><![CDATA[4 序列式容器4.1 容器的概观与分类所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。 4.2 vector4.2.1 vector概述array是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。 4.2.3 vector的迭代器由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。vector&lt;int&gt; :: iterator ivite;vector&lt;Shape&gt; :: iterator svite;其中 ivite的类型就是int*，svite的类型就是Shape* 。 4.2.4 vector的数据结构vector的数据结构如下：123456789template&lt;class T, class Alloc = alloc&gt;class vecotr&#123; //... protected: //注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置 iterator start; //表示目前使用空间的头部 iterator finish; //表示目前使用空间的尾部 iterator end_of_storage; //表示目前可用空间的尾部&#125; 为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。 4.2.5 vector的构造与内存管理：constructor，push_backpush_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。push_back源代码节选如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void push_back( const T&amp; x)&#123; if( finish != end_of_storage )&#123; construct( finish, x ); ++finish; &#125; else //无备用空间 insert_aux(end(), x);&#125;template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux( iterator positon, const T&amp; x )&#123; if( finish != end_of_storage )&#123; //为什么还要再次判断 construct( finish, *(finish - 1)); ++finish; T x_copy = x; //不懂 copy_backward(position, finish - 2, finish - 1); *position = x_copy; &#125; else&#123; //无备用空间 const size_type old_size = size(); const size_type len = old_size != 0 ? 2*old_size : 1; iterator new_start = data_allocator::allocatr(len); //实际配置空间 iterator new_finish = new_start; try&#123; //将原来vector内容拷贝到新的vector new_finish = uninitialized_copy(start, position, new_start); //为新元素设定初值x construct(new_finish, x); ++new_finish; //将安插点的原内容也拷贝过来//不懂 new_finish = uninitialized_copy(posiition, finish, new_finish); &#125; catch(...)&#123; //开辟失败 destroy(new_start, new_finish); data_allocator::deallocate(new_start, len); throw; &#125; //析构并释放原vector destory(begin(), end()); deallocate(); //调整迭代器，指向新的vector start = new_start; finish = new_finish; end_of_storage = new_start+len; &#125;&#125; 4.2.6 vector的元素操作：pop_back, erase, clear, insert1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//清除[first, last)中的元素iterator erase(iterator first, iterator last)&#123; iterator ii = copy(last, finish, first); //copy是全局函数，第六章 destory(i, finish); finish = finish - (last - first); return first;&#125;//清除某个位置上的元素iterator erase(iterator position)&#123; if(position + 1 != end()) copy(position + 1, finish, position); --finish; destroy(finish); return position;&#125;void clear()&#123; erase(begin(), end()); &#125;//从position开始，插入n个元素，元素初值为xtemplate &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert(iterator position, size_type n ,const T&amp; x)&#123; if(n != 0)&#123; //备用空间大于等于新增元素个数 if(size_type(end_of_storage - finish) &gt;= 0)&#123; T x_copy = x; //计算插入点之后的现有元素个数 const size_type elems_after = finish - position; iterator old_finish = finish; if(elems_after &gt; n)&#123; //插入点之后的现有元素个数 &gt; 新增元素个数 uninitialized_copy(finish - n, finish, finish); finish += n; //将vector 尾端标记后移 copy_backward(position, old_finish - n, old_finish); fill(position, position+n, x_copy); //从插入点开始填入新值 &#125; else&#123; uninitialized_fill_n(finish, n-elems_affter, x_copy); finish += n - elems_after; uninitialized_copy(position, old_finish, finish); finish += elems_after; fill(position, old_finish, x_copy); &#125; &#125; else&#123; //备用空间 &lt; 新增元素个数 const size_type old_size = size(); //决定新的长度为旧长度+新增元素个数 const size_type len = old_size + max(old_size, n); //配置新的vector空间 iterator new_start = data_allocaator::allocate(len); iterator new_finish = new_start; __STL_TRY&#123; //&lt;-- 这个是什么 //将旧的vector在插入点之前的元素复制到新空间 new_finish = uninitialized_copy(start, position, new_start); //将新增元素(初值为x)填入新空间 new_finish = uninitialized_fill_n(new_finish, n, x); //将旧的vector在插入点之后的元素复制到新空间 nwe_finish = uninitialized_copy(position, finish, new_finish); &#125; //异常处理 //... //清除释放旧的空间 destroy(start，finish); deallocate(); //调整迭代器指向新的空间 start = new_start; finish = new_finish; end_of_storage = new_start+len; &#125; &#125;&#125;//插入操作完成之后，新增节点应位于position的后面。 图解如下： 4.3 list4.3.1 list概述list每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。 4.3.2 list的节点(node)list的节点和list本身的设计是分开的。以下是STL list的节点结构：12345678template &lt;class T&gt;struct __list_node&#123; typedef void* void_pointer; void_pointer prev; //型别为void*，其实可以是__list_node&lt;T&gt; void_pointer next; T data;&#125;//这是一个双向链表节点 4.3.3 list的迭代器list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效 4.3.4 list的数据结构SGI list 是一个双向循环链表。list结构如下：123456789template &lt;class T, class Alloc = alloc&gt;class list&#123;protected: typedef __list_node&lt;T&gt; list_node;public: typedef list_node* link_type;protected: link_type node;&#125; STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。12345678910iterator begin() &#123; return (link_type)((*node).next); &#125;iterator end() &#123; return node; &#125;bool empty() const &#123; return node-&gt;next == node; &#125;size_type size() const &#123; size_type result = 0; distance(begin(), end(), result); //全局函数，第三章//计算两个迭代器之间的距离 return result;&#125;reference front() &#123; return *begin(); &#125;reference back() &#123; return *(--end()); &#125; 图解如下： 4.3.5 list的构造与内存管理：constructor， push_back, insertlist缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。list_node_alloctor(n)表示配置n个节点空间。同时有四个函数，如下：12345678//配置一个节点并传回link_type get_node();//释放一个节点void put_node(link_type p);//配置并构造一个节点，带有元素值link_type create_node(const T&amp; x);//析构并释放一个节点void destroy_node(link_type p); list众多构造函数中，有一个允许我们构造一个空list出来：123456789public: list()&#123; empty_initialize(); &#125;protected: void empty_initialize()&#123; //next、prev指针都指向自己 node = get_node(); node-&gt;next = node; node-&gt;prev = node; &#125; 空节点对象模型：当我们用push_back()插入新节点的时候，函数内部调用insert()void push_back(const T&amp; x) { inset( end(), x ); }insert()有很多的重载函数，最简单的如下:12345678910//在迭代器position所指位置插入一个节点，值为xiterator insert(iterator position, const T&amp; x)&#123; link_type tmp = create_node(x); //插入位置在position之前,这是STL规范。 tmp-&gt;next = position.node; tmp-&gt;prev = position.node-&gt;prev; (link_type(position.node-&gt;node-&gt;prev))-&gt;next = tmp; position.node-&gt;prev = tmp; return tmp;&#125; 4.3.6 list的元素操作：push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sortpush_front, push_back复用insert；pop_front, pop_back复用erase。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//移除迭代器position所指节点iterator erase(iterator position)&#123; link_type next_node = link_type(position.node-&gt;next); link_type prev_node = link_type(position.node-&gt;prev); prev_node-&gt;next = next_node; next_node-&gt;prev = prev_node; destroy_node(position.node); return iterator(next_node);&#125;//清除所有节点template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::clear()&#123; link_type cur = (link__type) node-&gt;next; //begin(); while( cur != node )&#123; link_type tmp - cur; cur = (link_type)cur-&gt;next; destroy_node(tmp); &#125; //恢复成空节点的初始结构 node-&gt;next = node; node-&gt;prev = node;&#125;//将数值为value的所有元素移除template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::remove(const T&amp; value)&#123; iterator first = begin(); iterator last = end(); while(first != last)&#123; iterator next = first; ++next; if(*first == value) erase(first); first = next; &#125;&#125;//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个//很帅啊template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::unique()&#123; iterator first = begin(); iterator last = end(); if(first == last) return; //判空 iterator next = first; while(++next != last)&#123; if(*first == *next) erase(next); else first = next; next = first; &#125;&#125; list 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。12345678910111213141516protected: //将[first, last)内的所有元素移动到position之前。 void transfer(iterator position, iterator first, iterator last)&#123; if(position != last)&#123; //先处理各节点的next (*(link_type((*last.node).prev))).next = position.node; (*(link_type((*first.node).prev))).next = last.node; (*(link_type((*position.node).prev))).next = first.node; //tmp为position的prev节点 link_type tmp = link_type((*position.node).prev); //处理各节点的prev (*position.node).prev = (*last.node).prev; (*last.node).prev = (*first.node).prev; (*first.node).prev = tmp; &#125; &#125; splice各个版本：1234567891011121314151617181920public: //将list x接合与position所指位置之前，x必须不同于*this void splice(iterator position, list&amp; x)&#123; if(!x.empty()) transfer(position, x.begin(), x.end()); &#125; //将i 所指元素接合于position所指元素之前。position和i可指向同一个list void splice(iterator position, list&amp;, iterator i)&#123; iterator j = i; ++j; if(position == i || position == j) return; trasfer(position, i, j); &#125; //将[first, last)内的所有元素接合于position所指位置之前， //position和[first, last)可指向同一个list。 //但是position不能在[first, last)范围之内 void splice(iterator posiition, list&amp;, iterator first, iterator last)&#123; if(first != last) transfer(position, first, last); &#125; merge(), reverse(), sort()源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//merge()将x合并到*this上，两个list必须是递增排序的template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::merge(list&lt;T, Alloc&gt;&amp; x)&#123; iterator first1 = begin(); iterator last1 = end(); iterator first2 = x.begin(); iterator last2 = x.end(); while(first1 != last1 &amp;&amp; first2 != last2)&#123; if(*first2 &lt; *first1)&#123; iterator next = first2; transfer(first1, first2, ++next); first2 = next; &#125; else ++first1; if(first2 != last2) transfer(last1, first2,last2); &#125;&#125;//reverse()将*this的内容逆置template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::reverse()&#123; //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢 if(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; iterator first = begin(); ++first; while(first != end())&#123; iterator old = first; ++first; transfer(begin(), old, first); &#125;&#125;//list不能使用STL中的sort()算法，只能使用自己的sort()//因为STL的sort()只接受RamdonAccessIterator//本函数使用quick sorttemplate &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::sort()&#123; //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢 if(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; //创建新的list空间，作为中介数据存放区 list&lt;T, Alloc&gt; carry; list&lt;T, Alloc&gt; counter[64]; int fill = 0; while(!empty())&#123; carry.splice(carry.begin(), *this, begin()); int i = 0; while(i &lt; fill &amp;&amp; !counter[i].empty())&#123; counter[i].merge(carry); carry.swap(counter[i++]); &#125; carry.swap(counter[i]); if(i == fill) ++fill; &#125; for(int i = 1; i &lt; fill; ++i) counter[i].merge(counter[i-1]); swap(counter[fill-1]);&#125;]]></content>
      <categories>
        <category>learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅读《STL源码剖析》笔记 3章]]></title>
    <url>%2F%E6%B5%85%E8%AF%BB%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0-3%E7%AB%A0.html</url>
    <content type="text"><![CDATA[3 迭代器(iterator)概念与traits编程技法迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式 3.1 迭代器设计思维STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一 12345678910111213141516171819202122232425262728293031323334//3.1举例说明迭代器的使用//find()的定义。template &lt;class InputIterator, chass T&gt;InputIterator find( InputIterator first, InputIterator last, const T&amp; value )&#123; while ( first != last &amp;&amp; *first != value ) ++first; return first;&#125;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; const int arraySiza = 7; int ia[arraySiza] = &#123; 0, 1, 2, 3, 4, 5, 6 &#125;; vector&lt;int&gt; ivect(ia, ia+arraySiza); //调用vector的iterator用于find() vector&lt;int&gt;::iterator it1 = find(ivect.begin(), ivect.end(), 4); if( it1 == ivect.end() ) cout &lt;&lt; "4 not found." &lt;&lt; endl; else cout &lt;&lt; "4 found:" &lt;&lt; *it1 &lt;&lt; endl; it1 = find(ivect.begin(), ivect.end(), 8); if( it1 == ivect.end() ) cout &lt;&lt; "8 not found." &lt;&lt; endl; else cout &lt;&lt; "8 found" &lt;&lt; *it1 &lt;&lt; endl; return 0;&#125; 运行结果： 3.2 迭代器(ierator)是一种smart pointer迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-&gt; 进行重载工作。以下，简单模拟一个list的结构，然后设计对应的iterator。12345678910111213141516171819202122232425//listnodetemplate &lt;typename T&gt;class ListItem&#123;public: T value() const&#123; return _value; &#125; ListItem* next() const&#123; return _next; &#125; //...private: T _value; ListItem* _next; //单向链表(single linked list)&#125;;//listtemplate &lt;typename T&gt;class List&#123;public: void insert_front(T value); //省略实现 void insert_end(T value); //省略实现 voide display(std::ostream &amp;os = std::cout) const;//省略实现 //...private: ListItem&lt;T&gt;* _end; ListItem&lt;T&gt;* _front; long _size;&#125;; 当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：1234567891011121314151617181920212223242526//iteratortemplate &lt;class Item&gt;//Item可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的operator++只适用于链表。struct ListIter&#123; Item* ptr; //保持与容器之间的一个联系 ListIter( Item* p = 0 ) :ptr(p) &#123;&#125; //不必实现copy ctor，因为编译器提供的缺省行为已经足够 //不必实现operator=，因为编译器提供的缺省行为已经足够 Item&amp; operator*() const &#123; return *ptr; &#125; Item* operator-&gt;() const &#123; return ptr; &#125; //operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator) //pre-increament operator ListIter&amp; operator++()&#123; ptr = ptr-&gt;next(); return *this; &#125; //post-incteament operator LostIter operator++(int)&#123; ListIter tmp = *this; ++*this; return tmp; &#125; bool operator==(const LostIter&amp; i)const&#123; return ptr == i.ptr; &#125; bool operator!=(const LostIter&amp; i)const&#123; return ptr != i.ptr; &#125;&#125; 接下来，将List和find()由ListIter粘合起来：1234567891011121314151617181920int main()&#123; List&lt;int&gt; mylist; for( int i=0; i&lt;5; ++i )&#123; mylist.insert_front(i); mylist.insert_end(i+2); &#125; mylist.displau(); //10( 4 3 2 1 0 2 3 4 5 6) ListIter&lt;ListItem&lt;int&gt; &gt; begin(mylist.front()); ListIter&lt;ListItem&lt;int&gt; &gt; end; ListIter&lt;ListItem&lt;int&gt; &gt; iter; iter = find(begin, end, 3); if( iter == end ) cout &lt;&lt; "not found" &lt;&lt; endl; else cout &lt;&lt; "found." &lt;&lt; iter-&gt;value() &lt;&lt; endl; //执行结果：found.3 return 0;&#125; 由于find() 函数以*iter != value来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 ListIterm&lt;int&gt;,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和ListIterm&lt;int&gt;。如下：12template &lt;typename T&gt;bool operator!=(const ListItem&lt;T&gt;&amp; item, T n)&#123; return item.value() != n; &#125; 3.3 迭代器相应型别(associated types)当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。 3.4 Traits 编程技法——STL源代码门钥value type：迭代器所指对象的型别。上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的”template参数推导机制”推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：123456789101112131415template &lt;class T&gt;struct MyIter&#123; typedef T value_type; //内嵌型别声明(nested type) MyIter(T* p = 0) :ptr(p) &#123;&#125; T&amp; operator*() const &#123; return *ptr; &#125; //... T* ptr; //成员变量&#125;;template &lt;class I&gt;typename I::value_type func( I ite )&#123; return *ite; &#125; //typename I::value_type 这是func的返回值型别；//...MyIter&lt;int&gt; ite(new int(8));cout &lt;&lt; func(ite); //输出:8 typename I::value_type必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。 这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 偏特化(template partial specialization)。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：12345678910//class templatetemplate &lt;typename T&gt;class C&#123; //这个泛化版本接受T为任何型别 //...&#125;;//prartial specializationtemplate &lt;typename T&gt;class C&lt;T*&gt;&#123; //这个特化版本只适用于"T 为原生指针"的情况 //...&#125;; 下面这个例子，专门用来萃取迭代器的特性，value type正是迭代器的特性之一1234template &lt;class I&gt;struct iterator_traits&#123; //traits意思为“特性” typedef typename I::value_type value_type;&#125;; 这样，前面那个func函数可以修改成这样。123template &lt;class I&gt;//typename iterator_traits&lt;I&gt;::value_type 是函数的返回型别typename iterator_traits&lt;I&gt;::value_type func(I ite)&#123; return *ite; &#125; 跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：1234template &lt;class T&gt;struct iterator_traits&lt;T*&gt;&#123; //偏特化版本--迭代器是一个原生指针 typedef T value_type;&#125; 此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的iterator_traits&lt;const int*&gt;::value_type得到的是const int。所以我们另外设计一个特化版本，让const T*转变为T*：1234template &lt;class T&gt;struct iterator_traits&lt;const T*&gt;&#123; //偏特化版本，当迭代器是一个const指针的时候， typedef T value_type; //萃取出来的是T，而不是const T&#125;; 到这里为止，不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。 图解iterator_traits：常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：12345678template &lt;class I&gt;struct iterator_traits&#123; typedef typename I::iterator_category iterator_category; typedef typename I::value_type value_type; typedef typename I::difference_type difference_type; typedef typename I::pointer pointer; typedef typename I::reference reference;&#125;; 其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。以上： 3.4.1 value type 如上3.4.2 difference type3.4.3 reference type3.4.4 pointer type3.4.5 iterator_catrgory]]></content>
      <categories>
        <category>learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅读《STL源码剖析》笔记 1、2章]]></title>
    <url>%2F%E6%B5%85%E8%AF%BB%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0-1%E3%80%812%E7%AB%A0.html</url>
    <content type="text"><![CDATA[1 STL概论与版本简介1.2 STL六大组件 容器(containers):vector,list,deque,set,map,用来存放数据 算法(algorithms):sort,search,copy,erase 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，迭代器器将operator*,operator++,operator--,operator-&gt;等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。 仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。 配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。 配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。 1.5~1.8 STL版本之二 P.J.Plauger (Microsoft Visual C++) SGI STL (Linux GCC) C++标准规范下的C头文件: cstdio,cstdlib,cstring C++标准程序库中不属于STL范畴: stream,string STL标准头文件: vector,deque,list,map,algorithm,functional C++Standard定案前，HP所规范的STL头文件: vector.h,deque.h,list.h,algo.h,function.h SGI STL内部文件(STL真正实现于此): stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h 1.9 可能令你困惑的C++语法1.9.2 临时对象的产生与运用临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。STL中最常将此技巧用在仿函数(functor)中。临时对象的生命周期只有这一行指令。 1.9.3 静态常量整数成员在class内部直接初始化class内含有const static integral data member，我们可以直接给予初值。123456789101112131415//1.9.3测试代码如下template &lt;typename T&gt;class testclass&#123;public: static const int datai = 5; static const long datal = 3L; static const char datac = 'c';&#125;;int main()&#123; cout &lt;&lt; testclass&lt;int&gt;::datai &lt;&lt; endl; cout &lt;&lt; testclass&lt;int&gt;::datal &lt;&lt; endl; cout &lt;&lt; testclass&lt;int&gt;::datac &lt;&lt; endl; return 0;&#125; 运行结果： 1.9.5 前闭后开区间表示法[)STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。 1.9.6 function call操作符(operator())function call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。如果你针对某个class进行operator()重载，它就成为一个仿函数。1234567891011121314151617//1.9.6测试代码如下template &lt;class T&gt;struct Add&#123; //重载了operator() T operator()(const T&amp;x, const T&amp;y) const&#123; return x+y; &#125;&#125;;int main()&#123; Add&lt;int&gt; addxy; system( "clear" ); //调用重载函数 cout &lt;&lt; addxy(3,5) &lt;&lt; endl; //调用匿名对象 cout &lt;&lt; Add&lt;int&gt;()(5,5) &lt;&lt; endl; return 0;&#125; 运行结果： 2 空间配置器(allocator)空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。 2.2 具备此配置力的SGI空间配置器2.2.1 SGI标准的空间配置器,std::allocatorSGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：vector&lt;int,std::allocator&lt;int&gt;&gt;;SGI STL写法如下：vector&lt;int, std::aloc&gt;绝大多数情况下，我们都是使用缺省的空间配置器。 2.2.2 SGI特殊的空间配置器，std::allocSGI同时也配备了标准空间配置器std::allocator，但是这只是对C++的operator new和operator delete做了一层封装，效率低下，SGI并不使用，只是为了向前兼容语法。 SGI自身使用的空间配置器是std::alloc一般来说，我们习惯的C++内存操作和释放操作是这样的：123class Foo&#123;&#125;;Foo* pf = new Foo;delete pf; 这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。STL的配置器(allocator)定于于&lt;memory&gt;，其中包含两个文件,一个是负责内存空间的配置与释放&lt;stl_alloc.h&gt;,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构&lt;stl_construct.h&gt;，定义了全局函数construct()和destroy()。 2.2.3 构造和析构基本工具:construct()和destroy()construct()的实现如下：12345#include &lt;new.h&gt; //使用placement new 需要这个头文件template &lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value)&#123; new (p) T1(value); //使用了placement new;调用T1:T1(value);&#125; 代码解释：construct()接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，通过placement new实现。destroy()有两个版本，实现如下:123456789101112131415161718192021222324252627282930//第一个版本，接受一个指针template &lt;class T&gt;inline void destroy(T* pointer)&#123; pointer-&gt;~T();&#125;//第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits&lt;&gt;求取最适当的措施。template &lt;class ForwardIterator&gt;inline void destroy(ForwardIterator first, ForwardIterator last)&#123; __destroy(first, last, value_type(first));&#125;//判断元素的数值型别(value type)是否有 trivial destructortemplate &lt;class ForwardIterator, class T&gt;inline void __destroy(ForwardIterator first, ForwardIterator last, T*)&#123; typedef typename __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor; __destroy_aux(first, last, trivial_destructor());&#125;//如果元素的数值型别(value type)有non-truvial destructor，循环释放template &lt;class ForwardIterator&gt;inline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type)&#123; for( ; first &lt; last; ++first) //调用第一个版本的destroy() destroy(&amp;* first);&#125;//如果元素的数值型别(value type)有trivial destructor,函数什么也不做template &lt;class ForwardIterator, ForwardIterator, __true_type&gt;&#123; inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type)&#123;&#125;&#125;//destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做inline void desroy(char*, char*)&#123;&#125;inline void destroy(wchar_t*,wchar_t*)&#123;&#125; 代码解释：destroy()有两个版本，第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可。第二个版本接收first和last两个迭代器，准备将[firat, last)范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓trivial destructor),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，这里首先利用value_type()获得迭代器所指对象的型别，再利用__type_traits&lt;T&gt;判断该型别的析构函数是否无关痛痒。若是(__true_type)，则什么都不做结束；若不是(__false_type),这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的destroy()。 construct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits&lt;&gt;在3.7节。 2.2.4 空间的配置与释放，std::alloc对象构造前的空间配置和对象析构后的空间释放，由&lt;stl_alloc.h&gt;负责。 向 system heap 要求空间 考虑多线程(multi-threads)状态(这里不考虑多线程的情况) 考虑内存不足时的应变措施 考虑过多“小型区域”可能造成的内存碎片(fragment)问题 C++内存配置的基本操作是::operator new()，内存释放的基本操作是::operator delete()。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。 为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，第一级配置器(__malloc_alloc_template)用malloc()和free()，第二级配置器(__default_alloc_template)看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池memory bool整理方式。其中具体是开放了第一级配置器还是两级配置器都开放了由USE_MEALLOC是否定义决定，定义了USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。 无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口simple_alloc，使其能够符合STL的接口规格。1234567891011121314151617template &lt;class T,class Alloc&gt;class simple_alloc&#123;public: static T* allocate(size_t n)&#123; return 0 == n?0 : (T*) Alloc::allocate(n* sizeof (T)); &#125; static T* allocate(void)&#123; return (T*) Alloc::allocatte(sizeof (T)); &#125; static void dallocate(T* p, size_t n)&#123; if(0 != n) Alloc::deallocate(p, n*sizeof (T)); &#125; static void deallocat(T* p)&#123; Alloc::deallocate(p, sizeof (T)); &#125;&#125;; 内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。 图解如下： 第一级配置器和第二级配置器： 包装接口和运用： 更新时间：2018.02.17 2.2.5 第一级配置器 __malloc_alloc_template 剖析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172template &lt;int inst&gt; //inst 没有用到class __malloc_alloc_template&#123;private: //处理内存不够的情况 //oom: out of memory static void *oom_malloc(size_t); static void *oom_realloc(void*, size_t); static void (* __malloc_alloc_oom_handler)();public: //直接调用malloc，free，realloc，只是多了一层封装，使之可以处理内存不够的情况 static void* allocate(size_t n)&#123; void *result = malloc(n); if(0 == result) result = oom_malloc(n); &#125; static void deallocate(void* p, size_t)&#123; free(p); &#125; static void* reallocate(void* p, size_t, size_t new_sz)&#123; void* result = realloc(p, new_sz); if(0 = result) result = oom_realloc(p, new_sz); return result; &#125; //仿真c++的set_new_handdler() static void(* set_malloc_handler(void(*f)()))()&#123; //被调用的函数__malloc_alloc_oom_handler void(* old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = f; return (old); &#125; //__malloc_alloc_oom_handler函数初始值是0，该值由客端自己设定 template &lt;int inst&gt; void (* __malloc_alloc_template&lt;inst&gt; :: __malloc_alloc_oom_handler)() = 0; //oom_malloc template &lt;int inst&gt; void* __malloc_alloc_template&lt;inst&gt; :: oom_malloc(size_t n)&#123; void (* my_malloc_handler)(); void* result; for(; ;)&#123; //不停的尝试，释放，配置，释放，配置…… my_malloc_handler = __malloc_alloc_oom_handler; //如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常 if(0 == my_malloc_handler)&#123; __THROW_BAD_ALLOC; &#125; (*my_malloc_handler)(); //调用处理例程，企图释放内存 result = malloc(n); //再次配置 if(result) return (result); &#125; &#125; //oom_realloc template &lt;int inst&gt; void* __malloc_alloc_template&lt;inst&gt; :: oom_realloc(void* p, size_t n)&#123; void (* my_malloc_handler)(); void* result; for(; ;)&#123; //不停的尝试，释放，配置，释放，配置…… my_malloc_handler = __malloc_alloc_oom_handler; //如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常 if(0 == my_malloc_handler)&#123; __THROW_BAD_ALLOC; &#125; (*my_malloc_handler)(); //调用处理例程，企图释放内存 result = malloc(n); //再次配置 if(result) return (result); &#125; &#125;&#125; 第一级配置器以malloc()、free()、realloc()等C函数执行实际的内存的配置、释放、重配置操作，同时实现出类似C++ new-handler的机制。所谓new-handler就是在系统内存配置需求无法被满足的情况下，调用一个指定的函数。 2.2.6 第二级配置器__default_alloc_template 剖析第二级配置器__default_alloc_template多了些机制，避免太多小额区块造成内存的碎片。 当区块超过128bytes，则用内存池管理，此做法又称为次层配置(sub-allocation)：每次配置一大块内存，并维护对应自由链表(free-lists)。下次如果再有相同大小的内存需求，就直接从free-lists中取出。如果客端释放返还小额区块，就有配置器会受到free-lists中。二级配置器会自动将内存调整为8的倍数，并维护16个free-lists，各自管理8的倍数的小额区块。12345//free-list的节点union obj&#123; union obj *free_list_link; char client_data[1];&#125; 其中，obj是一个obj指针，指向下一个相同大小的区块。同时obj是一个指针，指向实际中区块。结合2.2.7的图理解。如图： 2.2.7 空间配置函数allocate()allocate()是二级配置器__default_alloc_template的一个标准接口函数。这个函数首先判断区块大小，大于128bytes调用的第一级配置器，小于128bytes的查询对应free-list有可以用的区块，就直接拿来用，如果没有，就将区块大小调至8倍数边界，然后调用refill()，为free list重新填充空间。123456789101112131415161718192021//n &gt; 0static void* allocate(size_t n)&#123; //二级指针，但是volatile的用法不详 obj* volatile *my_free_list; obj* result; if(n&gt;(size_t) __MAX_BYTES)&#123; return (malloc_alloc::allocate(n)); &#125; //寻找16个free list中适合的一个 my_free_list = free_list + FREELIST_INDEX(n); result = *my_free_list; if(result == 0)&#123; //准备填充free list void* r = refill(ROUND_UP(n)); return r; &#125; //调整free list *my_free_list = result -&gt; free_list_link; return (result);&#125; 图解如下： 2.2.8 空间释放函数 deallocate()deallocate()是配置器__default_alloc_template的一个标准接口函数。大于128bytes调用第一级配置器，小于128bytes找到对应的free list将区块回收。12345678910111213141516// p不可以是 0static void deallocate(void *p, size_t n)&#123; obj* q = (obj* )p; //二级指针，但是volatile的用法不详 obj* volatile *my_free_list; if(n&gt;(size_t) __MAX_BYTES)&#123; malloc_alloc::deallocate(p, n); return; &#125; //寻找对应的free list my_free_list = free_list + FREELIST_INDEX(n); //调整free list，回收区域 q-&gt;free_list_link = *my_free_list(); *my_free_list = q;&#125; 图解如下： 2.2.9 重新填充 free listsallocate()中，当它发现free list中没有可用区块的时候，调用refill()，为free list重新填充空间。新的空间将取自内存池(chunk_alloc()完成)。缺省获得20个新节点。12345678910111213141516171819202122232425262728293031323334//返回一个大小为n的对象，并且有时候会为适当的free list增加节点//假设n已经适当上调至8的倍数template &lt;bool threads, int inst&gt;void* __default_alloc_template&lt;threads, inst&gt; :: refill(size_t n)&#123; int nobjs = 20; //缺省值 //调用chunk_alloc()，尝试获得nobjs个区块作为free list的新节点 char* chunk = chunk_alloc(n, nobjs); obj* volatile* my_free_list; obj* result; obj* current_obj, *next_obj; int i; //如果只获得一个区块，这个区块就分配给调用者使用，free list无新节点 if(1 == nobjs) return (chunk); //否则调整free list纳入新的节点 my_free_list = free_list + FREELIST_INDEX(n)； //以下在chunk空间创建free list result = (obj *)chumk; //以下导引free list 指向新配置的空间(取自内存池) *my_free_list = next_obj = (obj*)(chunk + n); //以下将free list 的各个节点串联起来 for(i = 1; ; i++)&#123; //从n == 1开始，因为0号要返回给客端 current_obj = next_obj; next_obj = (obj*)((char *)next_obj + n); if(nobjs - 1 == i)&#123; current_obj -&gt; free_list_link = 0; break; &#125; else&#123; current_obj-&gt;free_list_link = next_obj; &#125; &#125; return (result);&#125; 内存池暂时先按下…… 2.2.10 内存池(memory pool)2.3 内存基本处理工具STL定义了五个全局函数，作用于未初始化化空间上：用于构造的construct()和析构的destroy(),另外三个是：uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()(定于于&lt;memory&gt;),分别对应于高层次函数copy(),fill(),fill_n(),这些都是STL的算法。 2.3.1 uninitialized_copy2.3.2 uninitialized_fill2.3.3 uninitialized_fill_n]]></content>
      <categories>
        <category>learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[复杂单链表的复制]]></title>
    <url>%2F%E5%A4%8D%E6%9D%82%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.html</url>
    <content type="text"><![CDATA[题目:有一个单链表，该链表节点有两个指针，一个_next指向下一个节点，另一个_random指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。 思路： 单链表的复制比较简单，但是_random不好处理，如果_random指向前面的节点，我们该如何处理。_random还有可能是指向NULL，这种情况也需要单独处理。 为了解决这个问题，我们可以用一个比较巧妙的方法，对每一个节点都复制，同时插入到当前节点的后面。这样我们就得到了一个重复的链表，此时有一个优势，新_random就是原来_random的后一个。我们就不需要在考虑往前寻找的问题了。只需要找到当前节点的_random的_next就行。 这样处理之后，我们就得到了一个新的链表，接着只需要进行拆分就好了。 看图如下：创建了一个复杂链表 进行对每一个节点的复制同时插入到原链表中 给出节点的结构如下：123456789101112#define datatype inttypedef struct complexnode&#123; complexnode(datatype val)&#123; _data = val; _next = NULL; _random = NULL; &#125; datatype _data; complexnode* _next; complexnode* _random;&#125;comnode; 实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//主函数comnode* copy_complex_list( comnode* head )&#123; comnode* cur = head; comnode* next = cur-&gt;_next; if( cur == NULL ) return NULL; //将每一个节点复制到当前节点的后面，并链入链表 while( cur )&#123; comnode* tmp = new comnode(cur-&gt;_data); cur-&gt;_next = tmp; tmp-&gt;_next = next; cur = next; //防止对NULL访问 if( cur ) next = cur-&gt;_next; &#125; //将指针重置指向头结点 cur = head; next = cur-&gt;_next; //给新链入的节点置random while( cur )&#123; //分类处理_random为NULL的情况 if( cur-&gt;_random ) next-&gt;_random = cur-&gt;_random-&gt;_next; else next-&gt;_random = NULL; cur = next-&gt;_next; if( cur ) next = cur-&gt;_next; &#125; cur = head; next = cur-&gt;_next; comnode* result = next; //拆分两个链表 while( cur )&#123; cur-&gt;_next = next-&gt;_next; cur = cur-&gt;_next; if( cur )&#123; next-&gt;_next = cur-&gt;_next; next = next-&gt;_next; &#125; &#125; return result;&#125;//打印函数void print_random( comnode* head )&#123; comnode* cur = head; cout &lt;&lt; "list:"; while( cur )&#123; cout &lt;&lt; cur-&gt;_data &lt;&lt; "-&gt;"; cur = cur-&gt;_next; &#125; cout &lt;&lt; "NULL" &lt;&lt; endl &lt;&lt; "random:"; cur = head; while( cur )&#123; if( cur-&gt;_random ) cout &lt;&lt; cur-&gt;_random-&gt;_data &lt;&lt; " "; else cout &lt;&lt; "NULL" &lt;&lt; " "; cur = cur-&gt;_next; &#125; cout &lt;&lt; endl;&#125;int main()&#123; comnode* head = new comnode(1); comnode* n1 = new comnode(2); comnode* n2 = new comnode(4); comnode* n3 = new comnode(5); comnode* n4 = new comnode(9); head-&gt;_next = n1; n1-&gt;_next = n2; n2-&gt;_next = n3; n3-&gt;_next = n4; n4-&gt;_next = NULL; head-&gt;_random = n2; n1-&gt;_random = head; n2-&gt;_random = n3; n3-&gt;_random = NULL; n4-&gt;_random = n4; system( "clear" ); comnode* copy_list = copy_complex_list( head ); print_random(head); cout &lt;&lt; "copy_list:" &lt;&lt; endl; print_random(copy_list); return 0;&#125; 运行结果如下：同时打印了原来的链表和复制的链表 CSDN上用C写的，同时也将各个部分功能进行了函数封装]]></content>
      <categories>
        <category>practice</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[static const integral data member在类中的初始化]]></title>
    <url>%2Fstatic-const-integral-data-member%E5%9C%A8%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
    <content type="text"><![CDATA[当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。该类的其它对象对这个静态变量也是可以进行修改的。1234567891011121314151617//非常量静态成员变量初始化对比#include &lt;iostream&gt;using namespace std;class person&#123; public: static int num; //static int num = 11;&#125;;int person::num = 10;int main()&#123; person bob; system("clear"); cout &lt;&lt; bob.num &lt;&lt; endl; return 0;&#125; 在类内初始化非常量静态成员变量失败在类外初始化静态成员变量成功123//定义另外一个对象timmyperson timmy;cout &lt;&lt; "timmy:" &lt;&lt; timmy.num&lt;&lt; endl; 同一个类的不同对象共用一个静态成员变量 但是，常量的静态成员变量可以在类里面定义。12345678910111213141516#include &lt;iostream&gt;using namespace std;class person&#123; public: static const int num = 11; const static int age = 23;&#125;;int main()&#123; system("clear"); person tom; cout &lt;&lt; "tom:" &lt;&lt; tom.num &lt;&lt; endl; cout &lt;&lt; "tom:" &lt;&lt; tom.age &lt;&lt; endl; return 0;&#125; static const和const static一样的。 可是只有integral data member才可以，像 int，long，char才行。double，float等都不行12345678910111213#include &lt;iostream&gt;using namespace std;class person&#123; public: static const double num = 2.2;&#125;;int main()&#123; system("clear"); person tom; cout &lt;&lt; "tom:" &lt;&lt; tom.num &lt;&lt; endl; return 0;&#125; 用 static const double 初始化失败]]></content>
      <categories>
        <category>knowledge</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[创建一个不能被继承的类]]></title>
    <url>%2F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB.html</url>
    <content type="text"><![CDATA[题目：题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。 思路： 题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。那么我们只要将构造函数或析构函数定义为私有成员函数就好了。 第二个要求，能够正常使用，这样显然之前的方式是行不通的。构造函数为私有了，就无法创建对象了。那我再给他加一个友元函数，这样对象也可以创建了。 可是题目的要求是正常使用这个类，显然通过一个友元函数是不符合我们正常使用类的方式。 这个时候，正真正确的思路就出来了。我们借用一个中间类。例如：我们不能被继承的类是man，我们创建一个 私有构造函数的父类person，同时将 man定义为person的友元类。这样man就可以正常访问person的私有构造函数了。接着我们让 man虚继承person，到这里我们就完成了这个题目。 让man虚继承person是为了让继承man的类，都需要在man的父类，即person中调用构造函数，但只有man是person的友元类，其他的类都不能访问person的构造函数。因此man就成为了不能被继承的类，而man本身可以正常使用。 代码如下：123456789101112131415161718192021222324252627282930313233343536include &lt;iostream&gt;using namespace std;//设计一个不能被继承的类class person&#123; public: friend class man; private: //构造函数为private person()&#123;&#125;&#125;;//man虚拟继承personclass man:virtual public person &#123; public: man()&#123; age = 18; &#125; void show()&#123; cout &lt;&lt; age &lt;&lt; endl; &#125; private: int age;&#125;;// class son:public man&#123;// public:// son()&#123;&#125;// &#125;;int main()&#123; man bob; system( "clear" ); bob.show(); //son tom; return 0;&#125; 不定义man的继承类son，正常输出man的age = 18 定义man的继承类son失败]]></content>
      <categories>
        <category>practice</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[位运算实现Add]]></title>
    <url>%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0Add.html</url>
    <content type="text"><![CDATA[题目：实现一个Add函数，让两个整数相加，不能够使用+-*/、++、-- 思路： 正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，15+5=20先将位进行相加，不进行进位，得到10，再将进位加上，个位没有进位，十位进1，得到20。 题目要求不能使用+-*/，所以想到了位运算。15的二进制是1111，5的二进制是0101。根据上面的思路，我们先进行不进位相加，得到1010。(这个运算方式正好对应^)然后将进位加上(只求进位的运算正好对应&amp;再左移一位)，例子中只有第四位、第二位数值有进位值。得到10100，这个值就是20。 代码如下123456789101112131415161718192021222324//1、递归实现，每次将不进位相加的值赋给a，将计算出来的进位值赋给b，递归进行两者的分步相加，直到进位值`b=0`，返回a。long long Add( int a, int b )&#123; if( b == 0 ) return a; int sum = a^b; b = (a&amp;b)&lt;&lt;1; a = sum; return Add( a, b );&#125;int main()&#123; system( "clear" ); cout &lt;&lt; Add(3, 7) &lt;&lt; endl; //2、同时可以用迭代实现(非函数)，思路一样，进位值b最后肯定会等于0，因为总有进位结束的时候。 int a = 49; int b = 4; while( b != 0 )&#123; int sum = a^b; b = (a&amp;b)&lt;&lt;1; a = sum; &#125; cout &lt;&lt; a &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>practice</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1+2+……+n的特殊求法]]></title>
    <url>%2F1-%E2%80%A6%E2%80%A6-n%E7%9A%84%E7%89%B9%E6%AE%8A%E6%B1%82%E6%B3%95.html</url>
    <content type="text"><![CDATA[题目：求1+2+3+…+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。 自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&amp;&amp;的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。 更新：18.1.28发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了柔性数组，这种数组的长度的可变的，不需要用常量定义。 123456789101112class Solution&#123; public: int Sum_Solution( int n )&#123; bool a[n][n+1]; return sizeof(a)&gt;&gt;1; &#125;&#125;;int main()&#123; Solution s; cout &lt;&lt; s.Sum_Solution(10) &lt;&lt; endl; return 0;&#125; 原文： 利用&amp;&amp;操作符，|| 也一样的做法。思路：当result = 0 的时候，&amp;&amp;不再判断右操作数，递归停止。 123456789int sum( int n )&#123; int result = n; result &amp;&amp; (result += sum(n-1)); return result;&#125;int main()&#123; cout &lt;&lt; sum(100) &lt;&lt; endl; return 0;&#125; 利用构造函数以及静态成员变量思路：构造N次对象，每次对静态变量sum++，对n赋值。利用静态变量对所有同类对象有效的特点。 1234567891011121314151617181920212223242526272829303132333435class tmp&#123;public: //构造 tmp( )&#123; ++n; sum += n; &#125; //初始化 void static init()&#123; n = 0; sum = 0; &#125; //获得sum int static getsum()&#123; return sum; &#125;private: static int n; static int sum;&#125;;int tmp::n = 0;int tmp::sum = 0;//运行的函数int count(int n)&#123; tmp::init(); tmp* a = new tmp[n]; delete[] a; a = NULL; tmp::getsum();&#125;int main()&#123; cout &lt;&lt; count(100) &lt;&lt; endl; return 0;&#125; 利用虚函数、继承和函数指针思路： 定义两个类，A是基类，B是子类。 定义一个A* Array[2],其中Array[0]存放A对象的地址，Array[1]存放B对象的地址。 调用函数Sum中调用Sum的递归。同时对变量n两次取反Array[!!n]-&gt;Sum(n-1)+n,这样当n不为0的时候，得到bool值1。Array[!!n] = Array[1] 当n=0调用基类A的sum。充分利用虚函数参数与类型有关的性质。 12345678910111213141516171819202122232425262728293031323334353637383940414243//1、虚函数#include &lt;iostream&gt;using namespace std;class A;A* Array[2];class A&#123;public: virtual int Sum( int n )&#123; return 0; &#125;&#125;;class B:public A&#123;public: virtual int Sum( int n )&#123; //当 n != 0, !!n = 1 return Array[!!n]-&gt;Sum(n-1)+n; &#125;&#125;;int Sum2( int n )&#123; A a; B b; Array[0] = &amp;a; Array[1] = &amp;b; //调用虚函数 int value = Array[1]-&gt;Sum(n); return value;&#125;int main()&#123; cout &lt;&lt; Sum2(100) &lt;&lt; endl; return 0;&#125;//2、同上，这里利用函数指针来实现。typedef int (*fun)(int);int Sum( int i )&#123; return 0;&#125;int Sum2( int i )&#123; fun f[2] = &#123; Sum, Sum2 &#125;; return i + f[!!n](i-1);&#125; 利用异常处理的机制思路：try接收到的异常会在catch中捕获。 1234567891011int sum(int n)&#123; try&#123; //n = 2 的时候，出现异常，程序流跳转到catch int[] array = new int[n-2]; return n+sum(n-1); &#125; catch(Exception e)&#123; //返回1到上一个递归处，n = 2处。 return 1; &#125;&#125; 利用模板思路：利用了模板的特化作为递归结束的条件，并借用枚举类型。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;template &lt;unsigned N&gt;class Sum&#123; public: enum&#123; sum = N+Sum&lt;N-1&gt;::sum &#125;;&#125;;//模板特化，当N=1 的时候，调用template&lt;&gt;class Sum&lt;1&gt;&#123; public: enum&#123; sum = 1 &#125;;&#125;;int main()&#123; cout &lt;&lt; Sum&lt;100&gt;::sum &lt;&lt; endl; return 0;&#125; 方法来源地址]]></content>
      <categories>
        <category>practice</category>
        <category>C/C++</category>
      </categories>
  </entry>
</search>
