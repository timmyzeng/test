<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅读《STL源码剖析》笔记 1]]></title>
    <url>%2F2018%2F02%2F03%2F%E6%B5%85%E8%AF%BB%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[1 STL概论与版本简介1.2 STL六大组件 容器(containers):vector,list,deque,set,map,用来存放数据 算法(algorithms):sort,search,copy,erase 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，迭代器器将operator*,operator++,operator--,operator-&gt;等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。 仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。 配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。 配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。 1.5~1.8 STL版本之二 P.J.Plauger (Microsoft Visual C++) SGI STL (Linux GCC) C++标准规范下的C头文件: cstdio,cstdlib,cstring C++标准程序库中不属于STL范畴: stream,string STL标准头文件: vector,deque,list,map,algorithm,functional C++Standard定案前，HP所规范的STL头文件: vector.h,deque.h,list.h,algo.h,function.h SGI STL内部文件(STL真正实现于此): stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h 1.9 可能令你困惑的C++语法1.9.2 临时对象的产生与运用临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。STL中最常将此技巧用在仿函数(functor)中。临时对象的生命周期只有这一行指令。 1.9.3 静态常量整数成员在class内部直接初始化class内含有const static integral data member，我们可以直接给予初值。123456789101112131415//1.9.3测试代码如下template &lt;typename T&gt;class testclass&#123;public: static const int datai = 5; static const long datal = 3L; static const char datac = 'c';&#125;;int main()&#123; cout &lt;&lt; testclass&lt;int&gt;::datai &lt;&lt; endl; cout &lt;&lt; testclass&lt;int&gt;::datal &lt;&lt; endl; cout &lt;&lt; testclass&lt;int&gt;::datac &lt;&lt; endl; return 0;&#125; 运行结果： 1.9.5 前闭后开区间表示法[)STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。 1.9.6 function call操作符(operator())function call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。如果你针对某个class进行operator()重载，它就成为一个仿函数。1234567891011121314151617//1.9.6测试代码如下template &lt;class T&gt;struct Add&#123; //重载了operator() T operator()(const T&amp;x, const T&amp;y) const&#123; return x+y; &#125;&#125;;int main()&#123; Add&lt;int&gt; addxy; system( "clear" ); //调用重载函数 cout &lt;&lt; addxy(3,5) &lt;&lt; endl; //调用匿名对象 cout &lt;&lt; Add&lt;int&gt;()(5,5) &lt;&lt; endl; return 0;&#125; 运行结果： 2 空间配置器(allocator)空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。 2.2 具备此配置力的SGI空间配置器2.2.1 SGI标准的空间配置器,std::allocatorSGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：vector&lt;int,std::allocator&lt;int&gt;&gt;;SGI STL写法如下：vector&lt;int, std::aloc&gt;绝大多数情况下，我们都是使用缺省的空间配置器。 2.2.2 SGI特殊的空间配置器，std::alloc SGI同时也配备了标准空间配置器std::allocator，但是这只是对C++的operator new和operator delete做了一层封装，效率低下，SGI并不使用，只是为了向前兼容语法。 SGI自身使用的空间配置器是std::alloc一般来说，我们习惯的C++内存操作和释放操作是这样的： 123class Foo&#123;&#125;;Foo* pf = new Foo;delete pf; 这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。 STL的配置器(allocator)定于于&lt;memory&gt;，其中包含两个文件,一个是负责内存空间的配置与释放,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构，定义了全局函数construct()和destroy()。 2.2.3 构造和析构基本工具:construct()和destroy() construct()的实现如下： 12345#include &lt;new.h&gt; //使用placement new 需要这个头文件template &lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value)&#123; new (p) T1(value); //使用了placement new;调用T1:T1(value);&#125; 代码解释：construct()接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，通过placement new实现。 destroy()有两个版本，实现如下: 123456789101112131415161718192021222324252627282930//第一个版本，接受一个指针template &lt;class T&gt;inline void destroy(T* pointer)&#123; pointer-&gt;~T();&#125;//第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits&lt;&gt;求取最适当的措施。template &lt;class ForwardIterator&gt;inline void destroy(ForwardIterator first, ForwardIterator last)&#123; __destroy(first, last, value_type(first));&#125;//判断元素的数值型别(value type)是否有 trivial destructortemplate &lt;class ForwardIterator, class T&gt;inline void __destroy(ForwardIterator first, ForwardIterator last, T*)&#123; typedef typename __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor; __destroy_aux(first, last, trivial_destructor());&#125;//如果元素的数值型别(value type)有non-truvial destructor，循环释放template &lt;class ForwardIterator&gt;inline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type)&#123; for( ; first &lt; last; ++first) //调用第一个版本的destroy() destroy(&amp;* first);&#125;//如果元素的数值型别(value type)有trivial destructor,函数什么也不做template &lt;class ForwardIterator, ForwardIterator, __true_type&gt;&#123; inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type)&#123;&#125;&#125;//destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做inline void desroy(char*, char*)&#123;&#125;inline void destroy(wchar_t*,wchar_t*)&#123;&#125; 代码解释：destroy()有两个版本，第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可。第二个版本接收first和last两个迭代器，准备将[firat, last)范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓trivial destructor),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，这里首先利用value_type()获得迭代器所指对象的型别，再利用__type_traits&lt;T&gt;判断该型别的析构函数是否无关痛痒。若是(__true_type)，则什么都不做结束；若不是(__false_type),这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的destroy()。 construct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits&lt;&gt;在3.7节。 2.2.4 空间的配置与释放，std::alloc 对象构造前的空间配置和对象析构后的空间释放，由&lt;stl_alloc.h&gt;负责。 向 system heap 要求空间 考虑多线程(multi-threads)状态(这里不考虑多线程的情况) 考虑内存不足时的应变措施 考虑过多“小型区域”可能造成的内存碎片(fragment)问题 C++内存配置的基本操作是::operator new()，内存释放的基本操作是::operator delete()。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。 为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，第一级配置器(__malloc_alloc_template)用malloc()和free()，第二级配置器(__default_alloc_template)看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池memory bool整理方式。其中具体是开放了第一级配置器还是两级配置器都开放了由USE_MEALLOC是否定义决定，定义了USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。 无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口simple_alloc，使其能够符合STL的接口规格。 1234567891011121314151617template &lt;class T,class Alloc&gt;class simple_alloc&#123;public: static T* allocate(size_t n)&#123; return 0 == n?0 : (T*) Alloc::allocate(n* sizeof (T)); &#125; static T* allocate(void)&#123; return (T*) Alloc::allocatte(sizeof (T)); &#125; static void dallocate(T* p, size_t n)&#123; if(0 != n) Alloc::deallocate(p, n*sizeof (T)); &#125; static void deallocat(T* p)&#123; Alloc::deallocate(p, sizeof (T)); &#125;&#125;; 内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。 图解如下： 第一级配置器和第二级配置器： 包装接口和运用： 接下来几节，暂时先压住…… 2.2.5 第一级配置器 __malloc_alloc_template 剖析2.2.6 第二级配置器__default_alloc_template 剖析2.2.7 空间配置函数allocate()2.2.8 空间释放函数 deallocate()2.2.9 重新填充 free lists2.2.10 内存池(memory pool)2.3 内存基本处理工具STL定义了五个全局函数，作用于未初始化化空间上：用于构造的construct()和析构的destroy(),另外三个是：uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()(定于于&lt;memory&gt;),分别对应于高层次函数copy(),fill(),fill_n(),这些都是STL的算法。 2.3.1 uninitialized_copy2.3.2 uninitialized_fill2.3.3 uninitialized_fill_nhttp://music.163.com/song?id=30245576&amp;userid=285500825]]></content>
      <categories>
        <category>learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[复杂单链表的复制]]></title>
    <url>%2F2018%2F01%2F31%2F%E5%A4%8D%E6%9D%82%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目:有一个单链表，该链表节点有两个指针，一个_next指向下一个节点，另一个_random指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。 思路： 单链表的复制比较简单，但是_random不好处理，如果_random指向前面的节点，我们该如何处理。_random还有可能是指向NULL，这种情况也需要单独处理。 为了解决这个问题，我们可以用一个比较巧妙的方法，对每一个节点都复制，同时插入到当前节点的后面。这样我们就得到了一个重复的链表，此时有一个优势，新_random就是原来_random的后一个。我们就不需要在考虑往前寻找的问题了。只需要找到当前节点的_random的_next就行。 这样处理之后，我们就得到了一个新的链表，接着只需要进行拆分就好了。 看图如下：创建了一个复杂链表 进行对每一个节点的复制同时插入到原链表中 给出节点的结构如下：123456789101112#define datatype inttypedef struct complexnode&#123; complexnode(datatype val)&#123; _data = val; _next = NULL; _random = NULL; &#125; datatype _data; complexnode* _next; complexnode* _random;&#125;comnode; 实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//主函数comnode* copy_complex_list( comnode* head )&#123; comnode* cur = head; comnode* next = cur-&gt;_next; if( cur == NULL ) return NULL; //将每一个节点复制到当前节点的后面，并链入链表 while( cur )&#123; comnode* tmp = new comnode(cur-&gt;_data); cur-&gt;_next = tmp; tmp-&gt;_next = next; cur = next; //防止对NULL访问 if( cur ) next = cur-&gt;_next; &#125; //将指针重置指向头结点 cur = head; next = cur-&gt;_next; //给新链入的节点置random while( cur )&#123; //分类处理_random为NULL的情况 if( cur-&gt;_random ) next-&gt;_random = cur-&gt;_random-&gt;_next; else next-&gt;_random = NULL; cur = next-&gt;_next; if( cur ) next = cur-&gt;_next; &#125; cur = head; next = cur-&gt;_next; comnode* result = next; //拆分两个链表 while( cur )&#123; cur-&gt;_next = next-&gt;_next; cur = cur-&gt;_next; if( cur )&#123; next-&gt;_next = cur-&gt;_next; next = next-&gt;_next; &#125; &#125; return result;&#125;//打印函数void print_random( comnode* head )&#123; comnode* cur = head; cout &lt;&lt; "list:"; while( cur )&#123; cout &lt;&lt; cur-&gt;_data &lt;&lt; "-&gt;"; cur = cur-&gt;_next; &#125; cout &lt;&lt; "NULL" &lt;&lt; endl &lt;&lt; "random:"; cur = head; while( cur )&#123; if( cur-&gt;_random ) cout &lt;&lt; cur-&gt;_random-&gt;_data &lt;&lt; " "; else cout &lt;&lt; "NULL" &lt;&lt; " "; cur = cur-&gt;_next; &#125; cout &lt;&lt; endl;&#125;int main()&#123; comnode* head = new comnode(1); comnode* n1 = new comnode(2); comnode* n2 = new comnode(4); comnode* n3 = new comnode(5); comnode* n4 = new comnode(9); head-&gt;_next = n1; n1-&gt;_next = n2; n2-&gt;_next = n3; n3-&gt;_next = n4; n4-&gt;_next = NULL; head-&gt;_random = n2; n1-&gt;_random = head; n2-&gt;_random = n3; n3-&gt;_random = NULL; n4-&gt;_random = n4; system( "clear" ); comnode* copy_list = copy_complex_list( head ); print_random(head); cout &lt;&lt; "copy_list:" &lt;&lt; endl; print_random(copy_list); return 0;&#125; 运行结果如下：同时打印了原来的链表和复制的链表 CSDN上用C写的，同时也将各个部分功能进行了函数封装]]></content>
      <categories>
        <category>practice</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅读《More Effective C++》笔记]]></title>
    <url>%2F2018%2F01%2F30%2F%E6%B5%85%E8%AF%BB%E3%80%8AMore-Effective-C-%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基础议题条款1：区分指针和引用不存在空引用，引用必须要指向某个对象。当确定某个对象不允许有空值，就需要定义为引用，而不是指针。123//这种做法语法上没有错误，出现了引用为空的情况。但是不同的编译器会有不同的报错。不允许出现这样的代码。char* pc = 0;char &amp;rc = *pc; 因为不存在空引用这种情况，所以使引用会比指针更高效。12345678//引用不用判空void print_double(const double&amp; rd)&#123; cout &lt;&lt; rd;&#125;//指针要判空void print_double1(const double *pd)&#123; if(pd)&#123; cout &lt;&lt; *pd; &#125;&#125; 指针可以被重新赋值用以指向另外一个不同的对象，而引用则总是指向初始化时它指向的对象。12345678string s1("nancy");string s2("clancy");string&amp; rs = s1;string *ps = &amp;s1;//rs依然是s1的引用，此时rs = s1 = s2 = "clancy"rs = s2;//ps指向了s2,不再指向s1ps = &amp;s2; 实现某些操作符的时候，最常见的是[]操作符，绝大多数应该返回引用。12345vector&lt;int&gt; v(10);//一般情况下的返回值，此时是引用v[5] = 10;//如果返回的是指针就需要这样解引用，看起来v就像是一个指针vector一样。*v[5] = 10; 条款2：优先考虑C++风格的类型转换四个类型转换操作符：static_cast,const_cast,dynamic_cast,reinterpret_cast static_cast：作用类似于C中的隐式类型转换，只能转换相近类型的变量。比如struct到int的转换就不能实现。而且在C++中，static_cast并不能将const属性转换为非const属性。 const_cast：专门用来去除const属性和volatile属性。const_cast被用来用作其他的类型转换会被拒绝。 dynamic_cast：它是用来针对一个继承体系做向下或者横向的安全转换的。也就是说，用dynamic_cast把指向基类的指针或引用转换成指向派生类或者基类的兄弟类的指针或引用，同时可以知道是否成功。出现空指针(转换指针的时候)或者出现异常(转换引用的时候)意味着失败。他不能用于哪些没有虚函数的类型，也不能去除const属性。 reinterpret_const：这个操作符，转换结果往往是编译器定义的。因此它几乎是不可以移植的。最常见的用法是在函数指针之间进行类型转换。但是一般我们不使用这种转换，因为c++没有规定这种做法，有可能出现未知的错误，除非万不得已，不然不使用。 使用格式举例：static_cast&lt;double&gt; (first); const_cast&lt;special*&gt;(first); dynamic_cast&lt;special *&gt;(&amp;first); reinterpret_cast&lt;funcptr&gt; (&amp;dosomething); 条款3：绝不要把多态应用于数组继承的一大特性，它允许你通过指向基类的指针和引用来操纵派生类对象。这种指针和引用的行为具有多态性。同时C++也允许你通过基类指针和引用来操纵派生类数组，但是这个应该不被允许。见下面这个例子：123456789//一个BST类，有一个BalancedBST的类，它继承与BSTclass BST&#123;//...&#125;;class BalancedBST&#123;//...&#125;;//一个用于打印BST数组中BST元素的函数void printBSTArray(ostream&amp;s, const BST array[], int numElements)&#123; for( int i = 0; i &lt; numElements; ++i )&#123; s &lt;&lt; array[i]; &#125;&#125; 第一种情况，传递的数组是BST数组，程序没有问题；第二种情况，传递的数组是BalancedBST数组(继承于BST),编译器并不会报错，但是会出现问题，关键在于对array[i]的使用。array[i]=*(array+i)，我们知道array是指向数组的首地址的指针，其中array+i偏移的地址是根据元素的大小而定的。因为上例子中，array的类型是BST，所以array[i]的偏移是array+i*sizeof(SBT)。但我们传递了BST的子类BalancedBST给array，这样array的访问就会出现问题。 同时，如果打算通过一个基类指针删除一个包含派生类对象的数组，一样会出现问题。1234567void deleteArray(ostream&amp; logStream, BST array[])&#123; logStream &lt;&lt; static_cast&lt;void*&gt;(array) &lt;&lt; endl; delete[] array;&#125;BalancedBST *balTreeArray = new BalancedBST[50];//...deketeArray(cout, balTreeArray); 明面上这里并没有调用指针，]]></content>
      <categories>
        <category>learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[static const integral data member在类中的初始化]]></title>
    <url>%2F2018%2F01%2F30%2Fstatic-const-integral-data-member%E5%9C%A8%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。该类的其它对象对这个静态变量也是可以进行修改的。 1234567891011121314151617//非常量静态成员变量初始化对比#include &lt;iostream&gt;using namespace std;class person&#123; public: static int num; //static int num = 11;&#125;;int person::num = 10;int main()&#123; person bob; system("clear"); cout &lt;&lt; bob.num &lt;&lt; endl; return 0;&#125; 在类内初始化非常量静态成员变量失败 在类外初始化静态成员变量成功 123//定义另外一个对象timmyperson timmy;cout &lt;&lt; "timmy:" &lt;&lt; timmy.num&lt;&lt; endl; 同一个类的不同对象共用一个静态成员变量 但是，常量的静态成员变量可以在类里面定义。 12345678910111213141516#include &lt;iostream&gt;using namespace std;class person&#123; public: static const int num = 11; const static int age = 23;&#125;;int main()&#123; system("clear"); person tom; cout &lt;&lt; "tom:" &lt;&lt; tom.num &lt;&lt; endl; cout &lt;&lt; "tom:" &lt;&lt; tom.age &lt;&lt; endl; return 0;&#125; static const和const static一样的。 可是只有integral data member才可以，像 int，long，char才行。double，float等都不行 12345678910111213#include &lt;iostream&gt;using namespace std;class person&#123; public: static const double num = 2.2;&#125;;int main()&#123; system("clear"); person tom; cout &lt;&lt; "tom:" &lt;&lt; tom.num &lt;&lt; endl; return 0;&#125; 用 static const double 初始化失败]]></content>
      <categories>
        <category>knowledge</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[创建一个不能被继承的类]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[题目：题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。 思路： 题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。那么我们只要将构造函数或析构函数定义为私有成员函数就好了。 第二个要求，能够正常使用，这样显然之前的方式是行不通的。构造函数为私有了，就无法创建对象了。那我再给他加一个友元函数，这样对象也可以创建了。 可是题目的要求是正常使用这个类，显然通过一个友元函数是不符合我们正常使用类的方式。 这个时候，正真正确的思路就出来了。我们借用一个中间类。例如：我们不能被继承的类是man，我们创建一个 私有构造函数的父类person，同时将 man定义为person的友元类。这样man就可以正常访问person的私有构造函数了。接着我们让 man虚继承person，到这里我们就完成了这个题目。 让man虚继承person是为了让继承man的类，都需要在man的父类，即person中调用构造函数，但只有man是person的友元类，其他的类都不能访问person的构造函数。因此man就成为了不能被继承的类，而man本身可以正常使用。 代码如下：123456789101112131415161718192021222324252627282930313233343536include &lt;iostream&gt;using namespace std;//设计一个不能被继承的类class person&#123; public: friend class man; private: //构造函数为private person()&#123;&#125;&#125;;//man虚拟继承personclass man:virtual public person &#123; public: man()&#123; age = 18; &#125; void show()&#123; cout &lt;&lt; age &lt;&lt; endl; &#125; private: int age;&#125;;// class son:public man&#123;// public:// son()&#123;&#125;// &#125;;int main()&#123; man bob; system( "clear" ); bob.show(); //son tom; return 0;&#125; 不定义man的继承类son，正常输出man的age = 18 定义man的继承类son失败]]></content>
      <categories>
        <category>practice</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[位运算实现Add]]></title>
    <url>%2F2018%2F01%2F28%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0Add%2F</url>
    <content type="text"><![CDATA[题目：实现一个Add函数，让两个整数相加，不能够使用+-*/、++、-- 思路： 正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，15+5=20先将位进行相加，不进行进位，得到10，再将进位加上，个位没有进位，十位进1，得到20。 题目要求不能使用+-*/，所以想到了位运算。15的二进制是1111，5的二进制是0101。根据上面的思路，我们先进行不进位相加，得到1010。(这个运算方式正好对应^)然后将进位加上(只求进位的运算正好对应&amp;再左移一位)，例子中只有第四位、第二位数值有进位值。得到10100，这个值就是20。 代码如下123456789101112131415161718192021222324//1、递归实现，每次将不进位相加的值赋给a，将计算出来的进位值赋给b，递归进行两者的分步相加，直到进位值`b=0`，返回a。long long Add( int a, int b )&#123; if( b == 0 ) return a; int sum = a^b; b = (a&amp;b)&lt;&lt;1; a = sum; return Add( a, b );&#125;int main()&#123; system( "clear" ); cout &lt;&lt; Add(3, 7) &lt;&lt; endl; //2、同时可以用迭代实现(非函数)，思路一样，进位值b最后肯定会等于0，因为总有进位结束的时候。 int a = 49; int b = 4; while( b != 0 )&#123; int sum = a^b; b = (a&amp;b)&lt;&lt;1; a = sum; &#125; cout &lt;&lt; a &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>practice</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1+2+……+n的特殊求法]]></title>
    <url>%2F2018%2F01%2F27%2F1-%E2%80%A6%E2%80%A6-n%E7%9A%84%E7%89%B9%E6%AE%8A%E6%B1%82%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目：求1+2+3+…+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。 自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&amp;&amp;的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。 更新：18.1.28发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了柔性数组，这种数组的长度的可变的，不需要用常量定义。 123456789101112class Solution&#123; public: int Sum_Solution( int n )&#123; bool a[n][n+1]; return sizeof(a)&gt;&gt;1; &#125;&#125;;int main()&#123; Solution s; cout &lt;&lt; s.Sum_Solution(10) &lt;&lt; endl; return 0;&#125; 原文： 利用&amp;&amp;操作符，|| 也一样的做法。思路：当result = 0 的时候，&amp;&amp;不再判断右操作数，递归停止。 123456789int sum( int n )&#123; int result = n; result &amp;&amp; (result += sum(n-1)); return result;&#125;int main()&#123; cout &lt;&lt; sum(100) &lt;&lt; endl; return 0;&#125; 利用构造函数以及静态成员变量思路：构造N次对象，每次对静态变量sum++，对n赋值。利用静态变量对所有同类对象有效的特点。 1234567891011121314151617181920212223242526272829303132333435class tmp&#123;public: //构造 tmp( )&#123; ++n; sum += n; &#125; //初始化 void static init()&#123; n = 0; sum = 0; &#125; //获得sum int static getsum()&#123; return sum; &#125;private: static int n; static int sum;&#125;;int tmp::n = 0;int tmp::sum = 0;//运行的函数int count(int n)&#123; tmp::init(); tmp* a = new tmp[n]; delete[] a; a = NULL; tmp::getsum();&#125;int main()&#123; cout &lt;&lt; count(100) &lt;&lt; endl; return 0;&#125; 利用虚函数、继承和函数指针思路： 定义两个类，A是基类，B是子类。 定义一个A* Array[2],其中Array[0]存放A对象的地址，Array[1]存放B对象的地址。 调用函数Sum中调用Sum的递归。同时对变量n两次取反Array[!!n]-&gt;Sum(n-1)+n,这样当n不为0的时候，得到bool值1。Array[!!n] = Array[1] 当n=0调用基类A的sum。充分利用虚函数参数与类型有关的性质。 12345678910111213141516171819202122232425262728293031323334353637383940414243//1、虚函数#include &lt;iostream&gt;using namespace std;class A;A* Array[2];class A&#123;public: virtual int Sum( int n )&#123; return 0; &#125;&#125;;class B:public A&#123;public: virtual int Sum( int n )&#123; //当 n != 0, !!n = 1 return Array[!!n]-&gt;Sum(n-1)+n; &#125;&#125;;int Sum2( int n )&#123; A a; B b; Array[0] = &amp;a; Array[1] = &amp;b; //调用虚函数 int value = Array[1]-&gt;Sum(n); return value;&#125;int main()&#123; cout &lt;&lt; Sum2(100) &lt;&lt; endl; return 0;&#125;//2、同上，这里利用函数指针来实现。typedef int (*fun)(int);int Sum( int i )&#123; return 0;&#125;int Sum2( int i )&#123; fun f[2] = &#123; Sum, Sum2 &#125;; return i + f[!!n](i-1);&#125; 利用异常处理的机制思路：try接收到的异常会在catch中捕获。 1234567891011int sum(int n)&#123; try&#123; //n = 2 的时候，出现异常，程序流跳转到catch int[] array = new int[n-2]; return n+sum(n-1); &#125; catch(Exception e)&#123; //返回1到上一个递归处，n = 2处。 return 1; &#125;&#125; 利用模板思路：利用了模板的特化作为递归结束的条件，并借用枚举类型。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;template &lt;unsigned N&gt;class Sum&#123; public: enum&#123; sum = N+Sum&lt;N-1&gt;::sum &#125;;&#125;;//模板特化，当N=1 的时候，调用template&lt;&gt;class Sum&lt;1&gt;&#123; public: enum&#123; sum = 1 &#125;;&#125;;int main()&#123; cout &lt;&lt; Sum&lt;100&gt;::sum &lt;&lt; endl; return 0;&#125; 方法来源地址]]></content>
      <categories>
        <category>practice</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[收集]]></title>
    <url>%2F2018%2F01%2F25%2FLinux%E7%9B%B8%E5%85%B3%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[1、Linux命令相关1、Linux命令大全：http://man.linuxde.net/ 2、修改时间查看时间：https://www.cnblogs.com/jiu0821/p/5999566.html3、移动、重命名文件/目录：https://linux.cn/article-2688-1.html 4、查看系统版本：http://www.linuxidc.com/Linux/2015-07/119897.htm vim相关1、vim的配置：http://blog.csdn.net/footmart_c/article/details/51588524 2、多行删除复制：https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html 3、vim安装报错EXTERN.h：http://tieba.baidu.com/p/4471948063 4、vim升级8.0+YouCompleteMe补全插件：http://blog.csdn.net/nzyalj/article/details/75331822 5、vim8.0升级后添加到路径中：http://blog.csdn.net/u013388603/article/details/72780586 6、YouCompleteMe：http://blog.51cto.com/990487026/1905427 git相关1、git安装：https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html 2、git安装：http://blog.csdn.net/u013256816/article/details/54743470 3、git升级2.7.3：https://www.cnblogs.com/yexinw/p/6401663.html python相关1、2.6升级2.7：https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html 2、安装3.5.2并与python2共存：https://www.ywlib.com/archives/96-1.html 输入相关1、python造成 input method preferences无效：http://blog.csdn.net/jaket5219999/article/details/52912321 2、安装Fcitx 4.0.0：https://www.douban.com/note/319236531/ 3、设置Fcitx默认：https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html 4、ibus开启：http://blog.csdn.net/zitong_ccnu/article/details/40110583 源相关1、Nux Dextop源：http://www.linuxidc.com/Linux/2016-06/132101.htm 2、yum源解析（详细）：https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html Hexo相关gcc升级：http://www.cnblogs.com/lpbottle/p/install_gcc.html gcc升级：http://blog.csdn.net/furzoom/article/details/53322510 gcc升级：http://blog.csdn.net/zr1076311296/article/details/51334538 Nodejs安装：https://www.cnblogs.com/lpbottle/p/7733397.html 其它1、/mnt/hgfs没有共享文件夹：http://www.mamicode.com/info-detail-1655589.html 2、Linux就该这么学：http://www.linuxprobe.com/chapter-00.html 2、C语言1、链表相关笔试题：http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html 3、GitHub1、知乎：https://www.zhihu.com/question/20070065 2、他的网站里有：http://youngxhui.github.io/ 以下，搭建自己的github博客： 1）配置详细：https://www.jianshu.com/p/b7886271e21a 2）很强大的一个：http://kchen.cc/2016/11/12/hexo-instructions/ 3）WordPress和Hexo以及md编辑器：https://www.imooc.com/article/12257 4）localhost:4000出问题：http://blog.csdn.net/u012246342/article/details/51543370 5）Hexo问题总结：http://blog.csdn.net/wx_962464/article/details/44786929 4、blog1、http://www.zipperary.com/ 2、陈皓：https://coolshell.cn/featured 5、其它1、msdn：https://msdn.itellyou.cn/ 2、NTFS和FAT32区别：http://www.ntfsformac.cn/qita-nytqubie.html 3、SQL源码剖析：http://deepfuture.iteye.com/blog/718478]]></content>
      <categories>
        <category>网站收集</category>
      </categories>
  </entry>
</search>
