{"meta":{"title":"青匆","subtitle":"","description":"为即将来临的精彩。","author":"timmy","url":"http://jingxxn.cn"},"pages":[{"title":"categories","date":"2018-01-27T09:16:23.000Z","updated":"2018-01-27T11:01:04.502Z","comments":false,"path":"categories/index.html","permalink":"http://jingxxn.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"看这里，看这里","slug":"text","date":"2018-02-13T14:16:37.000Z","updated":"2018-02-13T18:00:18.059Z","comments":true,"path":"2018/02/13/text/","link":"","permalink":"http://jingxxn.cn/2018/02/13/text/","excerpt":"你的生日是密码啦，到底是几位，自己猜，猜不出来就不能怪我了","text":"你的生日是密码啦，到底是几位，自己猜，猜不出来就不能怪我了姐姐，今天是2018/2/14，我们的第一个西方情人节哦。很开心能够在这里分享小仙女和我的情人节。那么，咱们先欣赏一下小仙女的美姿啦~可爱的学姐，端庄的微笑~喜欢了啦就算是恶搞的相机效果，也不能打败学姐呢带上皇冠！！！简直不能太美哦姐姐，跟你相遇，真的好开心。常说月亮是夜晚的女神，温柔恰似一湖春水。姐姐就是我的月亮啊，我在堤岸望着湖中的仙女，你的身姿是这样的动人，你的一颦一簇都是那样的让我欢喜。都说在自己喜欢的人面前，才会袒露心声。我很开心、很欣喜、很愿意做姐姐的守护呢。正所谓“一颦一蹙可倾城,一嗔一笑亦销魂”。我爱你，姐姐。我要大声的告诉你，我爱你，爱你嘟嘴卖萌的时候，可爱诱人的样子；心疼你生气的时候，还要自己闷着的时候，还喜欢姐姐陪我做的最多的事：一起犯傻、逗乐啊hhhhhhh PS姐姐商量一下，以后不叫我傻逼聪聪了好不好，我就当姐姐答应了啦。muaaaaa~ 接下来，就是吃吃吃表演啦~~~ 还有！！卖萌啦，十块钱忍痛甩卖。诶？为什么是聪聪，hhhh那可不，聪聪肯定要出现在姐姐旁边啊 这里，是聪聪和学姐专区，就是我们了啦 姐姐哦，聪聪有的时候会挺傻的嘛，对不对。但是聪聪爱你的啦，我会加油哦。以后一定要和姐姐去美国种田啦。muaaaaaaaaaaaaaaa~ 最后的最后啦，情人节快乐！！！ 请猛击此处，用手机扫一扫功能哦","categories":[],"tags":[]},{"title":"浅读《STL源码剖析》笔记 4章-vector&&list","slug":"浅读《STL源码剖析》笔记-4章-vector&&list","date":"2018-02-09T02:13:57.000Z","updated":"2018-02-09T06:02:03.013Z","comments":true,"path":"2018/02/09/浅读《STL源码剖析》笔记-4章-vector&&list/","link":"","permalink":"http://jingxxn.cn/2018/02/09/浅读《STL源码剖析》笔记-4章-vector&&list/","excerpt":"4 序列式容器4.1 容器的概观与分类所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。","text":"4 序列式容器4.1 容器的概观与分类所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。 4.2 vector4.2.1 vector概述array是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。 4.2.3 vector的迭代器由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。vector&lt;int&gt; :: iterator ivite;vector&lt;Shape&gt; :: iterator svite;其中 ivite的类型就是int*，svite的类型就是Shape* 。 4.2.4 vector的数据结构vector的数据结构如下：123456789template&lt;class T, class Alloc = alloc&gt;class vecotr&#123; //... protected: //注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置 iterator start; //表示目前使用空间的头部 iterator finish; //表示目前使用空间的尾部 iterator end_of_storage; //表示目前可用空间的尾部&#125; 为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。 4.2.5 vector的构造与内存管理：constructor，push_backpush_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。push_back源代码节选如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void push_back( const T&amp; x)&#123; if( finish != end_of_storage )&#123; construct( finish, x ); ++finish; &#125; else //无备用空间 insert_aux(end(), x);&#125;template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux( iterator positon, const T&amp; x )&#123; if( finish != end_of_storage )&#123; //为什么还要再次判断 construct( finish, *(finish - 1)); ++finish; T x_copy = x; //不懂 copy_backward(position, finish - 2, finish - 1); *position = x_copy; &#125; else&#123; //无备用空间 const size_type old_size = size(); const size_type len = old_size != 0 ? 2*old_size : 1; iterator new_start = data_allocator::allocatr(len); //实际配置空间 iterator new_finish = new_start; try&#123; //将原来vector内容拷贝到新的vector new_finish = uninitialized_copy(start, position, new_start); //为新元素设定初值x construct(new_finish, x); ++new_finish; //将安插点的原内容也拷贝过来//不懂 new_finish = uninitialized_copy(posiition, finish, new_finish); &#125; catch(...)&#123; //开辟失败 destroy(new_start, new_finish); data_allocator::deallocate(new_start, len); throw; &#125; //析构并释放原vector destory(begin(), end()); deallocate(); //调整迭代器，指向新的vector start = new_start; finish = new_finish; end_of_storage = new_start+len; &#125;&#125; 4.2.6 vector的元素操作：pop_back, erase, clear, insert1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//清除[first, last)中的元素iterator erase(iterator first, iterator last)&#123; iterator ii = copy(last, finish, first); //copy是全局函数，第六章 destory(i, finish); finish = finish - (last - first); return first;&#125;//清除某个位置上的元素iterator erase(iterator position)&#123; if(position + 1 != end()) copy(position + 1, finish, position); --finish; destroy(finish); return position;&#125;void clear()&#123; erase(begin(), end()); &#125;//从position开始，插入n个元素，元素初值为xtemplate &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert(iterator position, size_type n ,const T&amp; x)&#123; if(n != 0)&#123; //备用空间大于等于新增元素个数 if(size_type(end_of_storage - finish) &gt;= 0)&#123; T x_copy = x; //计算插入点之后的现有元素个数 const size_type elems_after = finish - position; iterator old_finish = finish; if(elems_after &gt; n)&#123; //插入点之后的现有元素个数 &gt; 新增元素个数 uninitialized_copy(finish - n, finish, finish); finish += n; //将vector 尾端标记后移 copy_backward(position, old_finish - n, old_finish); fill(position, position+n, x_copy); //从插入点开始填入新值 &#125; else&#123; uninitialized_fill_n(finish, n-elems_affter, x_copy); finish += n - elems_after; uninitialized_copy(position, old_finish, finish); finish += elems_after; fill(position, old_finish, x_copy); &#125; &#125; else&#123; //备用空间 &lt; 新增元素个数 const size_type old_size = size(); //决定新的长度为旧长度+新增元素个数 const size_type len = old_size + max(old_size, n); //配置新的vector空间 iterator new_start = data_allocaator::allocate(len); iterator new_finish = new_start; __STL_TRY&#123; //&lt;-- 这个是什么 //将旧的vector在插入点之前的元素复制到新空间 new_finish = uninitialized_copy(start, position, new_start); //将新增元素(初值为x)填入新空间 new_finish = uninitialized_fill_n(new_finish, n, x); //将旧的vector在插入点之后的元素复制到新空间 nwe_finish = uninitialized_copy(position, finish, new_finish); &#125; //异常处理 //... //清除释放旧的空间 destroy(start，finish); deallocate(); //调整迭代器指向新的空间 start = new_start; finish = new_finish; end_of_storage = new_start+len; &#125; &#125;&#125;//插入操作完成之后，新增节点应位于position的后面。 图解如下： 4.3 list4.3.1 list概述list每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。 4.3.2 list的节点(node)list的节点和list本身的设计是分开的。以下是STL list的节点结构：12345678template &lt;class T&gt;struct __list_node&#123; typedef void* void_pointer; void_pointer prev; //型别为void*，其实可以是__list_node&lt;T&gt; void_pointer next; T data;&#125;//这是一个双向链表节点 4.3.3 list的迭代器list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效 4.3.4 list的数据结构SGI list 是一个双向循环链表。list结构如下：123456789template &lt;class T, class Alloc = alloc&gt;class list&#123;protected: typedef __list_node&lt;T&gt; list_node;public: typedef list_node* link_type;protected: link_type node;&#125; STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。12345678910iterator begin() &#123; return (link_type)((*node).next); &#125;iterator end() &#123; return node; &#125;bool empty() const &#123; return node-&gt;next == node; &#125;size_type size() const &#123; size_type result = 0; distance(begin(), end(), result); //全局函数，第三章//计算两个迭代器之间的距离 return result;&#125;reference front() &#123; return *begin(); &#125;reference back() &#123; return *(--end()); &#125; 图解如下： 4.3.5 list的构造与内存管理：constructor， push_back, insertlist缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。list_node_alloctor(n)表示配置n个节点空间。同时有四个函数，如下：12345678//配置一个节点并传回link_type get_node();//释放一个节点void put_node(link_type p);//配置并构造一个节点，带有元素值link_type create_node(const T&amp; x);//析构并释放一个节点void destroy_node(link_type p); list众多构造函数中，有一个允许我们构造一个空list出来：123456789public: list()&#123; empty_initialize(); &#125;protected: void empty_initialize()&#123; //next、prev指针都指向自己 node = get_node(); node-&gt;next = node; node-&gt;prev = node; &#125; 空节点对象模型：当我们用push_back()插入新节点的时候，函数内部调用insert()void push_back(const T&amp; x) { inset( end(), x ); }insert()有很多的重载函数，最简单的如下:12345678910//在迭代器position所指位置插入一个节点，值为xiterator insert(iterator position, const T&amp; x)&#123; link_type tmp = create_node(x); //插入位置在position之前,这是STL规范。 tmp-&gt;next = position.node; tmp-&gt;prev = position.node-&gt;prev; (link_type(position.node-&gt;node-&gt;prev))-&gt;next = tmp; position.node-&gt;prev = tmp; return tmp;&#125; 4.3.6 list的元素操作：push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sortpush_front, push_back复用insert；pop_front, pop_back复用erase。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//移除迭代器position所指节点iterator erase(iterator position)&#123; link_type next_node = link_type(position.node-&gt;next); link_type prev_node = link_type(position.node-&gt;prev); prev_node-&gt;next = next_node; next_node-&gt;prev = prev_node; destroy_node(position.node); return iterator(next_node);&#125;//清除所有节点template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::clear()&#123; link_type cur = (link__type) node-&gt;next; //begin(); while( cur != node )&#123; link_type tmp - cur; cur = (link_type)cur-&gt;next; destroy_node(tmp); &#125; //恢复成空节点的初始结构 node-&gt;next = node; node-&gt;prev = node;&#125;//将数值为value的所有元素移除template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::remove(const T&amp; value)&#123; iterator first = begin(); iterator last = end(); while(first != last)&#123; iterator next = first; ++next; if(*first == value) erase(first); first = next; &#125;&#125;//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个//很帅啊template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::unique()&#123; iterator first = begin(); iterator last = end(); if(first == last) return; //判空 iterator next = first; while(++next != last)&#123; if(*first == *next) erase(next); else first = next; next = first; &#125;&#125; list 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。12345678910111213141516protected: //将[first, last)内的所有元素移动到position之前。 void transfer(iterator position, iterator first, iterator last)&#123; if(position != last)&#123; //先处理各节点的next (*(link_type((*last.node).prev))).next = position.node; (*(link_type((*first.node).prev))).next = last.node; (*(link_type((*position.node).prev))).next = first.node; //tmp为position的prev节点 link_type tmp = link_type((*position.node).prev); //处理各节点的prev (*position.node).prev = (*last.node).prev; (*last.node).prev = (*first.node).prev; (*first.node).prev = tmp; &#125; &#125; splice各个版本：1234567891011121314151617181920public: //将list x接合与position所指位置之前，x必须不同于*this void splice(iterator position, list&amp; x)&#123; if(!x.empty()) transfer(position, x.begin(), x.end()); &#125; //将i 所指元素接合于position所指元素之前。position和i可指向同一个list void splice(iterator position, list&amp;, iterator i)&#123; iterator j = i; ++j; if(position == i || position == j) return; trasfer(position, i, j); &#125; //将[first, last)内的所有元素接合于position所指位置之前， //position和[first, last)可指向同一个list。 //但是position不能在[first, last)范围之内 void splice(iterator posiition, list&amp;, iterator first, iterator last)&#123; if(first != last) transfer(position, first, last); &#125; merge(), reverse(), sort()源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//merge()将x合并到*this上，两个list必须是递增排序的template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::merge(list&lt;T, Alloc&gt;&amp; x)&#123; iterator first1 = begin(); iterator last1 = end(); iterator first2 = x.begin(); iterator last2 = x.end(); while(first1 != last1 &amp;&amp; first2 != last2)&#123; if(*first2 &lt; *first1)&#123; iterator next = first2; transfer(first1, first2, ++next); first2 = next; &#125; else ++first1; if(first2 != last2) transfer(last1, first2,last2); &#125;&#125;//reverse()将*this的内容逆置template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::reverse()&#123; //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢 if(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; iterator first = begin(); ++first; while(first != end())&#123; iterator old = first; ++first; transfer(begin(), old, first); &#125;&#125;//list不能使用STL中的sort()算法，只能使用自己的sort()//因为STL的sort()只接受RamdonAccessIterator//本函数使用quick sorttemplate &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::sort()&#123; //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢 if(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; //创建新的list空间，作为中介数据存放区 list&lt;T, Alloc&gt; carry; list&lt;T, Alloc&gt; counter[64]; int fill = 0; while(!empty())&#123; carry.splice(carry.begin(), *this, begin()); int i = 0; while(i &lt; fill &amp;&amp; !counter[i].empty())&#123; counter[i].merge(carry); carry.swap(counter[i++]); &#125; carry.swap(counter[i]); if(i == fill) ++fill; &#125; for(int i = 1; i &lt; fill; ++i) counter[i].merge(counter[i-1]); swap(counter[fill-1]);&#125;","categories":[{"name":"learning","slug":"learning","permalink":"http://jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"浅读《STL源码剖析》笔记 3章","slug":"浅读《STL源码剖析》笔记-3章","date":"2018-02-08T09:07:30.000Z","updated":"2018-02-09T02:24:41.485Z","comments":true,"path":"2018/02/08/浅读《STL源码剖析》笔记-3章/","link":"","permalink":"http://jingxxn.cn/2018/02/08/浅读《STL源码剖析》笔记-3章/","excerpt":"3 迭代器(iterator)概念与traits编程技法迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式 3.1 迭代器设计思维STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一","text":"3 迭代器(iterator)概念与traits编程技法迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式 3.1 迭代器设计思维STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一 12345678910111213141516171819202122232425262728293031323334//3.1举例说明迭代器的使用//find()的定义。template &lt;class InputIterator, chass T&gt;InputIterator find( InputIterator first, InputIterator last, const T&amp; value )&#123; while ( first != last &amp;&amp; *first != value ) ++first; return first;&#125;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; const int arraySiza = 7; int ia[arraySiza] = &#123; 0, 1, 2, 3, 4, 5, 6 &#125;; vector&lt;int&gt; ivect(ia, ia+arraySiza); //调用vector的iterator用于find() vector&lt;int&gt;::iterator it1 = find(ivect.begin(), ivect.end(), 4); if( it1 == ivect.end() ) cout &lt;&lt; \"4 not found.\" &lt;&lt; endl; else cout &lt;&lt; \"4 found:\" &lt;&lt; *it1 &lt;&lt; endl; it1 = find(ivect.begin(), ivect.end(), 8); if( it1 == ivect.end() ) cout &lt;&lt; \"8 not found.\" &lt;&lt; endl; else cout &lt;&lt; \"8 found\" &lt;&lt; *it1 &lt;&lt; endl; return 0;&#125; 运行结果： 3.2 迭代器(ierator)是一种smart pointer迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-&gt; 进行重载工作。以下，简单模拟一个list的结构，然后设计对应的iterator。12345678910111213141516171819202122232425//listnodetemplate &lt;typename T&gt;class ListItem&#123;public: T value() const&#123; return _value; &#125; ListItem* next() const&#123; return _next; &#125; //...private: T _value; ListItem* _next; //单向链表(single linked list)&#125;;//listtemplate &lt;typename T&gt;class List&#123;public: void insert_front(T value); //省略实现 void insert_end(T value); //省略实现 voide display(std::ostream &amp;os = std::cout) const;//省略实现 //...private: ListItem&lt;T&gt;* _end; ListItem&lt;T&gt;* _front; long _size;&#125;; 当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：1234567891011121314151617181920212223242526//iteratortemplate &lt;class Item&gt;//Item可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的operator++只适用于链表。struct ListIter&#123; Item* ptr; //保持与容器之间的一个联系 ListIter( Item* p = 0 ) :ptr(p) &#123;&#125; //不必实现copy ctor，因为编译器提供的缺省行为已经足够 //不必实现operator=，因为编译器提供的缺省行为已经足够 Item&amp; operator*() const &#123; return *ptr; &#125; Item* operator-&gt;() const &#123; return ptr; &#125; //operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator) //pre-increament operator ListIter&amp; operator++()&#123; ptr = ptr-&gt;next(); return *this; &#125; //post-incteament operator LostIter operator++(int)&#123; ListIter tmp = *this; ++*this; return tmp; &#125; bool operator==(const LostIter&amp; i)const&#123; return ptr == i.ptr; &#125; bool operator!=(const LostIter&amp; i)const&#123; return ptr != i.ptr; &#125;&#125; 接下来，将List和find()由ListIter粘合起来：1234567891011121314151617181920int main()&#123; List&lt;int&gt; mylist; for( int i=0; i&lt;5; ++i )&#123; mylist.insert_front(i); mylist.insert_end(i+2); &#125; mylist.displau(); //10( 4 3 2 1 0 2 3 4 5 6) ListIter&lt;ListItem&lt;int&gt; &gt; begin(mylist.front()); ListIter&lt;ListItem&lt;int&gt; &gt; end; ListIter&lt;ListItem&lt;int&gt; &gt; iter; iter = find(begin, end, 3); if( iter == end ) cout &lt;&lt; \"not found\" &lt;&lt; endl; else cout &lt;&lt; \"found.\" &lt;&lt; iter-&gt;value() &lt;&lt; endl; //执行结果：found.3 return 0;&#125; 由于find() 函数以*iter != value来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 ListIterm&lt;int&gt;,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和ListIterm&lt;int&gt;。如下：12template &lt;typename T&gt;bool operator!=(const ListItem&lt;T&gt;&amp; item, T n)&#123; return item.value() != n; &#125; 3.3 迭代器相应型别(associated types)当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。 3.4 Traits 编程技法——STL源代码门钥value type：迭代器所指对象的型别。上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的”template参数推导机制”推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：123456789101112131415template &lt;class T&gt;struct MyIter&#123; typedef T value_type; //内嵌型别声明(nested type) MyIter(T* p = 0) :ptr(p) &#123;&#125; T&amp; operator*() const &#123; return *ptr; &#125; //... T* ptr; //成员变量&#125;;template &lt;class I&gt;typename I::value_type func( I ite )&#123; return *ite; &#125; //typename I::value_type 这是func的返回值型别；//...MyIter&lt;int&gt; ite(new int(8));cout &lt;&lt; func(ite); //输出:8 typename I::value_type必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。 这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 偏特化(template partial specialization)。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：12345678910//class templatetemplate &lt;typename T&gt;class C&#123; //这个泛化版本接受T为任何型别 //...&#125;;//prartial specializationtemplate &lt;typename T&gt;class C&lt;T*&gt;&#123; //这个特化版本只适用于\"T 为原生指针\"的情况 //...&#125;; 下面这个例子，专门用来萃取迭代器的特性，value type正是迭代器的特性之一1234template &lt;class I&gt;struct iterator_traits&#123; //traits意思为“特性” typedef typename I::value_type value_type;&#125;; 这样，前面那个func函数可以修改成这样。123template &lt;class I&gt;//typename iterator_traits&lt;I&gt;::value_type 是函数的返回型别typename iterator_traits&lt;I&gt;::value_type func(I ite)&#123; return *ite; &#125; 跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：1234template &lt;class T&gt;struct iterator_traits&lt;T*&gt;&#123; //偏特化版本--迭代器是一个原生指针 typedef T value_type;&#125; 此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的iterator_traits&lt;const int*&gt;::value_type得到的是const int。所以我们另外设计一个特化版本，让const T*转变为T*：1234template &lt;class T&gt;struct iterator_traits&lt;const T*&gt;&#123; //偏特化版本，当迭代器是一个const指针的时候， typedef T value_type; //萃取出来的是T，而不是const T&#125;; 到这里为止，不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。 图解iterator_traits：常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：12345678template &lt;class I&gt;struct iterator_traits&#123; typedef typename I::iterator_category iterator_category; typedef typename I::value_type value_type; typedef typename I::difference_type difference_type; typedef typename I::pointer pointer; typedef typename I::reference reference;&#125;; 其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。以上： 3.4.1 value type 如上3.4.2 difference type3.4.3 reference type3.4.4 pointer type3.4.5 iterator_catrgory","categories":[{"name":"learning","slug":"learning","permalink":"http://jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"浅读《STL源码剖析》笔记 1、2章","slug":"浅读《STL源码剖析》笔记-1、2章","date":"2018-02-03T03:15:06.000Z","updated":"2018-02-09T02:28:51.233Z","comments":true,"path":"2018/02/03/浅读《STL源码剖析》笔记-1、2章/","link":"","permalink":"http://jingxxn.cn/2018/02/03/浅读《STL源码剖析》笔记-1、2章/","excerpt":"1 STL概论与版本简介1.2 STL六大组件 容器(containers):vector,list,deque,set,map,用来存放数据 算法(algorithms):sort,search,copy,erase 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，","text":"1 STL概论与版本简介1.2 STL六大组件 容器(containers):vector,list,deque,set,map,用来存放数据 算法(algorithms):sort,search,copy,erase 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，迭代器器将operator*,operator++,operator--,operator-&gt;等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。 仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。 配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。 配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。 1.5~1.8 STL版本之二 P.J.Plauger (Microsoft Visual C++) SGI STL (Linux GCC) C++标准规范下的C头文件: cstdio,cstdlib,cstring C++标准程序库中不属于STL范畴: stream,string STL标准头文件: vector,deque,list,map,algorithm,functional C++Standard定案前，HP所规范的STL头文件: vector.h,deque.h,list.h,algo.h,function.h SGI STL内部文件(STL真正实现于此): stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h 1.9 可能令你困惑的C++语法1.9.2 临时对象的产生与运用临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。STL中最常将此技巧用在仿函数(functor)中。临时对象的生命周期只有这一行指令。 1.9.3 静态常量整数成员在class内部直接初始化class内含有const static integral data member，我们可以直接给予初值。123456789101112131415//1.9.3测试代码如下template &lt;typename T&gt;class testclass&#123;public: static const int datai = 5; static const long datal = 3L; static const char datac = 'c';&#125;;int main()&#123; cout &lt;&lt; testclass&lt;int&gt;::datai &lt;&lt; endl; cout &lt;&lt; testclass&lt;int&gt;::datal &lt;&lt; endl; cout &lt;&lt; testclass&lt;int&gt;::datac &lt;&lt; endl; return 0;&#125; 运行结果： 1.9.5 前闭后开区间表示法[)STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。 1.9.6 function call操作符(operator())function call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。如果你针对某个class进行operator()重载，它就成为一个仿函数。1234567891011121314151617//1.9.6测试代码如下template &lt;class T&gt;struct Add&#123; //重载了operator() T operator()(const T&amp;x, const T&amp;y) const&#123; return x+y; &#125;&#125;;int main()&#123; Add&lt;int&gt; addxy; system( \"clear\" ); //调用重载函数 cout &lt;&lt; addxy(3,5) &lt;&lt; endl; //调用匿名对象 cout &lt;&lt; Add&lt;int&gt;()(5,5) &lt;&lt; endl; return 0;&#125; 运行结果： 2 空间配置器(allocator)空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。 2.2 具备此配置力的SGI空间配置器2.2.1 SGI标准的空间配置器,std::allocatorSGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：vector&lt;int,std::allocator&lt;int&gt;&gt;;SGI STL写法如下：vector&lt;int, std::aloc&gt;绝大多数情况下，我们都是使用缺省的空间配置器。 2.2.2 SGI特殊的空间配置器，std::allocSGI同时也配备了标准空间配置器std::allocator，但是这只是对C++的operator new和operator delete做了一层封装，效率低下，SGI并不使用，只是为了向前兼容语法。 SGI自身使用的空间配置器是std::alloc一般来说，我们习惯的C++内存操作和释放操作是这样的：123class Foo&#123;&#125;;Foo* pf = new Foo;delete pf; 这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。STL的配置器(allocator)定于于&lt;memory&gt;，其中包含两个文件,一个是负责内存空间的配置与释放,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构，定义了全局函数construct()和destroy()。 2.2.3 构造和析构基本工具:construct()和destroy()construct()的实现如下：12345#include &lt;new.h&gt; //使用placement new 需要这个头文件template &lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value)&#123; new (p) T1(value); //使用了placement new;调用T1:T1(value);&#125; 代码解释：construct()接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，通过placement new实现。destroy()有两个版本，实现如下:123456789101112131415161718192021222324252627282930//第一个版本，接受一个指针template &lt;class T&gt;inline void destroy(T* pointer)&#123; pointer-&gt;~T();&#125;//第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits&lt;&gt;求取最适当的措施。template &lt;class ForwardIterator&gt;inline void destroy(ForwardIterator first, ForwardIterator last)&#123; __destroy(first, last, value_type(first));&#125;//判断元素的数值型别(value type)是否有 trivial destructortemplate &lt;class ForwardIterator, class T&gt;inline void __destroy(ForwardIterator first, ForwardIterator last, T*)&#123; typedef typename __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor; __destroy_aux(first, last, trivial_destructor());&#125;//如果元素的数值型别(value type)有non-truvial destructor，循环释放template &lt;class ForwardIterator&gt;inline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type)&#123; for( ; first &lt; last; ++first) //调用第一个版本的destroy() destroy(&amp;* first);&#125;//如果元素的数值型别(value type)有trivial destructor,函数什么也不做template &lt;class ForwardIterator, ForwardIterator, __true_type&gt;&#123; inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type)&#123;&#125;&#125;//destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做inline void desroy(char*, char*)&#123;&#125;inline void destroy(wchar_t*,wchar_t*)&#123;&#125; 代码解释：destroy()有两个版本，第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可。第二个版本接收first和last两个迭代器，准备将[firat, last)范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓trivial destructor),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，这里首先利用value_type()获得迭代器所指对象的型别，再利用__type_traits&lt;T&gt;判断该型别的析构函数是否无关痛痒。若是(__true_type)，则什么都不做结束；若不是(__false_type),这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的destroy()。 construct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits&lt;&gt;在3.7节。 2.2.4 空间的配置与释放，std::alloc对象构造前的空间配置和对象析构后的空间释放，由&lt;stl_alloc.h&gt;负责。 向 system heap 要求空间 考虑多线程(multi-threads)状态(这里不考虑多线程的情况) 考虑内存不足时的应变措施 考虑过多“小型区域”可能造成的内存碎片(fragment)问题 C++内存配置的基本操作是::operator new()，内存释放的基本操作是::operator delete()。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。 为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，第一级配置器(__malloc_alloc_template)用malloc()和free()，第二级配置器(__default_alloc_template)看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池memory bool整理方式。其中具体是开放了第一级配置器还是两级配置器都开放了由USE_MEALLOC是否定义决定，定义了USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。 无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口simple_alloc，使其能够符合STL的接口规格。1234567891011121314151617template &lt;class T,class Alloc&gt;class simple_alloc&#123;public: static T* allocate(size_t n)&#123; return 0 == n?0 : (T*) Alloc::allocate(n* sizeof (T)); &#125; static T* allocate(void)&#123; return (T*) Alloc::allocatte(sizeof (T)); &#125; static void dallocate(T* p, size_t n)&#123; if(0 != n) Alloc::deallocate(p, n*sizeof (T)); &#125; static void deallocat(T* p)&#123; Alloc::deallocate(p, sizeof (T)); &#125;&#125;; 内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。 图解如下： 第一级配置器和第二级配置器： 包装接口和运用： 接下来几节，暂时先压住…… 2.2.5 第一级配置器 __malloc_alloc_template 剖析2.2.6 第二级配置器__default_alloc_template 剖析2.2.7 空间配置函数allocate()2.2.8 空间释放函数 deallocate()2.2.9 重新填充 free lists2.2.10 内存池(memory pool)2.3 内存基本处理工具STL定义了五个全局函数，作用于未初始化化空间上：用于构造的construct()和析构的destroy(),另外三个是：uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()(定于于&lt;memory&gt;),分别对应于高层次函数copy(),fill(),fill_n(),这些都是STL的算法。 2.3.1 uninitialized_copy2.3.2 uninitialized_fill2.3.3 uninitialized_fill_n","categories":[{"name":"learning","slug":"learning","permalink":"http://jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"复杂单链表的复制","slug":"复杂单链表的复制","date":"2018-01-31T06:54:57.000Z","updated":"2018-02-08T06:19:39.885Z","comments":true,"path":"2018/01/31/复杂单链表的复制/","link":"","permalink":"http://jingxxn.cn/2018/01/31/复杂单链表的复制/","excerpt":"题目:有一个单链表，该链表节点有两个指针，一个_next指向下一个节点，另一个_random指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。 思路： 单链表的复制比较简单，但是_random不好处理，如果_random指向前面的节点，我们该如何处理。_random还有可能是指向NULL，这种情况也需要单独处理。","text":"题目:有一个单链表，该链表节点有两个指针，一个_next指向下一个节点，另一个_random指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。 思路： 单链表的复制比较简单，但是_random不好处理，如果_random指向前面的节点，我们该如何处理。_random还有可能是指向NULL，这种情况也需要单独处理。 为了解决这个问题，我们可以用一个比较巧妙的方法，对每一个节点都复制，同时插入到当前节点的后面。这样我们就得到了一个重复的链表，此时有一个优势，新_random就是原来_random的后一个。我们就不需要在考虑往前寻找的问题了。只需要找到当前节点的_random的_next就行。 这样处理之后，我们就得到了一个新的链表，接着只需要进行拆分就好了。 看图如下：创建了一个复杂链表 进行对每一个节点的复制同时插入到原链表中 给出节点的结构如下：123456789101112#define datatype inttypedef struct complexnode&#123; complexnode(datatype val)&#123; _data = val; _next = NULL; _random = NULL; &#125; datatype _data; complexnode* _next; complexnode* _random;&#125;comnode; 实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//主函数comnode* copy_complex_list( comnode* head )&#123; comnode* cur = head; comnode* next = cur-&gt;_next; if( cur == NULL ) return NULL; //将每一个节点复制到当前节点的后面，并链入链表 while( cur )&#123; comnode* tmp = new comnode(cur-&gt;_data); cur-&gt;_next = tmp; tmp-&gt;_next = next; cur = next; //防止对NULL访问 if( cur ) next = cur-&gt;_next; &#125; //将指针重置指向头结点 cur = head; next = cur-&gt;_next; //给新链入的节点置random while( cur )&#123; //分类处理_random为NULL的情况 if( cur-&gt;_random ) next-&gt;_random = cur-&gt;_random-&gt;_next; else next-&gt;_random = NULL; cur = next-&gt;_next; if( cur ) next = cur-&gt;_next; &#125; cur = head; next = cur-&gt;_next; comnode* result = next; //拆分两个链表 while( cur )&#123; cur-&gt;_next = next-&gt;_next; cur = cur-&gt;_next; if( cur )&#123; next-&gt;_next = cur-&gt;_next; next = next-&gt;_next; &#125; &#125; return result;&#125;//打印函数void print_random( comnode* head )&#123; comnode* cur = head; cout &lt;&lt; \"list:\"; while( cur )&#123; cout &lt;&lt; cur-&gt;_data &lt;&lt; \"-&gt;\"; cur = cur-&gt;_next; &#125; cout &lt;&lt; \"NULL\" &lt;&lt; endl &lt;&lt; \"random:\"; cur = head; while( cur )&#123; if( cur-&gt;_random ) cout &lt;&lt; cur-&gt;_random-&gt;_data &lt;&lt; \" \"; else cout &lt;&lt; \"NULL\" &lt;&lt; \" \"; cur = cur-&gt;_next; &#125; cout &lt;&lt; endl;&#125;int main()&#123; comnode* head = new comnode(1); comnode* n1 = new comnode(2); comnode* n2 = new comnode(4); comnode* n3 = new comnode(5); comnode* n4 = new comnode(9); head-&gt;_next = n1; n1-&gt;_next = n2; n2-&gt;_next = n3; n3-&gt;_next = n4; n4-&gt;_next = NULL; head-&gt;_random = n2; n1-&gt;_random = head; n2-&gt;_random = n3; n3-&gt;_random = NULL; n4-&gt;_random = n4; system( \"clear\" ); comnode* copy_list = copy_complex_list( head ); print_random(head); cout &lt;&lt; \"copy_list:\" &lt;&lt; endl; print_random(copy_list); return 0;&#125; 运行结果如下：同时打印了原来的链表和复制的链表 CSDN上用C写的，同时也将各个部分功能进行了函数封装","categories":[{"name":"practice","slug":"practice","permalink":"http://jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"浅读《More Effective C++》笔记","slug":"浅读《More-Effective-C-》笔记","date":"2018-01-30T06:27:03.000Z","updated":"2018-02-13T16:51:02.035Z","comments":true,"path":"2018/01/30/浅读《More-Effective-C-》笔记/","link":"","permalink":"http://jingxxn.cn/2018/01/30/浅读《More-Effective-C-》笔记/","excerpt":"基础议题条款1：区分指针和引用不存在空引用，引用必须要指向某个对象。当确定某个对象不允许有空值，就需要定义为引用，而不是指针。123//这种做法语法上没有错误，出现了引用为空的情况。但是不同的编译器会有不同的报错。不允许出现这样的代码。char* pc = 0;char &amp;rc = *pc; 因为不存在空引用这种情况，所以使引用会比指针更高效。","text":"基础议题条款1：区分指针和引用不存在空引用，引用必须要指向某个对象。当确定某个对象不允许有空值，就需要定义为引用，而不是指针。123//这种做法语法上没有错误，出现了引用为空的情况。但是不同的编译器会有不同的报错。不允许出现这样的代码。char* pc = 0;char &amp;rc = *pc; 因为不存在空引用这种情况，所以使引用会比指针更高效。12345678//引用不用判空void print_double(const double&amp; rd)&#123; cout &lt;&lt; rd;&#125;//指针要判空void print_double1(const double *pd)&#123; if(pd)&#123; cout &lt;&lt; *pd; &#125;&#125; 指针可以被重新赋值用以指向另外一个不同的对象，而引用则总是指向初始化时它指向的对象。12345678string s1(\"nancy\");string s2(\"clancy\");string&amp; rs = s1;string *ps = &amp;s1;//rs依然是s1的引用，此时rs = s1 = s2 = \"clancy\"rs = s2;//ps指向了s2,不再指向s1ps = &amp;s2; 实现某些操作符的时候，最常见的是[]操作符，绝大多数应该返回引用。12345vector&lt;int&gt; v(10);//一般情况下的返回值，此时是引用v[5] = 10;//如果返回的是指针就需要这样解引用，看起来v就像是一个指针vector一样。*v[5] = 10; 条款2：优先考虑C++风格的类型转换四个类型转换操作符：static_cast,const_cast,dynamic_cast,reinterpret_cast static_cast：作用类似于C中的隐式类型转换，只能转换相近类型的变量。比如struct到int的转换就不能实现。而且在C++中，static_cast并不能将const属性转换为非const属性。 const_cast：专门用来去除const属性和volatile属性。const_cast被用来用作其他的类型转换会被拒绝。 dynamic_cast：它是用来针对一个继承体系做向下或者横向的安全转换的。也就是说，用dynamic_cast把指向基类的指针或引用转换成指向派生类或者基类的兄弟类的指针或引用，同时可以知道是否成功。出现空指针(转换指针的时候)或者出现异常(转换引用的时候)意味着失败。他不能用于哪些没有虚函数的类型，也不能去除const属性。 reinterpret_const：这个操作符，转换结果往往是编译器定义的。因此它几乎是不可以移植的。最常见的用法是在函数指针之间进行类型转换。但是一般我们不使用这种转换，因为c++没有规定这种做法，有可能出现未知的错误，除非万不得已，不然不使用。 使用格式举例：static_cast&lt;double&gt; (first); const_cast&lt;special*&gt;(first); dynamic_cast&lt;special *&gt;(&amp;first); reinterpret_cast&lt;funcptr&gt; (&amp;dosomething); 条款3：绝不要把多态应用于数组继承的一大特性，它允许你通过指向基类的指针和引用来操纵派生类对象。这种指针和引用的行为具有多态性。同时C++也允许你通过基类指针和引用来操纵派生类数组，但是这个应该不被允许。见下面这个例子：123456789//一个BST类，有一个BalancedBST的类，它继承与BSTclass BST&#123;//...&#125;;class BalancedBST&#123;//...&#125;;//一个用于打印BST数组中BST元素的函数void printBSTArray(ostream&amp;s, const BST array[], int numElements)&#123; for( int i = 0; i &lt; numElements; ++i )&#123; s &lt;&lt; array[i]; &#125;&#125; 第一种情况，传递的数组是BST数组，程序没有问题；第二种情况，传递的数组是BalancedBST数组(继承于BST),编译器并不会报错，但是会出现问题，关键在于对array[i]的使用。array[i]=*(array+i)，我们知道array是指向数组的首地址的指针，其中array+i偏移的地址是根据元素的大小而定的。因为上例子中，array的类型是BST，所以array[i]的偏移是array+i*sizeof(SBT)。但我们传递了BST的子类BalancedBST给array，这样array的访问就会出现问题。 同时，如果打算通过一个基类指针删除一个包含派生类对象的数组，一样会出现问题。1234567void deleteArray(ostream&amp; logStream, BST array[])&#123; logStream &lt;&lt; static_cast&lt;void*&gt;(array) &lt;&lt; endl; delete[] array;&#125;BalancedBST *balTreeArray = new BalancedBST[50];//...deleteArray(cout, balTreeArray); 明面上这里并没有调用指针，但是当删除数组的时候，数组元素的析构函数必须被调用。 条款4 避免不必要的默认构造函数","categories":[{"name":"learning","slug":"learning","permalink":"http://jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"static const integral data member在类中的初始化","slug":"static-const-integral-data-member在类中的初始化","date":"2018-01-30T06:25:04.000Z","updated":"2018-02-09T02:36:56.418Z","comments":true,"path":"2018/01/30/static-const-integral-data-member在类中的初始化/","link":"","permalink":"http://jingxxn.cn/2018/01/30/static-const-integral-data-member在类中的初始化/","excerpt":"当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。该类的其它对象对这个静态变量也是可以进行修改的。1234567891011121314151617//非常量静态成员变量初始化对比#include &lt;iostream&gt;using namespace std;class person&#123; public: static int num; //static int num = 11;&#125;;int person::num = 10;int main()&#123; person bob; system(\"clear\"); cout &lt;&lt; bob.num &lt;&lt; endl; return 0;&#125;","text":"当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。该类的其它对象对这个静态变量也是可以进行修改的。1234567891011121314151617//非常量静态成员变量初始化对比#include &lt;iostream&gt;using namespace std;class person&#123; public: static int num; //static int num = 11;&#125;;int person::num = 10;int main()&#123; person bob; system(\"clear\"); cout &lt;&lt; bob.num &lt;&lt; endl; return 0;&#125; 在类内初始化非常量静态成员变量失败在类外初始化静态成员变量成功123//定义另外一个对象timmyperson timmy;cout &lt;&lt; \"timmy:\" &lt;&lt; timmy.num&lt;&lt; endl; 同一个类的不同对象共用一个静态成员变量 但是，常量的静态成员变量可以在类里面定义。12345678910111213141516#include &lt;iostream&gt;using namespace std;class person&#123; public: static const int num = 11; const static int age = 23;&#125;;int main()&#123; system(\"clear\"); person tom; cout &lt;&lt; \"tom:\" &lt;&lt; tom.num &lt;&lt; endl; cout &lt;&lt; \"tom:\" &lt;&lt; tom.age &lt;&lt; endl; return 0;&#125; static const和const static一样的。 可是只有integral data member才可以，像 int，long，char才行。double，float等都不行12345678910111213#include &lt;iostream&gt;using namespace std;class person&#123; public: static const double num = 2.2;&#125;;int main()&#123; system(\"clear\"); person tom; cout &lt;&lt; \"tom:\" &lt;&lt; tom.num &lt;&lt; endl; return 0;&#125; 用 static const double 初始化失败","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"创建一个不能被继承的类","slug":"创建一个不能被继承的类","date":"2018-01-29T02:23:19.000Z","updated":"2018-02-08T06:19:49.872Z","comments":true,"path":"2018/01/29/创建一个不能被继承的类/","link":"","permalink":"http://jingxxn.cn/2018/01/29/创建一个不能被继承的类/","excerpt":"题目：题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。 思路： 题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。","text":"题目：题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。 思路： 题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。那么我们只要将构造函数或析构函数定义为私有成员函数就好了。 第二个要求，能够正常使用，这样显然之前的方式是行不通的。构造函数为私有了，就无法创建对象了。那我再给他加一个友元函数，这样对象也可以创建了。 可是题目的要求是正常使用这个类，显然通过一个友元函数是不符合我们正常使用类的方式。 这个时候，正真正确的思路就出来了。我们借用一个中间类。例如：我们不能被继承的类是man，我们创建一个 私有构造函数的父类person，同时将 man定义为person的友元类。这样man就可以正常访问person的私有构造函数了。接着我们让 man虚继承person，到这里我们就完成了这个题目。 让man虚继承person是为了让继承man的类，都需要在man的父类，即person中调用构造函数，但只有man是person的友元类，其他的类都不能访问person的构造函数。因此man就成为了不能被继承的类，而man本身可以正常使用。 代码如下：123456789101112131415161718192021222324252627282930313233343536include &lt;iostream&gt;using namespace std;//设计一个不能被继承的类class person&#123; public: friend class man; private: //构造函数为private person()&#123;&#125;&#125;;//man虚拟继承personclass man:virtual public person &#123; public: man()&#123; age = 18; &#125; void show()&#123; cout &lt;&lt; age &lt;&lt; endl; &#125; private: int age;&#125;;// class son:public man&#123;// public:// son()&#123;&#125;// &#125;;int main()&#123; man bob; system( \"clear\" ); bob.show(); //son tom; return 0;&#125; 不定义man的继承类son，正常输出man的age = 18 定义man的继承类son失败","categories":[{"name":"practice","slug":"practice","permalink":"http://jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"位运算实现Add","slug":"位运算实现Add","date":"2018-01-28T05:30:43.000Z","updated":"2018-02-08T06:20:27.616Z","comments":true,"path":"2018/01/28/位运算实现Add/","link":"","permalink":"http://jingxxn.cn/2018/01/28/位运算实现Add/","excerpt":"题目：实现一个Add函数，让两个整数相加，不能够使用+-*/、++、-- 思路： 正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，15+5=20先将位进行相加，不进行进位，得到10，再将进位加上，个位没有进位，十位进1，得到20。","text":"题目：实现一个Add函数，让两个整数相加，不能够使用+-*/、++、-- 思路： 正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，15+5=20先将位进行相加，不进行进位，得到10，再将进位加上，个位没有进位，十位进1，得到20。 题目要求不能使用+-*/，所以想到了位运算。15的二进制是1111，5的二进制是0101。根据上面的思路，我们先进行不进位相加，得到1010。(这个运算方式正好对应^)然后将进位加上(只求进位的运算正好对应&amp;再左移一位)，例子中只有第四位、第二位数值有进位值。得到10100，这个值就是20。 代码如下123456789101112131415161718192021222324//1、递归实现，每次将不进位相加的值赋给a，将计算出来的进位值赋给b，递归进行两者的分步相加，直到进位值`b=0`，返回a。long long Add( int a, int b )&#123; if( b == 0 ) return a; int sum = a^b; b = (a&amp;b)&lt;&lt;1; a = sum; return Add( a, b );&#125;int main()&#123; system( \"clear\" ); cout &lt;&lt; Add(3, 7) &lt;&lt; endl; //2、同时可以用迭代实现(非函数)，思路一样，进位值b最后肯定会等于0，因为总有进位结束的时候。 int a = 49; int b = 4; while( b != 0 )&#123; int sum = a^b; b = (a&amp;b)&lt;&lt;1; a = sum; &#125; cout &lt;&lt; a &lt;&lt; endl; return 0;&#125;","categories":[{"name":"practice","slug":"practice","permalink":"http://jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"1+2+……+n的特殊求法","slug":"1-……-n的特殊求法","date":"2018-01-26T16:44:40.000Z","updated":"2018-02-08T06:20:15.815Z","comments":true,"path":"2018/01/27/1-……-n的特殊求法/","link":"","permalink":"http://jingxxn.cn/2018/01/27/1-……-n的特殊求法/","excerpt":"题目：求1+2+3+…+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。 自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&amp;&amp;的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。 更新：18.1.28发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了柔性数组，这种数组的长度的可变的，不需要用常量定义。","text":"题目：求1+2+3+…+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。 自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&amp;&amp;的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。 更新：18.1.28发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了柔性数组，这种数组的长度的可变的，不需要用常量定义。 123456789101112class Solution&#123; public: int Sum_Solution( int n )&#123; bool a[n][n+1]; return sizeof(a)&gt;&gt;1; &#125;&#125;;int main()&#123; Solution s; cout &lt;&lt; s.Sum_Solution(10) &lt;&lt; endl; return 0;&#125; 原文： 利用&amp;&amp;操作符，|| 也一样的做法。思路：当result = 0 的时候，&amp;&amp;不再判断右操作数，递归停止。 123456789int sum( int n )&#123; int result = n; result &amp;&amp; (result += sum(n-1)); return result;&#125;int main()&#123; cout &lt;&lt; sum(100) &lt;&lt; endl; return 0;&#125; 利用构造函数以及静态成员变量思路：构造N次对象，每次对静态变量sum++，对n赋值。利用静态变量对所有同类对象有效的特点。 1234567891011121314151617181920212223242526272829303132333435class tmp&#123;public: //构造 tmp( )&#123; ++n; sum += n; &#125; //初始化 void static init()&#123; n = 0; sum = 0; &#125; //获得sum int static getsum()&#123; return sum; &#125;private: static int n; static int sum;&#125;;int tmp::n = 0;int tmp::sum = 0;//运行的函数int count(int n)&#123; tmp::init(); tmp* a = new tmp[n]; delete[] a; a = NULL; tmp::getsum();&#125;int main()&#123; cout &lt;&lt; count(100) &lt;&lt; endl; return 0;&#125; 利用虚函数、继承和函数指针思路： 定义两个类，A是基类，B是子类。 定义一个A* Array[2],其中Array[0]存放A对象的地址，Array[1]存放B对象的地址。 调用函数Sum中调用Sum的递归。同时对变量n两次取反Array[!!n]-&gt;Sum(n-1)+n,这样当n不为0的时候，得到bool值1。Array[!!n] = Array[1] 当n=0调用基类A的sum。充分利用虚函数参数与类型有关的性质。 12345678910111213141516171819202122232425262728293031323334353637383940414243//1、虚函数#include &lt;iostream&gt;using namespace std;class A;A* Array[2];class A&#123;public: virtual int Sum( int n )&#123; return 0; &#125;&#125;;class B:public A&#123;public: virtual int Sum( int n )&#123; //当 n != 0, !!n = 1 return Array[!!n]-&gt;Sum(n-1)+n; &#125;&#125;;int Sum2( int n )&#123; A a; B b; Array[0] = &amp;a; Array[1] = &amp;b; //调用虚函数 int value = Array[1]-&gt;Sum(n); return value;&#125;int main()&#123; cout &lt;&lt; Sum2(100) &lt;&lt; endl; return 0;&#125;//2、同上，这里利用函数指针来实现。typedef int (*fun)(int);int Sum( int i )&#123; return 0;&#125;int Sum2( int i )&#123; fun f[2] = &#123; Sum, Sum2 &#125;; return i + f[!!n](i-1);&#125; 利用异常处理的机制思路：try接收到的异常会在catch中捕获。 1234567891011int sum(int n)&#123; try&#123; //n = 2 的时候，出现异常，程序流跳转到catch int[] array = new int[n-2]; return n+sum(n-1); &#125; catch(Exception e)&#123; //返回1到上一个递归处，n = 2处。 return 1; &#125;&#125; 利用模板思路：利用了模板的特化作为递归结束的条件，并借用枚举类型。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;template &lt;unsigned N&gt;class Sum&#123; public: enum&#123; sum = N+Sum&lt;N-1&gt;::sum &#125;;&#125;;//模板特化，当N=1 的时候，调用template&lt;&gt;class Sum&lt;1&gt;&#123; public: enum&#123; sum = 1 &#125;;&#125;;int main()&#123; cout &lt;&lt; Sum&lt;100&gt;::sum &lt;&lt; endl; return 0;&#125; 方法来源地址","categories":[{"name":"practice","slug":"practice","permalink":"http://jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"收集","slug":"Linux相关网站","date":"2018-01-25T10:18:01.000Z","updated":"2018-02-09T02:33:52.783Z","comments":true,"path":"2018/01/25/Linux相关网站/","link":"","permalink":"http://jingxxn.cn/2018/01/25/Linux相关网站/","excerpt":"1、Linux命令相关 Linux命令大全：http://man.linuxde.net/ 修改时间查看时间：https://www.cnblogs.com/jiu0821/p/5999566.html 移动、重命名文件/目录：https://linux.cn/article-2688-1.html 查看系统版本：http://www.linuxidc.com/Linux/2015-07/119897.htm","text":"1、Linux命令相关 Linux命令大全：http://man.linuxde.net/ 修改时间查看时间：https://www.cnblogs.com/jiu0821/p/5999566.html 移动、重命名文件/目录：https://linux.cn/article-2688-1.html 查看系统版本：http://www.linuxidc.com/Linux/2015-07/119897.htm vim相关 vim的配置：http://blog.csdn.net/footmart_c/article/details/51588524 多行删除复制：https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html vim安装报错EXTERN.h：http://tieba.baidu.com/p/4471948063 vim升级8.0+YouCompleteMe补全插件：http://blog.csdn.net/nzyalj/article/details/75331822 vim8.0升级后添加到路径中：http://blog.csdn.net/u013388603/article/details/72780586 YouCompleteMe：http://blog.51cto.com/990487026/1905427 git相关 git安装：https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html git安装：http://blog.csdn.net/u013256816/article/details/54743470 git升级2.7.3：https://www.cnblogs.com/yexinw/p/6401663.html python相关 2.6升级2.7：https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html 安装3.5.2并与python2共存：https://www.ywlib.com/archives/96-1.html 输入相关 python造成 input method preferences无效：http://blog.csdn.net/jaket5219999/article/details/52912321 安装Fcitx 4.0.0：https://www.douban.com/note/319236531/ 设置Fcitx默认：https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html ibus开启：http://blog.csdn.net/zitong_ccnu/article/details/40110583 源相关 Nux Dextop源：http://www.linuxidc.com/Linux/2016-06/132101.htm yum源解析（详细）：https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html Hexo相关 gcc升级：http://www.cnblogs.com/lpbottle/p/install_gcc.html gcc升级：http://blog.csdn.net/furzoom/article/details/53322510 gcc升级：http://blog.csdn.net/zr1076311296/article/details/51334538 Nodejs安装：https://www.cnblogs.com/lpbottle/p/7733397.html 其它 /mnt/hgfs没有共享文件夹：http://www.mamicode.com/info-detail-1655589.html Linux就该这么学：http://www.linuxprobe.com/chapter-00.html 2、C语言 链表相关笔试题：http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html 3、GitHub 知乎：https://www.zhihu.com/question/20070065 他的网站里有：http://youngxhui.github.io/ 以下，搭建自己的github博客： 配置详细：https://www.jianshu.com/p/b7886271e21a 很强大的一个：http://kchen.cc/2016/11/12/hexo-instructions/ WordPress和Hexo以及md编辑器：https://www.imooc.com/article/12257 localhost:4000出问题：http://blog.csdn.net/u012246342/article/details/51543370 Hexo问题总结：http://blog.csdn.net/wx_962464/article/details/44786929 4、blog http://www.zipperary.com/ 陈皓：https://coolshell.cn/featured 5、其它 msdn：https://msdn.itellyou.cn/ NTFS和FAT32区别：http://www.ntfsformac.cn/qita-nytqubie.html SQL源码剖析：http://deepfuture.iteye.com/blog/718478","categories":[{"name":"网站收集","slug":"网站收集","permalink":"http://jingxxn.cn/categories/网站收集/"}],"tags":[]}]}