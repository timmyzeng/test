---
title: 二叉树的基本实现
date: 2018-03-06 15:47:19
tags:
categories:
    - "knowledge"
    - "数据结构"
keywords:
    - "C++"
    - "binarytree"
    - "非递归遍历"
password:
---
## 二叉树
本文将使用c++实现模板类的二叉树，内容包括创建、递归遍历、非递归遍历、结点个数、深度、叶子结点的个数、第K层结点个数等函数。
### 结点、二叉树结构
二叉树的结点是一个结构体，包括值`_data`，指向左子树的指针和指向右子树的指针`_left`和`_right`。还有构造函数，用于创建结点。<!--more-->
将`BinaryTreeNode<T>`typedef为`Node`,很多时候我会遗漏模板的类型名需要加上`<T>`，这样就会出错。为了减少这种错误，索性用typedef换名。<
```c++
template <class T>
struct BinaryTreeNode
{
    BinaryTreeNode* _left;
    BinaryTreeNode* _right;
    T _data;

    BinaryTreeNode(const T& data = T()){
        _data = data;
        _left = NULL;
        _right = NULL;
    }
};

template <class T>
class BinaryTree{
typedef BinaryTreeNode<T> Node;
public:
    //...
protected:
    Node* _root;
};
```
## 默认成员函数
### 构造函数
设置了两个构造函数，一个为空，用于创建一个空的二叉树；另一个参数为两个。
`const T* a` 数组名
`const T& invalid` 非法值
解释一下，这里我用一个数组创建二叉树，同时用'#'表示这个空。如这个例子：

    int a1[] = {1,2,3,'#','#',4,'#','#',5,6,'#','#','#'};
如果`a1[i] != '#'`那么就创建，反之，表示这个位置没有结点。
```c++
//constructor
BinaryTree(){
    _root = NULL;
}
BinaryTree(const T* a, const T& invalid){
    size_t index = 0;
    _root = _CreateTree(a, invalid, index);
}
Node* _CreateTree(const T* a, const T& invalid, size_t& index){
    Node* root = NULL;
    if(a[index] != invalid){
        root = new Node(a[index]);
        root->_left = _CreateTree(a, invalid, ++index);
        root->_right = _CreateTree(a, invalid, ++index);
    }
    return root;
}
```
构造函数利用递归的思想，先跟的次序创建二叉树。**由于要利用到递归，就没有办法直接用构造函数来实现，因为在class之外是没有办法访问到_root的。所以通过一个函数，利用这个函数来实现递归的过程。**
构造出来的二叉树关系图：
![二叉树](http://p3ax8ersb.bkt.clouddn.com/201803061638_7.png-480.jpg)
### 拷贝构造
拷贝构造利用了一个`_CopyTree`函数。
```c++
BinaryTree(const BinaryTree& tree){
    _root = _CopyTree(tree._root);
}
Node* _CopyTree(Node* root){
    Node* node = root;
    if(node){
        node = new Node(root->_data);
        node->_left = _CopyTree(root->_left);
        node->_right = _CopyTree(root->_right);
    }
    return node;
}
```
### 析构函数
析构函数利用了一个`Destroy`函数
```c++
//destructor
~BinaryTree(){
    Destroy(_root);
}
void Destroy(Node* root){
    if(root == NULL)
        return;
    Destroy(root->_left);
    Destroy(root->_right);
    delete root;
}
```
### operator=(赋值运算符的重载)
先调用析构函数的`Destroy`销毁当前二叉树，然后调用`_CopyTree`重新构造当前二叉树。
```c++
//operator=
BinaryTree<T>& operator=(const BinaryTree<T>& tree){
    if(this != &tree){
        Destroy(_root);
        _root = _CopyTree(tree._root);
        return *this;
    }
}

//BinaryTree<T>& operator=(BinaryTree<T> tree){
    //if(this != &tree){
        //swap(_root, tree._root);
        //return *this;
    //}
//}
```
赋值运算符的重载有两种实现方式，第一种是传统写法，第二种是现代写法。传统写法就是销毁原来的空间，然后重新开辟新的空间。对内存的操作比较多。现代写法是利用拷贝构造的方式，**在传值进来的时候，生成一份临时拷贝**，然后交换当前二叉树和临时拷贝的根节点，返回根节点，同时利用临时拷贝的作用域，交换后的二叉树在出了当前函数之后被销毁。**相当于借用了系统的拷贝机制和自动析构机制来实现赋值的过程。**
## 递归遍历
### 先序遍历
先序遍历：`root left right`
```c++
//PrevOrder
void PrevOrder(){
    _PrevOrder(_root);
    cout << endl;
}
void _PrevOrder(Node* root){
    if(root){
        cout << root->_data << " ";
        _PrevOrder(root->_left);
        _PrevOrder(root->_right);
    }
    return;
}
```
### 中序遍历
中序遍历：`left root right`
```c++
//InOrder
void InOrder(){
    _InOreder(_root);
    cout << endl;
}
void _InOreder(Node* root){
    if(root){
        _InOreder(root->_left);
        cout << root->_data << " ";
        _InOreder(root->_right);
    }
    return;
}
```
### 后序遍历
后序遍历：`left root right`
```c++
//PostOrder
void PostOrder(){
    _PostOrder(_root);
    cout << endl;
}
void _PostOrder(Node* root){
    if(root){
        _PostOrder(root->_left);
        _PostOrder(root->_right);
        cout << root->_data << " ";
    }
    return;
}
```
## 非递归遍历
之所以要出现非递归遍历，是因为递归遍历有一定的缺陷。比如：当二叉树是一颗父节点只有一个子节点的树，那么对堆栈的使用就很大，**有可能出现堆栈使用太深而栈溢出的情况**。为了避免这种情况的出现，有必要使用非递归遍历。
**非递归遍历利用栈来实现对之前的结点的存储**，因为每一颗二叉树都有可能有左右子树，所以需要在访问单边的子树的时候，将结点保存下来，这样是为了之后可以返回去访问结点的另一边的子树。
### 层次遍历
层次遍历是一层一层的遍历结点的。它与之前三个的遍历方式都不一样。**他利用的是队列，通过队列让父节点带动子节点。**
```c++
//LevelOrder
void LevelOrder(){
    //不能是T，要用到root->_left; root->_right;
    //不好是Node，结构体太大;
    queue<Node*> q;
    if(_root){
        q.push(_root);
        while(!q.empty()){
            Node* top = q.front();
            //获取到队头之后，将当前结点pop
            q.pop();
            cout << top->_data << " ";
            //如果左右子树存在，就入队列
            if(top->_left)
                q.push(top->_left);
            if(top->_right)
                q.push(top->_right);
        }
    }
    cout << endl;
}
```
### 先序遍历非递归
根据先序遍历的特点，先输出当前结点，然后一路向左，访问完左边再返回访问上一个结点的右子树，这个就是子问题，利用上面一样的方法。
```c++
//PrevOrderNonR
void PrevOrderNonR(){
    //利用栈得以记录访问过的根，用来以后访问右子树
    stack<Node*> s;
    Node* cur = _root;
    while(cur || !s.empty()){
        //根据先根的次序，访问当前节点，并一路向左访问
        while(cur){
            cout << cur->_data << " ";
            s.push(cur);
            cur = cur->_left;
        }
        Node* top = s.top();
        //pop表示左子树已经访问完，接下来访问右子树
        s.pop();
        //右子树的访问是子问题
        cur = top->_right;
    }
    cout << endl;
}
```
### 中序遍历非递归
中序遍历和先序遍历唯一的不同就是先序遍历是访问当前结点就打印当前结点，中序遍历就是先走完左边，再回来获取结点，这个时候再输出。
```c++
//InOrderNonR
void InOrderNonR(){
    stack<Node*> s;
    Node* cur = _root;
    while(cur || !s.empty()){
        while(cur){
            s.push(cur);
            cur = cur->_left;
        }
        Node* top = s.top();
        s.pop();
        cout << top->_data << " ";
        cur = top->_right;
    }
    cout << endl;
}
```
### 后序遍历非递归
后序遍历相比于之前的有一个转弯，看下图：
![后序遍历非递归](http://p3ax8ersb.bkt.clouddn.com/201803061639_158.png-960.jpg)
所以为了区分这个点，先设立一个prev，prev指向当前结点cur的上一个结点。如果`prev == cur->_right`表示当前结点的右子树已经访问完成，那么就可以输出cur了。
```c++
//PostOrderNonR
void PostOrderNonR(){
    stack<Node*> s;
    Node* cur = _root;
    Node* prev = NULL;
    while(cur || !s.empty()){
        //一路向左走到底
        while(cur){
            s.push(cur);
            cur = cur->_left;
        }
        Node* top = s.top();
        //访问当前结点的两个条件
        //1、没有右子树
        //2、右子树已经访问完成
        if(top->_right == NULL || prev == top->_right){
            s.pop();
            //此时的top成为过去式，将top设置为prev
            prev = top;
            cout << top->_data << " ";
        }
        //此时表示右子树还没有访问
        else{
            cur = top->_right;
        }
    }
    cout << endl;
}
```
## 结点个数函数
以下函数都利用了递归的思想。
### 统计结点个数函数Size
```c++
//Size
size_t Size(){
    return _Size(_root);
}
size_t _Size(Node* root){
    if(root == NULL)
        return 0;
    return _Size(root->_left) + _Size(root->_right) + 1;
}
```
### 统计深度函数Depth
统计深度的时候，因为二叉树有左右子树，所以需要区分是左子树结点多还是右子树结点多。通过两个变量来记录，分别统计大小，然后再比较大小，大的是深度。
这里默认根节点是第一层
```c++
//Depth
size_t Depth(){
    return _Depth(_root);
}
size_t _Depth(Node* root){
    size_t leftnum = 0;
    size_t rightnum = 0;
    if(root == NULL)
        return 0;
    //如果存在就接着往下递归
    if(root->_left)
        leftnum += _Depth(root->_left);
    if(root->_right)
        rightnum += _Depth(root->_right);
    return (leftnum > rightnum ? leftnum : rightnum) + 1;
}
```
### 统计叶子结点个数的函数LeafSize
叶子结点的统计是在当前结点都没有左右子树的时候返回个数1。
```c++
//LeafSize
size_t LeafSize(){
    return _LeafSize(_root);
}
size_t _LeafSize(Node* root){
    if(root == NULL)
        return 0;
    if(root->_left == NULL && root->_right == NULL)
        return 1;
    return _LeafSize(root->_left) + _LeafSize(root->_right);
}
```
### 计算第K层的结点个数函数GetKLevel
这个函数可以**通过子问题的思想**来解决。比如：我要计算第三层，当指针在第一层的时候，是计算K=3；当指针在第二层的时候，是计算K=2；当指针在第三层的时候，是计算K=1的结点个数。所以只要当K=1的时候返回计算值1就好了。
```c++
//GetKLevel
size_t GetKLevel(size_t K){
    return _GetKLevel(_root, K);
}
size_t _GetKLevel(Node* root, size_t K){
    if(K == 0 || root == NULL)
        return 0;
    if(K == 1)
        return 1;
    //不能使用--K，应该用K-1。
    //不能返回除了K=1的其他情况。
    return _GetKLevel(root->_left, K - 1) + _GetKLevel(root->_right, K - 1);
}
```
## 测试代码
```c++
int a1[] = {1,2,3,'#','#',4,'#','#',5,6,'#','#','#'};
int a2[] = {1,2,'#',3,'#','#',4,5,'#',6,'#',7,'#','#',8,'#','#'};
BinaryTree<int> tree(a1,'#');
BinaryTree<int> tree1(a2, '#');
BinaryTree<int> tree2(tree);
tree2 = tree1;

cout << "tree.PrevOrder" << endl;
tree.PrevOrder();
cout << "tree1.InOrder" << endl;
tree1.InOrder();
cout << "tree2.PostOrder" << endl;
tree2.PostOrder();

cout << "tree.LevelOrder" << endl;
tree.LevelOrder();
cout << "tree.PrevOrderNonR" << endl;
tree.PrevOrderNonR();
cout << "tree1.InOrderNonR" << endl;
tree1.InOrderNonR();
cout << "tree2.PostOrderNonR" << endl;
tree2.PostOrderNonR();

cout << "tree.Size:" << tree.Size() << endl;
cout << "tree.Depth:" << tree.Depth() << endl;
cout << "tree.LeafSize:" << tree.LeafSize() << endl;
cout << "tree.GetKLevel(K=2):" << tree.GetKLevel(2) << endl;

cout << "tree1.Size:" << tree1.Size() << endl;
cout << "tree1.Depth:" << tree1.Depth() << endl;
cout << "tree1.LeafSize:" << tree1.LeafSize() << endl;
cout << "tree1.GetKLevel(K=3):" << tree1.GetKLevel(3) << endl;
```
截图如下：
![测试](http://p3ax8ersb.bkt.clouddn.com/201803061640_12.png-960.jpg)
二叉树的实现，最重要的是要掌握子问题的思想，通过子问题的思想来解决左右子树，只需要一个递归就好了。
