---
title: 复杂单链表的复制
date: 2018-01-31 14:54:57
tags:
categories:
    - "practice"
    - "C/C++"
---
## 题目:
有一个单链表，该链表节点有两个指针，一个`_next`指向下一个节点，另一个`_random`指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。

### 思路：
1. 单链表的复制比较简单，但是`_random`不好处理，如果`_random`指向前面的节点，我们该如何处理。`_random`还有可能是指向NULL，这种情况也需要单独处理。
<!--more-->
2. 为了解决这个问题，我们可以用一个比较巧妙的方法，对每一个节点都复制，同时插入到当前节点的后面。这样我们就得到了一个重复的链表，此时有一个优势，新`_random`就是原来`_random`的后一个。我们就不需要在考虑往前寻找的问题了。只需要找到当前节点的`_random`的`_next`就行。
3. 这样处理之后，我们就得到了一个新的链表，接着只需要进行拆分就好了。

### 看图如下：
创建了一个复杂链表
![复杂链表](http://p3ax8ersb.bkt.clouddn.com/201801311509_357.png)

进行对每一个节点的复制同时插入到原链表中
![复制并插入](http://p3ax8ersb.bkt.clouddn.com/201801311511_432.png)

### 给出节点的结构如下：
```c++
#define datatype int

typedef struct complexnode{
    complexnode(datatype val){
        _data = val;
        _next = NULL;
        _random = NULL;
    }
    datatype _data;
    complexnode* _next;
    complexnode* _random;
}comnode;
```

### 实现代码如下：
```c++
//主函数
comnode* copy_complex_list( comnode* head ){
    comnode* cur = head;
    comnode* next = cur->_next;
    if( cur == NULL )
        return NULL;

    //将每一个节点复制到当前节点的后面，并链入链表
    while( cur ){
        comnode* tmp = new comnode(cur->_data);
        cur->_next = tmp;
        tmp->_next = next;
        cur = next;
        //防止对NULL访问
        if( cur )
            next = cur->_next;
    }
    //将指针重置指向头结点
    cur = head;
    next = cur->_next;
    //给新链入的节点置random
    while( cur ){
        //分类处理_random为NULL的情况
        if( cur->_random )
            next->_random = cur->_random->_next;
        else
            next->_random = NULL;
        cur = next->_next;
        if( cur )
            next = cur->_next;
    }

    cur = head;
    next = cur->_next;
    comnode* result = next;
    //拆分两个链表
    while( cur ){
        cur->_next = next->_next;
        cur = cur->_next;
        if( cur ){
            next->_next = cur->_next;
            next = next->_next;
        }
    }
    return result;
}
//打印函数
void print_random( comnode* head ){
    comnode* cur = head;
    cout << "list:";
    while( cur ){
        cout << cur->_data << "->";
        cur = cur->_next;
    }
    cout << "NULL" << endl << "random:";
    cur = head;
    while( cur ){
        if( cur->_random )
            cout << cur->_random->_data << " ";
        else
            cout << "NULL" << " ";
        cur = cur->_next;
    }
    cout << endl;
}

int main(){
    comnode* head = new comnode(1);
    comnode* n1 = new comnode(2);
    comnode* n2 = new comnode(4);
    comnode* n3 = new comnode(5);
    comnode* n4 = new comnode(9);

    head->_next = n1;
    n1->_next = n2;
    n2->_next = n3;
    n3->_next = n4;
    n4->_next = NULL;

    head->_random = n2;
    n1->_random = head;
    n2->_random = n3;
    n3->_random = NULL;
    n4->_random = n4;

    system( "clear" );
    comnode* copy_list = copy_complex_list( head );
    print_random(head);
    cout << "copy_list:" << endl;
    print_random(copy_list);

    return 0;
}
```

### 运行结果如下：
同时打印了原来的链表和复制的链表
![打印结果](http://p3ax8ersb.bkt.clouddn.com/201801311519_393.png)

[CSDN上用C写的，同时也将各个部分功能进行了函数封装](http://blog.csdn.net/mac_timmy/article/details/78482792)
