---
title: 1+2+……+n的特殊求法
date: 2018-01-27 00:44:40
category:
    - "practice"
    - "C/C++"
---
## 题目：
**求1+2+3+...+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。**

自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&&的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。

### 更新：18.1.28
发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了[柔性数组](https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html)，这种数组的长度的可变的，不需要用常量定义。

<!-- more -->

```c++
class Solution{
    public:
        int Sum_Solution( int n ){
            bool a[n][n+1];
            return sizeof(a)>>1;
        }
};
int main(){
    Solution s;
    cout << s.Sum_Solution(10) << endl;
    return 0;
}
```

---
原文：
### 利用&&操作符，|| 也一样的做法。

思路：当result = 0 的时候，&&不再判断右操作数，递归停止。

```c++
int sum( int n ){
    int result = n;
    result && (result += sum(n-1));
    return result;
}
int main(){
    cout << sum(100) << endl;
    return 0;
}
```

### 利用构造函数以及静态成员变量
思路：构造N次对象，每次对静态变量sum++，对n赋值。利用静态变量对所有同类对象有效的特点。

```c++
class tmp{
public:
    //构造
    tmp( ){
        ++n;
        sum += n;
    }
    //初始化
    void static init(){
        n = 0;
        sum = 0;
    }
    //获得sum
    int static getsum(){
        return sum;
    }
private:
    static int n;
    static int sum;
};

int tmp::n = 0;
int tmp::sum = 0;
//运行的函数
int count(int n){
    tmp::init();
    tmp* a = new tmp[n];
    delete[] a;
    a = NULL;
    tmp::getsum();
}
int main(){
    cout << count(100) << endl;
    return 0;
}
```

### 利用虚函数、继承和函数指针
思路：
1. 定义两个类，A是基类，B是子类。
2. 定义一个`A* Array[2]`,其中Array[0]存放A对象的地址，Array[1]存放B对象的地址。
3. 调用函数Sum中调用Sum的递归。同时对变量n两次取反`Array[!!n]->Sum(n-1)+n`,这样当n不为0的时候，得到bool值1。`Array[!!n] = Array[1]`
4. 当n=0调用基类A的sum。充分利用虚函数参数与类型有关的性质。

```c++
//1、虚函数
#include <iostream>
using namespace std;
class A;
A* Array[2];
class A{
public:
    virtual int Sum( int n ){
        return 0;
    }
};
class B:public A{
public:
    virtual int Sum( int n ){
        //当 n != 0, !!n = 1
        return Array[!!n]->Sum(n-1)+n;
    }
};

int Sum2( int n ){
    A a;
    B b;
    Array[0] = &a;
    Array[1] = &b;
    //调用虚函数
    int value = Array[1]->Sum(n);
    return value;
}
int main(){
    cout << Sum2(100) << endl;
    return 0;
}

//2、同上，这里利用函数指针来实现。
typedef int (*fun)(int);

int Sum( int i ){
    return 0;
}
int Sum2( int i ){
    fun f[2] = { Sum, Sum2 };
    return i + f[!!n](i-1);
}
```

### 利用异常处理的机制
思路：try接收到的异常会在catch中捕获。

```c++
int sum(int n){
    try{
        //n = 2 的时候，出现异常，程序流跳转到catch
        int[] array = new int[n-2];
        return n+sum(n-1);
    }
    catch(Exception e){
        //返回1到上一个递归处，n = 2处。
        return 1;
    }
}
```

### 利用模板
思路：利用了模板的特化作为递归结束的条件，并借用枚举类型。

```c++
#include <iostream>
using namespace std;

template <unsigned N>
class Sum{
    public:
        enum{
            sum = N+Sum<N-1>::sum
        };
};
//模板特化，当N=1 的时候，调用
template<>
class Sum<1>{
    public:
        enum{
            sum = 1
        };
};
int main(){
    cout << Sum<100>::sum << endl;
    return 0;
}

```
### [方法来源地址](http://blog.csdn.net/u010993983/article/details/37730317)