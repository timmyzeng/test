{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next-1.png","path":"images/favicon-16x16-next-1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next-1.png","path":"images/favicon-32x32-next-1.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/love.js","path":"js/src/love.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"dd3bd3f1c3f2a5bdbea86dc241b589bbd2d5d998","modified":1518085939089},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1514806389000},{"_id":"source/baidu_verify_aF8IqoDm9Z.html","hash":"76e45f4650434a39bec5aba72b721b9a0a53a265","modified":1518835022037},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1514806389000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1514806389000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1514806389000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1514806389000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1514806389000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1514806389000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1514806389000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1514806389000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1514806389000},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1514806389000},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1514806389000},{"_id":"themes/next/_config.yml","hash":"c7f578d2c1d3bd340e2739898d3c67a67f624691","modified":1520910177859},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1514806389000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1514806389000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1514806389000},{"_id":"source/_drafts/浅读《STL源码剖析》笔记.md","hash":"9bd555d066f18c1d95167d8f2cc94a27dbf92c37","modified":1517629414829},{"_id":"source/_posts/1-……-n的特殊求法.md","hash":"c5658ac17aaf538c9b58635888813cf104d2bed1","modified":1518070815815},{"_id":"source/_posts/Linux中时间的设置.md","hash":"d6f621bb1e76ab9856435e509750490486337273","modified":1520512417661},{"_id":"source/_posts/Linux相关网站.md","hash":"1c62585f34ec12038b5d7d5b86f9796c323f64d0","modified":1518143632783},{"_id":"source/_posts/static-const-integral-data-member在类中的初始化.md","hash":"9dd0c6366d943b77e98d5fb581cc0f8f63ec292d","modified":1518143816418},{"_id":"source/_posts/二叉树的基本实现.md","hash":"b35c8f3f1794751db5782f777378c75cc0b97cd1","modified":1520327814673},{"_id":"source/_posts/创建一个不能被继承的类.md","hash":"9938224646d6f1da56f4a798dfd43f02af6ed26d","modified":1519459484249},{"_id":"source/_posts/位运算实现Add.md","hash":"84bcb1e36901a39994b4ed7af8422db86d9d2ec5","modified":1518070827616},{"_id":"source/_posts/判断元素的入栈和出栈顺序是否一致.md","hash":"3e66c67f43646af4080f79f4a5c54bd3cb07145c","modified":1520408897619},{"_id":"source/_posts/复杂单链表的复制.md","hash":"e3099a94387a51c06e06084db55dc91cda6cb1dd","modified":1518070779885},{"_id":"source/_posts/智能指针.md","hash":"e2f7f448e42d800bcff5c6acd0c1c4bee2839b51","modified":1519631416314},{"_id":"source/_posts/模板与分离编译.md","hash":"fab98ce1d8445123cd348b912064fc86c81b48c8","modified":1519484310756},{"_id":"source/_posts/模板的类型萃取.md","hash":"e511b50c86f7177acc8f73d8b8a81e266e63092e","modified":1519464616478},{"_id":"source/_posts/查看Linux系统版本信息.md","hash":"4bfa8df981d1b2617d935978f8a6b6458798f31c","modified":1520497940222},{"_id":"source/_posts/浅读《STL源码剖析》笔记-1、2章.md","hash":"e25d599d4b05f36591b7d711af11b1fae25058f2","modified":1520325894368},{"_id":"source/_posts/浅读《More-Effective-C-》笔记.md","hash":"cd048f2d7f96784c9637543b77f6bed739e824a8","modified":1520344356574},{"_id":"source/_posts/浅读《STL源码剖析》笔记-3章.md","hash":"397afbab9130f3ed748e3e35afd30d6f71d905c8","modified":1520325864742},{"_id":"source/categories/index.md","hash":"c069ae29d74a0d796a4f4159266a28fac6a195f6","modified":1517050864502},{"_id":"source/_posts/浅读《STL源码剖析》笔记-4章-vector和list.md","hash":"8cdbea2839f184ebba67ffe226487331d092fd59","modified":1520325741511},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1514806389000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1514806389000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1514806389000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1514806389000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1514806389000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1514806389000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1514806389000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1514806389000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1514806389000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1514806389000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1514806389000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1514806389000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1514806389000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1514806389000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1514806389000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1514806389000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1514806389000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1514806389000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1514806389000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1514806389000},{"_id":"themes/next/layout/_layout.swig","hash":"b7d5d0713c7f9bcfa10e130690020bada3c1c337","modified":1516931163244},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1514806389000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1514806389000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1514806389000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1514806389000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1514806389000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1514806389000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1514806389000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1514806389000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1514806389000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1514806389000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1514806389000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1514806389000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"7cd061a3d9c54a507316fba1db7f651c78d7a15d","modified":1519484593668},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514806389000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1514806389000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1514806389000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1514806389000},{"_id":"themes/next/layout/_macro/post.swig","hash":"00ca04166bf1d867c0df9e87f47a29faf916eac8","modified":1516931565805},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"8880c076b7ba673b8fd79d8a9a3e92071028e32e","modified":1518107960227},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1514806389000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1514806389000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"9548b63af97016c03d61c1da590d98323a60e721","modified":1518922652524},{"_id":"themes/next/layout/_partials/head.swig","hash":"d62c758e53527de08f901bb4a003254f2a7fecb0","modified":1518836368694},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1514806389000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1514806389000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1514806389000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1514806389000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1514806389000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1514806389000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1514806389000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1514806389000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1514806389000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1514806389000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1514806389000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1514806389000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1514806389000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1514806389000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1514806389000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1514806389000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1514806389000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1514806389000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1514806389000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1514806389000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1514806389000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1514806389000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1514806389000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1514806389000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1514806389000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1514806389000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1514806389000},{"_id":"themes/next/source/images/avatar.jpg","hash":"d68f7eabc4407302d275fee0af248e1d1d943dc2","modified":1501839050765},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1514806389000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1514806389000},{"_id":"themes/next/source/images/favicon-16x16-next-1.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1514806389000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1514806389000},{"_id":"themes/next/source/images/favicon-32x32-next-1.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1514806389000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1514806389000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"a48b49389c1cb7c0b1aa4e41e369b0ab10c0cbf0","modified":1516941053857},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"05dd77762a2e99b871e894f999729c84fb044306","modified":1516941041372},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514806389000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1514806389000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514806389000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1514806389000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1514806389000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1514806389000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1514806389000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1514806389000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1514806389000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"a111bd99d49221e7ae5f45e0c449a9f92a5f4a7c","modified":1516942313736},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514806389000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1514806389000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1514806389000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1514806389000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"2be63fbbb8a0daee38853b944d69b33d5ed80d4e","modified":1519522813236},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1514806389000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1519488451122},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1514806389000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1514806389000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1514806389000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1514806389000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1514806389000},{"_id":"themes/next/source/js/src/love.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1516930228881},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1514806389000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1514806389000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1514806389000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1514806389000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1514806389000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1514806389000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1514806389000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1514806389000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1514806389000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1514806389000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1514806389000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1514806389000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1514806389000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1514806389000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1514806389000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1514806389000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1514806389000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1514806389000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1514806389000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1514806389000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"53a02db002bd1062f4b55684b4cc268df7be578f","modified":1517129757005},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1519488426805},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"7714f0af4432e04ad7cafc0a8c2dcdb72cbaa8ff","modified":1517812432485},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1514806389000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1514806389000},{"_id":"themes/next/source/images/background.jpg","hash":"7c6e9000de92d6bcf7a7ff852a25bc4f56016207","modified":1517803379333},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1514806389000},{"_id":"public/baidu_urls.txt","hash":"3596ac2e4ec07d615de2c344cfc1dd4a363f650d","modified":1520910197727},{"_id":"public/baidu_verify_aF8IqoDm9Z.html","hash":"9f89bf7a567966feb15c366f8f87e405356fcc80","modified":1520910197747},{"_id":"public/baidusitemap.xml","hash":"e00a534988716bf6ed6c87eb84e09895b14e143e","modified":1520910197747},{"_id":"public/atom.xml","hash":"1c82e904ffff3727812ee11745b7dcd9555aaf59","modified":1520910197747},{"_id":"public/search.xml","hash":"08b04bff5ce3bbb6f6e077a4fb627408973e33f1","modified":1520910197747},{"_id":"public/content.json","hash":"9517d653b514cfe8f26755d2756be91ac526ca75","modified":1520910197747},{"_id":"public/sitemap.xml","hash":"cf1dbd47f78638eceefe49bfff1971385fc052aa","modified":1520910197747},{"_id":"public/categories/index.html","hash":"82ada30e76adacbab02b90982fddeeaf396daa63","modified":1520910197756},{"_id":"public/查看Linux系统版本信息.html","hash":"226a16a9c5fd1f670d6e2273168e40541c02d994","modified":1520910197756},{"_id":"public/Linux中时间的设置.html","hash":"ad4a12e7a57bb84554ca935de5b3f55a53f8e06b","modified":1520910197756},{"_id":"public/判断元素的入栈和出栈顺序是否一致.html","hash":"0a637dc48b6500863a96345f0fbebe9bde6c7a6f","modified":1520910197756},{"_id":"public/二叉树的基本实现.html","hash":"56267f59f59525a120539f0d1b05477f5fe3859a","modified":1520910197756},{"_id":"public/智能指针.html","hash":"039c33d3c769ba9602c02d60b19c65c2b3b433b7","modified":1520910197756},{"_id":"public/模板的类型萃取.html","hash":"b6ef23b989c4c3a3061792577c4a474a0b766fb6","modified":1520910197756},{"_id":"public/模板与分离编译.html","hash":"5986074bfad23a54239ab17e2a63872f615d357a","modified":1520910197756},{"_id":"public/浅读《STL源码剖析》笔记-4章-vector和list.html","hash":"c2195d44cf59dc99685daf954907ab8479df0c79","modified":1520910197757},{"_id":"public/浅读《STL源码剖析》笔记-3章.html","hash":"0adf5be2e733dd0f5259c544e1024ed494516e91","modified":1520910197757},{"_id":"public/浅读《STL源码剖析》笔记-1、2章.html","hash":"3431a4b3c8cec03da3017e94217e6a66069bd42a","modified":1520910197757},{"_id":"public/复杂单链表的复制.html","hash":"9ffe82fc27a8951d6cbe6628f34a70cabc5c633c","modified":1520910197757},{"_id":"public/浅读《More-Effective-C-》笔记.html","hash":"b287ecbaa975a8296570c162d592d43387342e72","modified":1520910197757},{"_id":"public/static-const-integral-data-member在类中的初始化.html","hash":"37dec54678aa11b1d5d62c2c83805d979f7c9d03","modified":1520910197757},{"_id":"public/创建一个不能被继承的类.html","hash":"f884d15837116e683352fafdbef70c7ff7151e89","modified":1520910197757},{"_id":"public/位运算实现Add.html","hash":"47580577b74ba89de196c2eceb08c336b54520d2","modified":1520910197757},{"_id":"public/1-……-n的特殊求法.html","hash":"a40664dd3ef663b02bdac1b367c0fb25802ab6c4","modified":1520910197758},{"_id":"public/archives/index.html","hash":"2bd784a3aa61d57ced8b9ba0a962ea48f301d039","modified":1520910197758},{"_id":"public/Linux相关网站.html","hash":"59cb0210f82a259a19dea13c3cdd55b65828bfc4","modified":1520910197758},{"_id":"public/archives/2018/01/index.html","hash":"0fc8a16022f9a48ae0ad4c7fc4874e1a3cb4015c","modified":1520910197758},{"_id":"public/archives/2018/index.html","hash":"13a6c99badf272e0dced2fd91d32099f973f2c31","modified":1520910197758},{"_id":"public/archives/2018/02/index.html","hash":"af2069033276caf61dd230da1c727bde6424a5a3","modified":1520910197758},{"_id":"public/categories/learning/index.html","hash":"02617c050eafa8bfaab21b4534f5b3b44f4e696c","modified":1520910197758},{"_id":"public/archives/2018/03/index.html","hash":"56dcc910c32efb12d35020a9d7a7694482793805","modified":1520910197758},{"_id":"public/categories/practice/index.html","hash":"7477bdd59a1c85565fed2206987dd2edd0bfe13f","modified":1520910197758},{"_id":"public/categories/网站收集/index.html","hash":"07af3e50e85e5055b9379357a771223db2a0b7c0","modified":1520910197758},{"_id":"public/categories/Linux/index.html","hash":"273c8ff650426988d6795f485f025002e0f8a521","modified":1520910197758},{"_id":"public/categories/practice/C-C/index.html","hash":"1eb0a139174e80efbf8770952d97eb769b666f88","modified":1520910197759},{"_id":"public/categories/knowledge/index.html","hash":"bfea4d75084d90ad8fa18511fc88a666f52573ae","modified":1520910197759},{"_id":"public/categories/Linux/method/index.html","hash":"cd69bafebc73bd1fb88580f8c6829abf631616ed","modified":1520910197759},{"_id":"public/index.html","hash":"691f25e19d513ef8a7ed99ad1a26fd64baf59fff","modified":1520910197759},{"_id":"public/categories/knowledge/C-C/index.html","hash":"9c5a0cb6a684fea66c5492a13fc8379cccab2fb6","modified":1520910197759},{"_id":"public/page/2/index.html","hash":"0174567608a5de0165565490a8443d4c899fe23c","modified":1520910197759},{"_id":"public/page/3/index.html","hash":"ebe98f7f21f2c93d3096af87f1eab8ca539be8d6","modified":1520910197759},{"_id":"public/CNAME","hash":"dd3bd3f1c3f2a5bdbea86dc241b589bbd2d5d998","modified":1520910197772},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1520910197772},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1520910197772},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1520910197772},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1520910197772},{"_id":"public/images/avatar.jpg","hash":"d68f7eabc4407302d275fee0af248e1d1d943dc2","modified":1520910197772},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1520910197772},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1520910197773},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1520910197773},{"_id":"public/images/favicon-16x16-next-1.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1520910197773},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1520910197773},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1520910197773},{"_id":"public/images/favicon-32x32-next-1.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1520910197773},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1520910197773},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1520910197773},{"_id":"public/images/favicon-16x16-next.png","hash":"a48b49389c1cb7c0b1aa4e41e369b0ab10c0cbf0","modified":1520910197773},{"_id":"public/images/favicon-32x32-next.png","hash":"05dd77762a2e99b871e894f999729c84fb044306","modified":1520910197773},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1520910197773},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1520910197773},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1520910197773},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1520910197773},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1520910197773},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1520910197773},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1520910197773},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1520910198429},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1520910198429},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1520910198431},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1520910198432},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1520910198432},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1520910198432},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1520910198432},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1520910198432},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1520910198432},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1520910198432},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1520910198432},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1520910198432},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1520910198432},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1520910198458},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1520910198458},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1520910198470},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1520910198470},{"_id":"public/js/src/love.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1520910198470},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1520910198470},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1520910198470},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1520910198470},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1520910198470},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1520910198470},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1520910198470},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1520910198470},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1520910198470},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1520910198470},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1520910198470},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1520910198470},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1520910198470},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1520910198471},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1520910198471},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1520910198471},{"_id":"public/css/main.css","hash":"1e2f933757ac995c71058e3cc771c355ffa8226a","modified":1520910198471},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1520910198471},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1520910198471},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1520910198471},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1520910198492},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1520910198493},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1520910198493},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1520910198493},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1520910198493},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1520910198493},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1520910198493},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1520910198493},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1520910198493},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1520910198493},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1520910198494},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1520910198494},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1520910198494},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1520910198494},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1520910198494},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1520910198494},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1520910198494},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1520910198494},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1520910198495},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1520910198495},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1520910198495},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1520910198495},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1520910198495},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1520910198495},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1520910198495},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1520910198495},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1520910198495},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1520910198495},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1520910198495},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1520910198496},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1520910198497},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1520910198498},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1520910198498},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1520910198498},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1520910198498},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1520910198498},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1520910198498},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1520910198498},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1520910198498},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1520910198498},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1520910198498},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1520910198498},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1520910198498},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1520910198499},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1520910198499},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1520910198499},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1520910198499},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1520910198499},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1520910198499},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1520910198499},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1520910198499},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1520910198499},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1520910198698},{"_id":"public/images/background.jpg","hash":"7c6e9000de92d6bcf7a7ff852a25bc4f56016207","modified":1520910198806}],"Category":[{"name":"learning","_id":"cjep2nqym000304d8496neorb"},{"name":"网站收集","_id":"cjep2nqyx000704d8i5tn7euz"},{"name":"practice","_id":"cjep2nqz2000b04d8ajvwvdxi"},{"name":"Linux","_id":"cjep2nqz7000f04d87b70d5pr"},{"name":"knowledge","_id":"cjep2nqz8000g04d8urjaqpfr"},{"name":"C/C++","parent":"cjep2nqz2000b04d8ajvwvdxi","_id":"cjep2nqzd000j04d87uyz9k6p"},{"name":"method","parent":"cjep2nqz7000f04d87b70d5pr","_id":"cjep2nqzh000o04d8riqwjz3t"},{"name":"C/C++","parent":"cjep2nqz8000g04d8urjaqpfr","_id":"cjep2nqzj000r04d8v7s7dykx"}],"Data":[],"Page":[{"layout":"false","_content":"aF8IqoDm9Z","source":"baidu_verify_aF8IqoDm9Z.html","raw":"---\nlayout: false\n---\naF8IqoDm9Z","date":"2018-02-17T02:37:02.037Z","updated":"2018-02-17T02:37:02.037Z","path":"baidu_verify_aF8IqoDm9Z.html","title":"","comments":1,"_id":"cjep2nqws000004d8ce68aj4p","content":"aF8IqoDm9Z","site":{"data":{}},"excerpt":"","more":"aF8IqoDm9Z"},{"title":"categories","date":"2018-01-27T09:16:23.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-01-27 17:16:23\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-01-27T11:01:04.502Z","path":"categories/index.html","layout":"page","_id":"cjep2nr64001604d8s9lrwbet","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"浅读《STL源码剖析》笔记","_content":"#### 1 STL概论与版本简介\n##### 1.2 STL六大组件\n1. 容器(containers):`vector,list,deque,set,map`,用来存放数据\n2. 算法(algorithms):`sort,search,copy,erase`\n3. 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，<!--more-->迭代器器将`operator*,operator++,operator--,operator->`等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。\n4. 仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。\n5. 配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。\n6. 配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。\n\n##### 1.5~1.8 STL版本之二\n1. P.J.Plauger (Microsoft Visual C++)\n2. SGI STL (Linux GCC)\n    C++标准规范下的C头文件: `cstdio,cstdlib,cstring`\n    C++标准程序库中不属于STL范畴: `stream,string`\n    STL标准头文件: `vector,deque,list,map,algorithm,functional`\n    C++Standard定案前，HP所规范的STL头文件: `vector.h,deque.h,list.h,algo.h,function.h`\n    SGI STL内部文件(STL真正实现于此): `stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h`\n\n##### 1.9 可能令你困惑的C++语法\n###### 1.9.2 临时对象的产生与运用\n临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。**STL中最常将此技巧用在仿函数(functor)中。**临时对象的生命周期只有这一行指令。\n###### 1.9.3 静态常量整数成员在class内部直接初始化\nclass内含有`const static integral data member`，我们可以直接给予初值。\n    ```c++\n    //1.9.3测试代码如下\n    template <typename T>\n    class testclass{\n    public:\n        static const int datai = 5;\n        static const long datal = 3L;\n        static const char datac = 'c';\n    };\n\n    int main(){\n        cout << testclass<int>::datai << endl;\n        cout << testclass<int>::datal << endl;\n        cout << testclass<int>::datac << endl;\n        return 0;\n    }\n    ```\n运行结果：\n![运行结果](http://p3ax8ersb.bkt.clouddn.com/201801291947_629.png)\n###### 1.9.5 前闭后开区间表示法[)\n**STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。**\n###### 1.9.6 function call操作符(operator())\nfunction call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。**如果你针对某个class进行operator()重载，它就成为一个仿函数。**\n    ```c++\n    //1.9.6测试代码如下\n    template <class T>\n    struct Add{\n        //重载了operator()\n        T operator()(const T&x, const T&y) const{\n            return x+y;\n        }\n    };\n    int main(){\n        Add<int> addxy;\n        system( \"clear\" );\n        //调用重载函数\n        cout << addxy(3,5) << endl;\n        //调用匿名对象\n        cout << Add<int>()(5,5) << endl;\n        return 0;\n    }\n    ```\n运行结果：\n![仿函数](http://p3ax8ersb.bkt.clouddn.com/201801292024_990.png)\n\n#### 2 空间配置器(allocator)\n空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。\n##### 2.2 具备此配置力的SGI空间配置器\n###### 2.2.1 SGI标准的空间配置器,std::allocator\nSGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：`vector<int,std::allocator<int>>`;SGI STL写法如下：`vector<int, std::aloc>`绝大多数情况下，我们都是使用缺省的空间配置器。\n###### 2.2.2 SGI特殊的空间配置器，std::alloc\n- SGI同时也配备了标准空间配置器`std::allocator`，但是这只是对C++的`operator new和operator delete`做了一层封装，效率低下，**SGI并不使用，只是为了向前兼容语法。**\n- **SGI自身使用的空间配置器是`std::alloc`**一般来说，我们习惯的C++内存操作和释放操作是这样的：\n    ```c++\n    class Foo{};\n    Foo* pf = new Foo;\n    delete pf;\n    ```\n    这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。**为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。**\n- STL的配置器(allocator)定于于`<memory>`，其中包含两个文件,一个是负责内存空间的配置与释放<stl_alloc.h>,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构<stl_construct.h>，定义了全局函数construct()和destroy()。\n\n###### 2.2.3 构造和析构基本工具:construct()和destroy()\n- construct()的实现如下：\n    ```c++\n    #include <new.h>    //使用placement new 需要这个头文件\n    template <class T1, class T2>\n    inline void construct(T1* p, const T2& value){\n        new (p) T1(value);  //使用了placement new;调用T1:T1(value);\n    }\n    ```\n    代码解释：`construct()`接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，**通过`placement new`实现**。\n- destroy()有两个版本，实现如下:\n    ```c++\n    //第一个版本，接受一个指针\n    template <class T>\n    inline void destroy(T* pointer){\n        pointer->~T();\n    }\n    //第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits<>求取最适当的措施。\n    template <class ForwardIterator>\n    inline void destroy(ForwardIterator first, ForwardIterator last){\n        __destroy(first, last, value_type(first));\n    }\n    //判断元素的数值型别(value type)是否有 trivial destructor\n    template <class ForwardIterator, class T>\n    inline void __destroy(ForwardIterator first, ForwardIterator last, T*){\n        typedef typename __type_traits<T>::has_trivial_destructor trivial_destructor;\n        __destroy_aux(first, last, trivial_destructor());\n    }\n    //如果元素的数值型别(value type)有non-truvial destructor，循环释放\n    template <class ForwardIterator>\n    inline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type){\n        for( ; first < last; ++first)\n            //调用第一个版本的destroy()\n            destroy(&* first);\n    }\n    //如果元素的数值型别(value type)有trivial destructor,函数什么也不做\n    template <class ForwardIterator, ForwardIterator, __true_type>{\n        inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type){}\n    }\n    //destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做\n    inline void desroy(char*, char*){}\n    inline void destroy(wchar_t*,wchar_t*){}\n    ```\n    代码解释：`destroy()`有两个版本，**第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可**。第二个版本接收first和last两个迭代器，准备将`[firat, last)`范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓`trivial destructor`),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，**这里首先利用`value_type()`获得迭代器所指对象的型别，再利用`__type_traits<T>`判断该型别的析构函数是否无关痛痒。若是`(__true_type)`，则什么都不做结束；若不是`(__false_type)`,这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的`destroy()`。**\n- construct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits<>在3.7节。![construct()和destroy()图解](http://p3ax8ersb.bkt.clouddn.com/201802011438_654.png)\n\n###### 2.2.4 空间的配置与释放，std::alloc\n- 对象构造前的空间配置和对象析构后的空间释放，由`<stl_alloc.h>`负责。\n    - 向 system heap 要求空间\n    - 考虑多线程(multi-threads)状态(这里不考虑多线程的情况)\n    - 考虑内存不足时的应变措施\n    - 考虑过多“小型区域”可能造成的内存碎片(fragment)问题\n- **C++内存配置的基本操作是:`:operator new()`，内存释放的基本操作是`::operator delete()`。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。**\n- 为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，**第一级配置器`(__malloc_alloc_template)`用malloc()和free()，第二级配置器`(__default_alloc_template)`看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池`memory bool`整理方式。**其中具体是开放了第一级配置器还是两级配置器都开放了由__USE_MEALLOC是否定义决定，定义了__USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。\n- 无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口`simple_alloc`，使其能够符合STL的接口规格。\n    ```c++\n    template <class T,class Alloc>\n    class simple_alloc{\n    public:\n        static T* allocate(size_t n){\n            return 0 == n?0 : (T*) Alloc::allocate(n* sizeof (T));\n        }\n        static T* allocate(void){\n            return (T*) Alloc::allocatte(sizeof (T));\n        }\n        static void dallocate(T* p, size_t n){\n            if(0 != n)\n                Alloc::deallocate(p, n*sizeof (T));\n        }\n        static void deallocat(T* p){\n            Alloc::deallocate(p, sizeof (T));\n        }\n    };\n    ```\n    内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。\n- 图解如下：\n    - 第一级配置器和第二级配置器：![第一级配置器和第二级配置器](http://p3ax8ersb.bkt.clouddn.com/201802011620_34.png)\n    - 包装接口和运用：![包装接口和运用](http://p3ax8ersb.bkt.clouddn.com/201802011647_747.png)\n\n接下来几节，暂时先压住……\n###### 2.2.5 第一级配置器 __malloc_alloc_template 剖析\n###### 2.2.6 第二级配置器__default_alloc_template 剖析\n###### 2.2.7 空间配置函数allocate()\n###### 2.2.8 空间释放函数 deallocate()\n###### 2.2.9 重新填充 free lists\n###### 2.2.10 内存池(memory pool)\n##### 2.3 内存基本处理工具\nSTL定义了五个全局函数，作用于未初始化化空间上：用于构造的`construct()`和析构的`destroy()`,另外三个是：`uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()`(定于于`<memory>`),分别对应于高层次函数`copy(),fill(),fill_n()`,这些都是STL的算法。\n###### 2.3.1 uninitialized_copy\n###### 2.3.2 uninitialized_fill\n###### 2.3.3 uninitialized_fill_n\n\n#### 3 迭代器(iterator)概念与traits编程技法\n迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式\n\n##### 3.1 迭代器设计思维\n**STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一**\n\n```c++\n//3.1举例说明迭代器的使用\n//find()的定义。\ntemplate <class InputIterator, chass T>\nInputIterator find( InputIterator first, InputIterator last, const T& value ){\n    while ( first != last && *first != value )\n        ++first;\n        return first;\n}\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    const int arraySiza = 7;\n    int ia[arraySiza] = { 0, 1, 2, 3, 4, 5, 6 };\n    vector<int> ivect(ia, ia+arraySiza);\n    //调用vector的iterator用于find()\n    vector<int>::iterator it1 = find(ivect.begin(), ivect.end(), 4);\n    if( it1 == ivect.end() )\n        cout << \"4 not found.\" << endl;\n    else\n        cout << \"4 found:\" << *it1 << endl;\n\n    it1 = find(ivect.begin(), ivect.end(), 8);\n    if( it1 == ivect.end() )\n        cout << \"8 not found.\" << endl;\n    else\n        cout << \"8 found\" << *it1 << endl;\n\n    return 0;\n}\n```\n运行结果：\n![迭代器](http://p3ax8ersb.bkt.clouddn.com/201802011511_588.png)\n\n##### 3.2 迭代器(ierator)是一种smart pointer\n**迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-> 进行重载工作。**\n以下，简单模拟一个list的结构，然后设计对应的iterator。\n```c++\n//listnode\ntemplate <typename T>\nclass ListItem{\npublic:\n    T value() const{ return _value; }\n    ListItem* next() const{ return _next; }\n    //...\nprivate:\n    T _value;\n    ListItem* _next; //单向链表(single linked list)\n};\n\n//list\ntemplate <typename T>\nclass List{\npublic:\n    void insert_front(T value); //省略实现\n    void insert_end(T value);   //省略实现\n    voide display(std::ostream &os = std::cout) const;//省略实现\n    //...\nprivate:\n    ListItem<T>* _end;\n    ListItem<T>* _front;\n    long _size;\n};\n```\n当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：\n```c++\n//iterator\ntemplate <class Item>//Item可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的operator++只适用于链表。\nstruct ListIter{\n    Item* ptr;  //保持与容器之间的一个联系\n    ListIter( Item* p = 0 )\n        :ptr(p)\n        {}\n    //不必实现copy ctor，因为编译器提供的缺省行为已经足够\n    //不必实现operator=，因为编译器提供的缺省行为已经足够\n    Item& operator*() const { return *ptr; }\n    Item* operator->() const { return ptr; }\n    //operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator)\n    //pre-increament operator\n    ListIter& operator++(){\n        ptr = ptr->next();\n        return *this;\n    }\n    //post-incteament operator\n    LostIter operator++(int){\n        ListIter tmp = *this;\n        ++*this;\n        return tmp;\n    }\n    bool operator==(const LostIter& i)const{ return ptr == i.ptr; }\n    bool operator!=(const LostIter& i)const{ return ptr != i.ptr; }\n}\n```\n接下来，将List和find()由ListIter粘合起来：\n```c++\nint main(){\n    List<int> mylist;\n    for( int i=0; i<5; ++i ){\n        mylist.insert_front(i);\n        mylist.insert_end(i+2);\n    }\n    mylist.displau();   //10( 4 3 2 1 0 2 3 4 5 6)\n    ListIter<ListItem<int> > begin(mylist.front());\n    ListIter<ListItem<int> > end;\n    ListIter<ListItem<int> > iter;\n\n    iter = find(begin, end, 3);\n    if( iter == end )\n        cout << \"not found\" << endl;\n    else\n        cout << \"found.\" << iter->value() << endl;\n    //执行结果：found.3\n\n    return 0;\n}\n```\n由于find() 函数以`*iter != value`来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 `ListIterm<int>`,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和`ListIterm<int>`。如下：\n```c++\ntemplate <typename T>\nbool operator!=(const ListItem<T>& item, T n){ return item.value() != n; }\n```\n##### 3.3 迭代器相应型别(associated types)\n当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：![function template的例子](http://p3ax8ersb.bkt.clouddn.com/201802011841_231.png)\n以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。\n##### 3.4 Traits 编程技法——STL源代码门钥\n- **value type：迭代器所指对象的型别。**上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的\"template参数推导机制\"推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：\n    ```c++\n    template <class T>\n    struct MyIter{\n        typedef T value_type;   //内嵌型别声明(nested type)\n        MyIter(T* p = 0)\n            :ptr(p)\n            {}\n        T& operator*() const { return *ptr; }\n        //...\n        T* ptr; //成员变量\n    };\n    template <class I>\n    typename I::value_type func( I ite ){ return *ite; }    //typename I::value_type  这是func的返回值型别；\n    //...\n    MyIter<int> ite(new int(8));\n    cout << func(ite);  //输出:8\n    ```\n    `typename I::value_type`必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。**加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。**\n- 这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 **偏特化(template partial specialization)**。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：\n    ```c++\n    //class template\n    template <typename T>\n    class C{    //这个泛化版本接受T为任何型别\n        //...\n    };\n    //prartial specialization\n    template <typename T>\n    class C<T*>{    //这个特化版本只适用于\"T 为原生指针\"的情况\n        //...\n    };\n    ```\n- 下面这个例子，**专门用来萃取迭代器的特性，value type正是迭代器的特性之一**\n    ```c++\n    template <class I>\n    struct iterator_traits{ //traits意思为“特性”\n        typedef typename I::value_type value_type;\n    };\n    ```\n    这样，前面那个func函数可以修改成这样。\n    ```c++\n    template <class I>\n    //typename iterator_traits<I>::value_type 是函数的返回型别\n    typename iterator_traits<I>::value_type func(I ite){ return *ite; }\n    ```\n    跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：\n    ```c++\n    template <class T>\n    struct iterator_traits<T*>{ //偏特化版本--迭代器是一个原生指针\n        typedef T value_type;\n    }\n    ```\n    此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的`iterator_traits<const int*>::value_type`得到的是const int。所以我们另外设计一个特化版本，让`const T*`转变为T*：\n    ```c++\n    template <class T>\n    struct iterator_traits<const T*>{   //偏特化版本，当迭代器是一个const指针的时候，\n        typedef T value_type;           //萃取出来的是T，而不是const T\n    };\n    ```\n    到这里为止，**不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。**\n- 图解iterator_traits：![iterator_traits](http://p3ax8ersb.bkt.clouddn.com/201802012217_572.png)\n- 常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：\n    ```c++\n    template <class I>\n    struct iterator_traits{\n        typedef typename I::iterator_category iterator_category;\n        typedef typename I::value_type value_type;\n        typedef typename I::difference_type difference_type;\n        typedef typename I::pointer pointer;\n        typedef typename I::reference reference;\n    };\n    ```\n    **其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。**\n\n本章先到这里，往下就是对STL原原本本的探究了。\n###### 3.4.1 value type 如上\n###### 3.4.2 difference type\n###### 3.4.3 reference type\n###### 3.4.4 pointer type\n###### 3.4.5 iterator_catrgory\n\n\n#### 4 序列式容器\n##### 4.1 容器的概观与分类\n![SGI STL的各个容器](http://p3ax8ersb.bkt.clouddn.com/201801311638_540.png)\n所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。\n##### 4.2 vector\n###### 4.2.1 vector概述\narray是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。\n###### 4.2.3 vector的迭代器\n由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。`vector<int> :: iterator ivite;vector<Shape> :: iterator svite;`其中 `ivite`的类型就是`int*`，`svite`的类型就是`Shape*` 。\n###### 4.2.4 vector的数据结构\n- vector的数据结构如下：\n    ```c++\n    template<class T, class Alloc = alloc>\n    class vecotr{\n        //...\n        protected:\n        //注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置\n            iterator start;             //表示目前使用空间的头部\n            iterator finish;            //表示目前使用空间的尾部\n            iterator end_of_storage;    //表示目前可用空间的尾部\n    }\n    ```\n- 为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。\n- 运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。\n\n###### 4.2.5 vector的构造与内存管理：constructor，push_back\npush_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。**因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。**push_back源代码节选如下：\n```c++\nvoid push_back( const T& x){\n    if( finish != end_of_storage ){\n        construct( finish, x );\n        ++finish;\n    }\n    else    //无备用空间\n    insert_aux(end(), x);\n}\n\ntemplate <class T, class Alloc>\nvoid vector<T, Alloc>::insert_aux( iterator positon, const T& x ){\n    if( finish != end_of_storage ){ //为什么还要再次判断\n        construct( finish, *(finish - 1));\n        ++finish;\n        T x_copy = x;\n        //不懂\n        copy_backward(position, finish - 2, finish - 1);\n        *position = x_copy;\n    }\n    else{   //无备用空间\n        const size_type old_size = size();\n        const size_type len = old_size != 0 ? 2*old_size : 1;\n        iterator new_start = data_allocator::allocatr(len); //实际配置空间\n        iterator new_finish = new_start;\n        try{\n            //将原来vector内容拷贝到新的vector\n            new_finish = uninitialized_copy(start, position, new_start);\n            //为新元素设定初值x\n            construct(new_finish, x);\n            ++new_finish;\n            //将安插点的原内容也拷贝过来//不懂\n            new_finish = uninitialized_copy(posiition, finish, new_finish);\n        }\n        catch(...){\n            //开辟失败\n            destroy(new_start, new_finish);\n            data_allocator::deallocate(new_start, len);\n            throw;\n        }\n        //析构并释放原vector\n        destory(begin(), end());\n        deallocate();\n        //调整迭代器，指向新的vector\n        start = new_start;\n        finish = new_finish;\n        end_of_storage = new_start+len;\n    }\n}\n```\n\n###### 4.2.6 vector的元素操作：pop_back, erase, clear, insert\n```c++\n//清除[first, last)中的元素\niterator erase(iterator first, iterator last){\n    iterator ii = copy(last, finish, first);    //copy是全局函数，第六章\n    destory(i, finish);\n    finish = finish - (last - first);\n    return first;\n}\n//清除某个位置上的元素\niterator erase(iterator position){\n    if(position + 1 != end())\n        copy(position + 1, finish, position);\n    --finish;\n    destroy(finish);\n    return position;\n}\n\nvoid clear(){ erase(begin(), end()); }\n\n//从position开始，插入n个元素，元素初值为x\ntemplate <class T, class Alloc>\nvoid vector<T, Alloc>::insert(iterator position, size_type n ,const T& x){\n    if(n != 0){\n        //备用空间大于等于新增元素个数\n        if(size_type(end_of_storage - finish) >= 0){\n            T x_copy = x;\n            //计算插入点之后的现有元素个数\n            const size_type elems_after = finish - position;\n            iterator old_finish = finish;\n            if(elems_after > n){    //插入点之后的现有元素个数 > 新增元素个数\n                uninitialized_copy(finish - n, finish, finish);\n                finish += n;    //将vector 尾端标记后移\n                copy_backward(position, old_finish - n, old_finish);\n                fill(position, position+n, x_copy); //从插入点开始填入新值\n            }\n            else{\n                uninitialized_fill_n(finish, n-elems_affter, x_copy);\n                finish += n - elems_after;\n                uninitialized_copy(position, old_finish, finish);\n                finish += elems_after;\n                fill(position, old_finish, x_copy);\n            }\n        }\n        else{   //备用空间 < 新增元素个数\n            const size_type old_size = size();\n            //决定新的长度为旧长度+新增元素个数\n            const size_type len = old_size + max(old_size, n);\n            //配置新的vector空间\n            iterator new_start = data_allocaator::allocate(len);\n            iterator new_finish = new_start;\n            __STL_TRY{  //<-- 这个是什么\n                //将旧的vector在插入点之前的元素复制到新空间\n                new_finish = uninitialized_copy(start, position, new_start);\n                //将新增元素(初值为x)填入新空间\n                new_finish = uninitialized_fill_n(new_finish, n, x);\n                //将旧的vector在插入点之后的元素复制到新空间\n                nwe_finish = uninitialized_copy(position, finish, new_finish);\n            }\n            //异常处理\n            //...\n\n            //清除释放旧的空间\n            destroy(start，finish);\n            deallocate();\n            //调整迭代器指向新的空间\n            start = new_start;\n            finish = new_finish;\n            end_of_storage = new_start+len;\n        }\n    }\n}\n//插入操作完成之后，新增节点应位于position的后面。\n```\n图解如下：![insert](http://p3ax8ersb.bkt.clouddn.com/201802021439_772.png)\n##### 4.3 list\n###### 4.3.1 list概述\nlist每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。\n###### 4.3.2 list的节点(node)\nlist的节点和list本身的设计是分开的。以下是STL list的节点结构：\n```c++\ntemplate <class T>\nstruct __list_node{\n    typedef void* void_pointer;\n    void_pointer prev;  //型别为void*，其实可以是__list_node<T>\n    void_pointer next;\n    T data;\n}\n//这是一个双向链表节点\n```\n###### 4.3.3 list的迭代器\n**list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效**\n###### 4.3.4 list的数据结构\nSGI list 是一个双向循环链表。list结构如下：\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list{\nprotected:\n    typedef __list_node<T> list_node;\npublic:\n    typedef list_node* link_type;\nprotected:\n    link_type node;\n}\n```\n**STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。**\n```c++\niterator begin() { return (link_type)((*node).next); }\niterator end() { return node; }\nbool empty() const { return node->next == node; }\nsize_type size() const {\n    size_type result = 0;\n    distance(begin(), end(), result);   //全局函数，第三章//计算两个迭代器之间的距离\n    return result;\n}\nreference front() { return *begin(); }\nreference back() { return *(--end()); }\n```\n图解如下：![list](http://p3ax8ersb.bkt.clouddn.com/201802021641_929.png)\n\n###### 4.3.5 list的构造与内存管理：constructor， push_back, insert\nlist缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。`list_node_alloctor(n)`表示配置n个节点空间。同时有四个函数，如下：\n```c++\n//配置一个节点并传回\nlink_type get_node();\n//释放一个节点\nvoid put_node(link_type p);\n//配置并构造一个节点，带有元素值\nlink_type create_node(const T& x);\n//析构并释放一个节点\nvoid destroy_node(link_type p);\n```\nlist众多构造函数中，有一个允许我们构造一个空list出来：\n```c++\npublic:\n    list(){ empty_initialize(); }\nprotected:\n    void empty_initialize(){\n        //next、prev指针都指向自己\n        node = get_node();\n        node->next = node;\n        node->prev = node;\n    }\n```\n空节点对象模型：![空节点](http://p3ax8ersb.bkt.clouddn.com/201802021656_767.png)\n当我们用push_back()插入新节点的时候，函数内部调用insert()`void push_back(const T& x) { inset( end(), x ); }`insert()有很多的重载函数，最简单的如下:\n```c++\n//在迭代器position所指位置插入一个节点，值为x\niterator insert(iterator position, const T& x){\n    link_type tmp = create_node(x);\n    //插入位置在position之前,这是STL规范。\n    tmp->next = position.node;\n    tmp->prev = position.node->prev;\n    (link_type(position.node->node->prev))->next = tmp;\n    position.node->prev = tmp;\n    return tmp;\n}\n```\n###### 4.3.6 list的元素操作：`push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort`\npush_front, push_back复用insert；pop_front, pop_back复用erase。\n```c++\n//移除迭代器position所指节点\niterator erase(iterator position){\n    link_type next_node = link_type(position.node->next);\n    link_type prev_node = link_type(position.node->prev);\n    prev_node->next = next_node;\n    next_node->prev = prev_node;\n    destroy_node(position.node);\n    return iterator(next_node);\n}\n//清除所有节点\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::clear(){\n    link_type cur = (link__type) node->next;    //begin();\n    while( cur != node ){\n        link_type tmp - cur;\n        cur = (link_type)cur->next;\n        destroy_node(tmp);\n    }\n    //恢复成空节点的初始结构\n    node->next = node;\n    node->prev = node;\n}\n//将数值为value的所有元素移除\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::remove(const T& value){\n    iterator first = begin();\n    iterator last = end();\n    while(first != last){\n        iterator next = first;\n        ++next;\n        if(*first == value) erase(first);\n        first = next;\n    }\n}\n//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个\n//很帅啊\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::unique(){\n    iterator first = begin();\n    iterator last = end();\n    if(first == last) return;   //判空\n    iterator next = first;\n    while(++next != last){\n        if(*first == *next)\n            erase(next);\n        else\n            first = next;\n        next = first;\n    }\n}\n```\nlist 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。\n```c++\nprotected:\n    //将[first, last)内的所有元素移动到position之前。\n    void transfer(iterator position, iterator first, iterator last){\n        if(position != last){\n            //先处理各节点的next\n            (*(link_type((*last.node).prev))).next = position.node;\n            (*(link_type((*first.node).prev))).next = last.node;\n            (*(link_type((*position.node).prev))).next = first.node;\n            //tmp为position的prev节点\n            link_type tmp = link_type((*position.node).prev);\n            //处理各节点的prev\n            (*position.node).prev = (*last.node).prev;\n            (*last.node).prev = (*first.node).prev;\n            (*first.node).prev = tmp;\n        }\n    }\n```\nsplice各个版本：\n```c++\npublic:\n    //将list x接合与position所指位置之前，x必须不同于*this\n    void splice(iterator position, list& x){\n        if(!x.empty())\n            transfer(position, x.begin(), x.end());\n    }\n    //将i 所指元素接合于position所指元素之前。position和i可指向同一个list\n    void splice(iterator position, list&, iterator i){\n        iterator j = i;\n        ++j;\n        if(position == i || position == j) return;\n        trasfer(position, i, j);\n    }\n    //将[first, last)内的所有元素接合于position所指位置之前，\n    //position和[first, last)可指向同一个list。\n    //但是position不能在[first, last)范围之内\n    void splice(iterator posiition, list&, iterator first, iterator last){\n        if(first != last)\n            transfer(position, first, last);\n    }\n```\nmerge(), reverse(), sort()源码：\n```c++\n//merge()将x合并到*this上，两个list必须是递增排序的\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::merge(list<T, Alloc>& x){\n    iterator first1 = begin();\n    iterator last1 = end();\n    iterator first2 = x.begin();\n    iterator last2 = x.end();\n    while(first1 != last1 && first2 != last2){\n        if(*first2 < *first1){\n            iterator next = first2;\n            transfer(first1, first2, ++next);\n            first2 = next;\n        }\n        else\n            ++first1;\n        if(first2 !=  last2) transfer(last1, first2,last2);\n    }\n}\n\n//reverse()将*this的内容逆置\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::reverse(){\n    //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢\n    if(node->next == node || link_type(node->next)->next == node)\n        return;\n    iterator first = begin();\n    ++first;\n    while(first != end()){\n        iterator old = first;\n        ++first;\n        transfer(begin(), old, first);\n    }\n}\n\n//list不能使用STL中的sort()算法，只能使用自己的sort()\n//因为STL的sort()只接受RamdonAccessIterator\n//本函数使用quick sort\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::sort(){\n     //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢\n    if(node->next == node || link_type(node->next)->next == node)\n        return;\n    //创建新的list空间，作为中介数据存放区\n    list<T, Alloc> carry;\n    list<T, Alloc> counter[64];\n    int fill = 0;\n    while(!empty()){\n        carry.splice(carry.begin(), *this, begin());\n        int i = 0;\n        while(i < fill && !counter[i].empty()){\n            counter[i].merge(carry);\n            carry.swap(counter[i++]);\n        }\n        carry.swap(counter[i]);\n        if(i == fill)\n            ++fill;\n    }\n    for(int i = 1; i < fill; ++i)\n        counter[i].merge(counter[i-1]);\n    swap(counter[fill-1]);\n}\n```\n##### 4.4 deque\n###### 4.4.1 deque概述\ndeque是双向开口的连续性空间。可以在头尾两端分贝做元素的插入和删除操作。vector从技术层面也可以实现，但是头部操作效果奇差。\n![deque](http://p3ax8ersb.bkt.clouddn.com/201802021818_269.png)\ndeque和vector的最大区别在于二：一是deque对头部的常数时间操作。二是deque没有capacity的概念，因为deque是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。\n###### 4.4.2 deque的中控器\ndeque是由一段一段的定量连续空间构成。deque的最大任务就是，在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存储的接口。避开了vector那样的重新分配、复制、释放的轮回，而是以复杂的迭代器架构为代价。\n\ndeque采用一块所谓的map(非STL中的map容器)作为主控。这个map是一块连续空间，其中每个元素(称为节点node)都是指针，指向另一段较大的连续线性空间(缓冲区)。缓冲区才是deque的存储空间主题。SGI STL允许我们指定缓冲区的大小，默认值0代表使用512bytes缓冲区。结构如下：\n```c++\ntemplate <class T, class Alloc=alloc, size_t BufSiz = 0>\nclass deque {\npublic:\n    typedef T value_type;\n    typedef value_type* pointer;\n    //...\nprotected:\n    //元素的指针的指针\n    typedef pointer* map_pointer;\n    map_pointer map;    //指向map，map是一个连续空间，\n                        //每一个元素是一个指针(称为节点)，指向一块缓冲区\n    size_type map_size; //指定map可以容纳多少指针\n}\n```\n**map是一个二级指针，指向型别是T**。见图解：\n![map](http://p3ax8ersb.bkt.clouddn.com/201802031030_124.png)\n###### 4.4.3 deque的迭代器\n维持deque是一块连续空间的假象，用迭代器的operator++和operator--实现。迭代器起码要实现两个功能：一、可以指出分段连续空间(缓冲区)在哪里。二、能够判断是否处于缓冲区的边缘，如果是，向前移动或向后移动可以跳到上一个缓冲区或下一个缓冲区。需要正确跳段，需要掌控map。结构如下：\n```c++\ntemplate <class T, class Ref, class Ptr, size_t BufSiz>\nstruct __deque_iterator{\n    typedef __deque_iterator<T, Ref, Ptr, BufSiz> iterator;\n    typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;\n    static size_t buffer_size() { return __deque_buf_size(BufSiz, sizeof(T)); }\n\n    //没有继承std::iterator,所以需要自己写五个必要的迭代器相应型别(第三章)\n    typedef random_access_iterator_tag iterator_category;   //1\n    typedef T value_type;   //2\n    typedef Ptr pointer;    //3\n    typedef Ref reference;  //4\n    typedef ptrdiff_t difference_type;  //5\n\n    typedef size_t size_type;\n    typedef T** map_pointer;\n    typedef __deque_iterator self;\n\n    //保持与容器的联系\n    T* cur;     //当前缓冲区中当前元素\n    T* first;   //当前缓冲区的头\n    T* last;    //当前缓冲区的尾\n    map_pointer node;   //指向中控器map\n    //...\n}\n//上段决定缓冲区大小的函数buffer_size()，调用__deque_buf_size(),这是一个全局函数，如下：\n//当n不为0，传回n，表示buffer_size用户自定义了\n//当n为0，buffer_size使用默认值\ninline size_t __deque_buf_size(size_t n, size_t sz){\n    return n != 0 ? n : (sz < 512 ? size_t(512 / sz) : size_t(1));\n}\n```\n下图是deque的中控器，缓冲区，迭代器的相互关系：\n![deque的中控器，缓冲区，迭代器的相互关系](http://p3ax8ersb.bkt.clouddn.com/201802031110_957.png)","source":"_drafts/浅读《STL源码剖析》笔记.md","raw":"---\ntitle: 浅读《STL源码剖析》笔记\ntags:\ncategories:\n    - \"learning\"\n---\n#### 1 STL概论与版本简介\n##### 1.2 STL六大组件\n1. 容器(containers):`vector,list,deque,set,map`,用来存放数据\n2. 算法(algorithms):`sort,search,copy,erase`\n3. 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，<!--more-->迭代器器将`operator*,operator++,operator--,operator->`等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。\n4. 仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。\n5. 配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。\n6. 配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。\n\n##### 1.5~1.8 STL版本之二\n1. P.J.Plauger (Microsoft Visual C++)\n2. SGI STL (Linux GCC)\n    C++标准规范下的C头文件: `cstdio,cstdlib,cstring`\n    C++标准程序库中不属于STL范畴: `stream,string`\n    STL标准头文件: `vector,deque,list,map,algorithm,functional`\n    C++Standard定案前，HP所规范的STL头文件: `vector.h,deque.h,list.h,algo.h,function.h`\n    SGI STL内部文件(STL真正实现于此): `stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h`\n\n##### 1.9 可能令你困惑的C++语法\n###### 1.9.2 临时对象的产生与运用\n临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。**STL中最常将此技巧用在仿函数(functor)中。**临时对象的生命周期只有这一行指令。\n###### 1.9.3 静态常量整数成员在class内部直接初始化\nclass内含有`const static integral data member`，我们可以直接给予初值。\n    ```c++\n    //1.9.3测试代码如下\n    template <typename T>\n    class testclass{\n    public:\n        static const int datai = 5;\n        static const long datal = 3L;\n        static const char datac = 'c';\n    };\n\n    int main(){\n        cout << testclass<int>::datai << endl;\n        cout << testclass<int>::datal << endl;\n        cout << testclass<int>::datac << endl;\n        return 0;\n    }\n    ```\n运行结果：\n![运行结果](http://p3ax8ersb.bkt.clouddn.com/201801291947_629.png)\n###### 1.9.5 前闭后开区间表示法[)\n**STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。**\n###### 1.9.6 function call操作符(operator())\nfunction call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。**如果你针对某个class进行operator()重载，它就成为一个仿函数。**\n    ```c++\n    //1.9.6测试代码如下\n    template <class T>\n    struct Add{\n        //重载了operator()\n        T operator()(const T&x, const T&y) const{\n            return x+y;\n        }\n    };\n    int main(){\n        Add<int> addxy;\n        system( \"clear\" );\n        //调用重载函数\n        cout << addxy(3,5) << endl;\n        //调用匿名对象\n        cout << Add<int>()(5,5) << endl;\n        return 0;\n    }\n    ```\n运行结果：\n![仿函数](http://p3ax8ersb.bkt.clouddn.com/201801292024_990.png)\n\n#### 2 空间配置器(allocator)\n空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。\n##### 2.2 具备此配置力的SGI空间配置器\n###### 2.2.1 SGI标准的空间配置器,std::allocator\nSGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：`vector<int,std::allocator<int>>`;SGI STL写法如下：`vector<int, std::aloc>`绝大多数情况下，我们都是使用缺省的空间配置器。\n###### 2.2.2 SGI特殊的空间配置器，std::alloc\n- SGI同时也配备了标准空间配置器`std::allocator`，但是这只是对C++的`operator new和operator delete`做了一层封装，效率低下，**SGI并不使用，只是为了向前兼容语法。**\n- **SGI自身使用的空间配置器是`std::alloc`**一般来说，我们习惯的C++内存操作和释放操作是这样的：\n    ```c++\n    class Foo{};\n    Foo* pf = new Foo;\n    delete pf;\n    ```\n    这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。**为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。**\n- STL的配置器(allocator)定于于`<memory>`，其中包含两个文件,一个是负责内存空间的配置与释放<stl_alloc.h>,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构<stl_construct.h>，定义了全局函数construct()和destroy()。\n\n###### 2.2.3 构造和析构基本工具:construct()和destroy()\n- construct()的实现如下：\n    ```c++\n    #include <new.h>    //使用placement new 需要这个头文件\n    template <class T1, class T2>\n    inline void construct(T1* p, const T2& value){\n        new (p) T1(value);  //使用了placement new;调用T1:T1(value);\n    }\n    ```\n    代码解释：`construct()`接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，**通过`placement new`实现**。\n- destroy()有两个版本，实现如下:\n    ```c++\n    //第一个版本，接受一个指针\n    template <class T>\n    inline void destroy(T* pointer){\n        pointer->~T();\n    }\n    //第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits<>求取最适当的措施。\n    template <class ForwardIterator>\n    inline void destroy(ForwardIterator first, ForwardIterator last){\n        __destroy(first, last, value_type(first));\n    }\n    //判断元素的数值型别(value type)是否有 trivial destructor\n    template <class ForwardIterator, class T>\n    inline void __destroy(ForwardIterator first, ForwardIterator last, T*){\n        typedef typename __type_traits<T>::has_trivial_destructor trivial_destructor;\n        __destroy_aux(first, last, trivial_destructor());\n    }\n    //如果元素的数值型别(value type)有non-truvial destructor，循环释放\n    template <class ForwardIterator>\n    inline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type){\n        for( ; first < last; ++first)\n            //调用第一个版本的destroy()\n            destroy(&* first);\n    }\n    //如果元素的数值型别(value type)有trivial destructor,函数什么也不做\n    template <class ForwardIterator, ForwardIterator, __true_type>{\n        inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type){}\n    }\n    //destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做\n    inline void desroy(char*, char*){}\n    inline void destroy(wchar_t*,wchar_t*){}\n    ```\n    代码解释：`destroy()`有两个版本，**第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可**。第二个版本接收first和last两个迭代器，准备将`[firat, last)`范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓`trivial destructor`),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，**这里首先利用`value_type()`获得迭代器所指对象的型别，再利用`__type_traits<T>`判断该型别的析构函数是否无关痛痒。若是`(__true_type)`，则什么都不做结束；若不是`(__false_type)`,这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的`destroy()`。**\n- construct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits<>在3.7节。![construct()和destroy()图解](http://p3ax8ersb.bkt.clouddn.com/201802011438_654.png)\n\n###### 2.2.4 空间的配置与释放，std::alloc\n- 对象构造前的空间配置和对象析构后的空间释放，由`<stl_alloc.h>`负责。\n    - 向 system heap 要求空间\n    - 考虑多线程(multi-threads)状态(这里不考虑多线程的情况)\n    - 考虑内存不足时的应变措施\n    - 考虑过多“小型区域”可能造成的内存碎片(fragment)问题\n- **C++内存配置的基本操作是:`:operator new()`，内存释放的基本操作是`::operator delete()`。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。**\n- 为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，**第一级配置器`(__malloc_alloc_template)`用malloc()和free()，第二级配置器`(__default_alloc_template)`看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池`memory bool`整理方式。**其中具体是开放了第一级配置器还是两级配置器都开放了由__USE_MEALLOC是否定义决定，定义了__USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。\n- 无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口`simple_alloc`，使其能够符合STL的接口规格。\n    ```c++\n    template <class T,class Alloc>\n    class simple_alloc{\n    public:\n        static T* allocate(size_t n){\n            return 0 == n?0 : (T*) Alloc::allocate(n* sizeof (T));\n        }\n        static T* allocate(void){\n            return (T*) Alloc::allocatte(sizeof (T));\n        }\n        static void dallocate(T* p, size_t n){\n            if(0 != n)\n                Alloc::deallocate(p, n*sizeof (T));\n        }\n        static void deallocat(T* p){\n            Alloc::deallocate(p, sizeof (T));\n        }\n    };\n    ```\n    内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。\n- 图解如下：\n    - 第一级配置器和第二级配置器：![第一级配置器和第二级配置器](http://p3ax8ersb.bkt.clouddn.com/201802011620_34.png)\n    - 包装接口和运用：![包装接口和运用](http://p3ax8ersb.bkt.clouddn.com/201802011647_747.png)\n\n接下来几节，暂时先压住……\n###### 2.2.5 第一级配置器 __malloc_alloc_template 剖析\n###### 2.2.6 第二级配置器__default_alloc_template 剖析\n###### 2.2.7 空间配置函数allocate()\n###### 2.2.8 空间释放函数 deallocate()\n###### 2.2.9 重新填充 free lists\n###### 2.2.10 内存池(memory pool)\n##### 2.3 内存基本处理工具\nSTL定义了五个全局函数，作用于未初始化化空间上：用于构造的`construct()`和析构的`destroy()`,另外三个是：`uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()`(定于于`<memory>`),分别对应于高层次函数`copy(),fill(),fill_n()`,这些都是STL的算法。\n###### 2.3.1 uninitialized_copy\n###### 2.3.2 uninitialized_fill\n###### 2.3.3 uninitialized_fill_n\n\n#### 3 迭代器(iterator)概念与traits编程技法\n迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式\n\n##### 3.1 迭代器设计思维\n**STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一**\n\n```c++\n//3.1举例说明迭代器的使用\n//find()的定义。\ntemplate <class InputIterator, chass T>\nInputIterator find( InputIterator first, InputIterator last, const T& value ){\n    while ( first != last && *first != value )\n        ++first;\n        return first;\n}\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    const int arraySiza = 7;\n    int ia[arraySiza] = { 0, 1, 2, 3, 4, 5, 6 };\n    vector<int> ivect(ia, ia+arraySiza);\n    //调用vector的iterator用于find()\n    vector<int>::iterator it1 = find(ivect.begin(), ivect.end(), 4);\n    if( it1 == ivect.end() )\n        cout << \"4 not found.\" << endl;\n    else\n        cout << \"4 found:\" << *it1 << endl;\n\n    it1 = find(ivect.begin(), ivect.end(), 8);\n    if( it1 == ivect.end() )\n        cout << \"8 not found.\" << endl;\n    else\n        cout << \"8 found\" << *it1 << endl;\n\n    return 0;\n}\n```\n运行结果：\n![迭代器](http://p3ax8ersb.bkt.clouddn.com/201802011511_588.png)\n\n##### 3.2 迭代器(ierator)是一种smart pointer\n**迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-> 进行重载工作。**\n以下，简单模拟一个list的结构，然后设计对应的iterator。\n```c++\n//listnode\ntemplate <typename T>\nclass ListItem{\npublic:\n    T value() const{ return _value; }\n    ListItem* next() const{ return _next; }\n    //...\nprivate:\n    T _value;\n    ListItem* _next; //单向链表(single linked list)\n};\n\n//list\ntemplate <typename T>\nclass List{\npublic:\n    void insert_front(T value); //省略实现\n    void insert_end(T value);   //省略实现\n    voide display(std::ostream &os = std::cout) const;//省略实现\n    //...\nprivate:\n    ListItem<T>* _end;\n    ListItem<T>* _front;\n    long _size;\n};\n```\n当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：\n```c++\n//iterator\ntemplate <class Item>//Item可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的operator++只适用于链表。\nstruct ListIter{\n    Item* ptr;  //保持与容器之间的一个联系\n    ListIter( Item* p = 0 )\n        :ptr(p)\n        {}\n    //不必实现copy ctor，因为编译器提供的缺省行为已经足够\n    //不必实现operator=，因为编译器提供的缺省行为已经足够\n    Item& operator*() const { return *ptr; }\n    Item* operator->() const { return ptr; }\n    //operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator)\n    //pre-increament operator\n    ListIter& operator++(){\n        ptr = ptr->next();\n        return *this;\n    }\n    //post-incteament operator\n    LostIter operator++(int){\n        ListIter tmp = *this;\n        ++*this;\n        return tmp;\n    }\n    bool operator==(const LostIter& i)const{ return ptr == i.ptr; }\n    bool operator!=(const LostIter& i)const{ return ptr != i.ptr; }\n}\n```\n接下来，将List和find()由ListIter粘合起来：\n```c++\nint main(){\n    List<int> mylist;\n    for( int i=0; i<5; ++i ){\n        mylist.insert_front(i);\n        mylist.insert_end(i+2);\n    }\n    mylist.displau();   //10( 4 3 2 1 0 2 3 4 5 6)\n    ListIter<ListItem<int> > begin(mylist.front());\n    ListIter<ListItem<int> > end;\n    ListIter<ListItem<int> > iter;\n\n    iter = find(begin, end, 3);\n    if( iter == end )\n        cout << \"not found\" << endl;\n    else\n        cout << \"found.\" << iter->value() << endl;\n    //执行结果：found.3\n\n    return 0;\n}\n```\n由于find() 函数以`*iter != value`来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 `ListIterm<int>`,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和`ListIterm<int>`。如下：\n```c++\ntemplate <typename T>\nbool operator!=(const ListItem<T>& item, T n){ return item.value() != n; }\n```\n##### 3.3 迭代器相应型别(associated types)\n当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：![function template的例子](http://p3ax8ersb.bkt.clouddn.com/201802011841_231.png)\n以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。\n##### 3.4 Traits 编程技法——STL源代码门钥\n- **value type：迭代器所指对象的型别。**上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的\"template参数推导机制\"推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：\n    ```c++\n    template <class T>\n    struct MyIter{\n        typedef T value_type;   //内嵌型别声明(nested type)\n        MyIter(T* p = 0)\n            :ptr(p)\n            {}\n        T& operator*() const { return *ptr; }\n        //...\n        T* ptr; //成员变量\n    };\n    template <class I>\n    typename I::value_type func( I ite ){ return *ite; }    //typename I::value_type  这是func的返回值型别；\n    //...\n    MyIter<int> ite(new int(8));\n    cout << func(ite);  //输出:8\n    ```\n    `typename I::value_type`必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。**加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。**\n- 这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 **偏特化(template partial specialization)**。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：\n    ```c++\n    //class template\n    template <typename T>\n    class C{    //这个泛化版本接受T为任何型别\n        //...\n    };\n    //prartial specialization\n    template <typename T>\n    class C<T*>{    //这个特化版本只适用于\"T 为原生指针\"的情况\n        //...\n    };\n    ```\n- 下面这个例子，**专门用来萃取迭代器的特性，value type正是迭代器的特性之一**\n    ```c++\n    template <class I>\n    struct iterator_traits{ //traits意思为“特性”\n        typedef typename I::value_type value_type;\n    };\n    ```\n    这样，前面那个func函数可以修改成这样。\n    ```c++\n    template <class I>\n    //typename iterator_traits<I>::value_type 是函数的返回型别\n    typename iterator_traits<I>::value_type func(I ite){ return *ite; }\n    ```\n    跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：\n    ```c++\n    template <class T>\n    struct iterator_traits<T*>{ //偏特化版本--迭代器是一个原生指针\n        typedef T value_type;\n    }\n    ```\n    此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的`iterator_traits<const int*>::value_type`得到的是const int。所以我们另外设计一个特化版本，让`const T*`转变为T*：\n    ```c++\n    template <class T>\n    struct iterator_traits<const T*>{   //偏特化版本，当迭代器是一个const指针的时候，\n        typedef T value_type;           //萃取出来的是T，而不是const T\n    };\n    ```\n    到这里为止，**不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。**\n- 图解iterator_traits：![iterator_traits](http://p3ax8ersb.bkt.clouddn.com/201802012217_572.png)\n- 常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：\n    ```c++\n    template <class I>\n    struct iterator_traits{\n        typedef typename I::iterator_category iterator_category;\n        typedef typename I::value_type value_type;\n        typedef typename I::difference_type difference_type;\n        typedef typename I::pointer pointer;\n        typedef typename I::reference reference;\n    };\n    ```\n    **其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。**\n\n本章先到这里，往下就是对STL原原本本的探究了。\n###### 3.4.1 value type 如上\n###### 3.4.2 difference type\n###### 3.4.3 reference type\n###### 3.4.4 pointer type\n###### 3.4.5 iterator_catrgory\n\n\n#### 4 序列式容器\n##### 4.1 容器的概观与分类\n![SGI STL的各个容器](http://p3ax8ersb.bkt.clouddn.com/201801311638_540.png)\n所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。\n##### 4.2 vector\n###### 4.2.1 vector概述\narray是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。\n###### 4.2.3 vector的迭代器\n由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。`vector<int> :: iterator ivite;vector<Shape> :: iterator svite;`其中 `ivite`的类型就是`int*`，`svite`的类型就是`Shape*` 。\n###### 4.2.4 vector的数据结构\n- vector的数据结构如下：\n    ```c++\n    template<class T, class Alloc = alloc>\n    class vecotr{\n        //...\n        protected:\n        //注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置\n            iterator start;             //表示目前使用空间的头部\n            iterator finish;            //表示目前使用空间的尾部\n            iterator end_of_storage;    //表示目前可用空间的尾部\n    }\n    ```\n- 为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。\n- 运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。\n\n###### 4.2.5 vector的构造与内存管理：constructor，push_back\npush_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。**因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。**push_back源代码节选如下：\n```c++\nvoid push_back( const T& x){\n    if( finish != end_of_storage ){\n        construct( finish, x );\n        ++finish;\n    }\n    else    //无备用空间\n    insert_aux(end(), x);\n}\n\ntemplate <class T, class Alloc>\nvoid vector<T, Alloc>::insert_aux( iterator positon, const T& x ){\n    if( finish != end_of_storage ){ //为什么还要再次判断\n        construct( finish, *(finish - 1));\n        ++finish;\n        T x_copy = x;\n        //不懂\n        copy_backward(position, finish - 2, finish - 1);\n        *position = x_copy;\n    }\n    else{   //无备用空间\n        const size_type old_size = size();\n        const size_type len = old_size != 0 ? 2*old_size : 1;\n        iterator new_start = data_allocator::allocatr(len); //实际配置空间\n        iterator new_finish = new_start;\n        try{\n            //将原来vector内容拷贝到新的vector\n            new_finish = uninitialized_copy(start, position, new_start);\n            //为新元素设定初值x\n            construct(new_finish, x);\n            ++new_finish;\n            //将安插点的原内容也拷贝过来//不懂\n            new_finish = uninitialized_copy(posiition, finish, new_finish);\n        }\n        catch(...){\n            //开辟失败\n            destroy(new_start, new_finish);\n            data_allocator::deallocate(new_start, len);\n            throw;\n        }\n        //析构并释放原vector\n        destory(begin(), end());\n        deallocate();\n        //调整迭代器，指向新的vector\n        start = new_start;\n        finish = new_finish;\n        end_of_storage = new_start+len;\n    }\n}\n```\n\n###### 4.2.6 vector的元素操作：pop_back, erase, clear, insert\n```c++\n//清除[first, last)中的元素\niterator erase(iterator first, iterator last){\n    iterator ii = copy(last, finish, first);    //copy是全局函数，第六章\n    destory(i, finish);\n    finish = finish - (last - first);\n    return first;\n}\n//清除某个位置上的元素\niterator erase(iterator position){\n    if(position + 1 != end())\n        copy(position + 1, finish, position);\n    --finish;\n    destroy(finish);\n    return position;\n}\n\nvoid clear(){ erase(begin(), end()); }\n\n//从position开始，插入n个元素，元素初值为x\ntemplate <class T, class Alloc>\nvoid vector<T, Alloc>::insert(iterator position, size_type n ,const T& x){\n    if(n != 0){\n        //备用空间大于等于新增元素个数\n        if(size_type(end_of_storage - finish) >= 0){\n            T x_copy = x;\n            //计算插入点之后的现有元素个数\n            const size_type elems_after = finish - position;\n            iterator old_finish = finish;\n            if(elems_after > n){    //插入点之后的现有元素个数 > 新增元素个数\n                uninitialized_copy(finish - n, finish, finish);\n                finish += n;    //将vector 尾端标记后移\n                copy_backward(position, old_finish - n, old_finish);\n                fill(position, position+n, x_copy); //从插入点开始填入新值\n            }\n            else{\n                uninitialized_fill_n(finish, n-elems_affter, x_copy);\n                finish += n - elems_after;\n                uninitialized_copy(position, old_finish, finish);\n                finish += elems_after;\n                fill(position, old_finish, x_copy);\n            }\n        }\n        else{   //备用空间 < 新增元素个数\n            const size_type old_size = size();\n            //决定新的长度为旧长度+新增元素个数\n            const size_type len = old_size + max(old_size, n);\n            //配置新的vector空间\n            iterator new_start = data_allocaator::allocate(len);\n            iterator new_finish = new_start;\n            __STL_TRY{  //<-- 这个是什么\n                //将旧的vector在插入点之前的元素复制到新空间\n                new_finish = uninitialized_copy(start, position, new_start);\n                //将新增元素(初值为x)填入新空间\n                new_finish = uninitialized_fill_n(new_finish, n, x);\n                //将旧的vector在插入点之后的元素复制到新空间\n                nwe_finish = uninitialized_copy(position, finish, new_finish);\n            }\n            //异常处理\n            //...\n\n            //清除释放旧的空间\n            destroy(start，finish);\n            deallocate();\n            //调整迭代器指向新的空间\n            start = new_start;\n            finish = new_finish;\n            end_of_storage = new_start+len;\n        }\n    }\n}\n//插入操作完成之后，新增节点应位于position的后面。\n```\n图解如下：![insert](http://p3ax8ersb.bkt.clouddn.com/201802021439_772.png)\n##### 4.3 list\n###### 4.3.1 list概述\nlist每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。\n###### 4.3.2 list的节点(node)\nlist的节点和list本身的设计是分开的。以下是STL list的节点结构：\n```c++\ntemplate <class T>\nstruct __list_node{\n    typedef void* void_pointer;\n    void_pointer prev;  //型别为void*，其实可以是__list_node<T>\n    void_pointer next;\n    T data;\n}\n//这是一个双向链表节点\n```\n###### 4.3.3 list的迭代器\n**list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效**\n###### 4.3.4 list的数据结构\nSGI list 是一个双向循环链表。list结构如下：\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list{\nprotected:\n    typedef __list_node<T> list_node;\npublic:\n    typedef list_node* link_type;\nprotected:\n    link_type node;\n}\n```\n**STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。**\n```c++\niterator begin() { return (link_type)((*node).next); }\niterator end() { return node; }\nbool empty() const { return node->next == node; }\nsize_type size() const {\n    size_type result = 0;\n    distance(begin(), end(), result);   //全局函数，第三章//计算两个迭代器之间的距离\n    return result;\n}\nreference front() { return *begin(); }\nreference back() { return *(--end()); }\n```\n图解如下：![list](http://p3ax8ersb.bkt.clouddn.com/201802021641_929.png)\n\n###### 4.3.5 list的构造与内存管理：constructor， push_back, insert\nlist缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。`list_node_alloctor(n)`表示配置n个节点空间。同时有四个函数，如下：\n```c++\n//配置一个节点并传回\nlink_type get_node();\n//释放一个节点\nvoid put_node(link_type p);\n//配置并构造一个节点，带有元素值\nlink_type create_node(const T& x);\n//析构并释放一个节点\nvoid destroy_node(link_type p);\n```\nlist众多构造函数中，有一个允许我们构造一个空list出来：\n```c++\npublic:\n    list(){ empty_initialize(); }\nprotected:\n    void empty_initialize(){\n        //next、prev指针都指向自己\n        node = get_node();\n        node->next = node;\n        node->prev = node;\n    }\n```\n空节点对象模型：![空节点](http://p3ax8ersb.bkt.clouddn.com/201802021656_767.png)\n当我们用push_back()插入新节点的时候，函数内部调用insert()`void push_back(const T& x) { inset( end(), x ); }`insert()有很多的重载函数，最简单的如下:\n```c++\n//在迭代器position所指位置插入一个节点，值为x\niterator insert(iterator position, const T& x){\n    link_type tmp = create_node(x);\n    //插入位置在position之前,这是STL规范。\n    tmp->next = position.node;\n    tmp->prev = position.node->prev;\n    (link_type(position.node->node->prev))->next = tmp;\n    position.node->prev = tmp;\n    return tmp;\n}\n```\n###### 4.3.6 list的元素操作：`push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort`\npush_front, push_back复用insert；pop_front, pop_back复用erase。\n```c++\n//移除迭代器position所指节点\niterator erase(iterator position){\n    link_type next_node = link_type(position.node->next);\n    link_type prev_node = link_type(position.node->prev);\n    prev_node->next = next_node;\n    next_node->prev = prev_node;\n    destroy_node(position.node);\n    return iterator(next_node);\n}\n//清除所有节点\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::clear(){\n    link_type cur = (link__type) node->next;    //begin();\n    while( cur != node ){\n        link_type tmp - cur;\n        cur = (link_type)cur->next;\n        destroy_node(tmp);\n    }\n    //恢复成空节点的初始结构\n    node->next = node;\n    node->prev = node;\n}\n//将数值为value的所有元素移除\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::remove(const T& value){\n    iterator first = begin();\n    iterator last = end();\n    while(first != last){\n        iterator next = first;\n        ++next;\n        if(*first == value) erase(first);\n        first = next;\n    }\n}\n//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个\n//很帅啊\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::unique(){\n    iterator first = begin();\n    iterator last = end();\n    if(first == last) return;   //判空\n    iterator next = first;\n    while(++next != last){\n        if(*first == *next)\n            erase(next);\n        else\n            first = next;\n        next = first;\n    }\n}\n```\nlist 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。\n```c++\nprotected:\n    //将[first, last)内的所有元素移动到position之前。\n    void transfer(iterator position, iterator first, iterator last){\n        if(position != last){\n            //先处理各节点的next\n            (*(link_type((*last.node).prev))).next = position.node;\n            (*(link_type((*first.node).prev))).next = last.node;\n            (*(link_type((*position.node).prev))).next = first.node;\n            //tmp为position的prev节点\n            link_type tmp = link_type((*position.node).prev);\n            //处理各节点的prev\n            (*position.node).prev = (*last.node).prev;\n            (*last.node).prev = (*first.node).prev;\n            (*first.node).prev = tmp;\n        }\n    }\n```\nsplice各个版本：\n```c++\npublic:\n    //将list x接合与position所指位置之前，x必须不同于*this\n    void splice(iterator position, list& x){\n        if(!x.empty())\n            transfer(position, x.begin(), x.end());\n    }\n    //将i 所指元素接合于position所指元素之前。position和i可指向同一个list\n    void splice(iterator position, list&, iterator i){\n        iterator j = i;\n        ++j;\n        if(position == i || position == j) return;\n        trasfer(position, i, j);\n    }\n    //将[first, last)内的所有元素接合于position所指位置之前，\n    //position和[first, last)可指向同一个list。\n    //但是position不能在[first, last)范围之内\n    void splice(iterator posiition, list&, iterator first, iterator last){\n        if(first != last)\n            transfer(position, first, last);\n    }\n```\nmerge(), reverse(), sort()源码：\n```c++\n//merge()将x合并到*this上，两个list必须是递增排序的\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::merge(list<T, Alloc>& x){\n    iterator first1 = begin();\n    iterator last1 = end();\n    iterator first2 = x.begin();\n    iterator last2 = x.end();\n    while(first1 != last1 && first2 != last2){\n        if(*first2 < *first1){\n            iterator next = first2;\n            transfer(first1, first2, ++next);\n            first2 = next;\n        }\n        else\n            ++first1;\n        if(first2 !=  last2) transfer(last1, first2,last2);\n    }\n}\n\n//reverse()将*this的内容逆置\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::reverse(){\n    //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢\n    if(node->next == node || link_type(node->next)->next == node)\n        return;\n    iterator first = begin();\n    ++first;\n    while(first != end()){\n        iterator old = first;\n        ++first;\n        transfer(begin(), old, first);\n    }\n}\n\n//list不能使用STL中的sort()算法，只能使用自己的sort()\n//因为STL的sort()只接受RamdonAccessIterator\n//本函数使用quick sort\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::sort(){\n     //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢\n    if(node->next == node || link_type(node->next)->next == node)\n        return;\n    //创建新的list空间，作为中介数据存放区\n    list<T, Alloc> carry;\n    list<T, Alloc> counter[64];\n    int fill = 0;\n    while(!empty()){\n        carry.splice(carry.begin(), *this, begin());\n        int i = 0;\n        while(i < fill && !counter[i].empty()){\n            counter[i].merge(carry);\n            carry.swap(counter[i++]);\n        }\n        carry.swap(counter[i]);\n        if(i == fill)\n            ++fill;\n    }\n    for(int i = 1; i < fill; ++i)\n        counter[i].merge(counter[i-1]);\n    swap(counter[fill-1]);\n}\n```\n##### 4.4 deque\n###### 4.4.1 deque概述\ndeque是双向开口的连续性空间。可以在头尾两端分贝做元素的插入和删除操作。vector从技术层面也可以实现，但是头部操作效果奇差。\n![deque](http://p3ax8ersb.bkt.clouddn.com/201802021818_269.png)\ndeque和vector的最大区别在于二：一是deque对头部的常数时间操作。二是deque没有capacity的概念，因为deque是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。\n###### 4.4.2 deque的中控器\ndeque是由一段一段的定量连续空间构成。deque的最大任务就是，在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存储的接口。避开了vector那样的重新分配、复制、释放的轮回，而是以复杂的迭代器架构为代价。\n\ndeque采用一块所谓的map(非STL中的map容器)作为主控。这个map是一块连续空间，其中每个元素(称为节点node)都是指针，指向另一段较大的连续线性空间(缓冲区)。缓冲区才是deque的存储空间主题。SGI STL允许我们指定缓冲区的大小，默认值0代表使用512bytes缓冲区。结构如下：\n```c++\ntemplate <class T, class Alloc=alloc, size_t BufSiz = 0>\nclass deque {\npublic:\n    typedef T value_type;\n    typedef value_type* pointer;\n    //...\nprotected:\n    //元素的指针的指针\n    typedef pointer* map_pointer;\n    map_pointer map;    //指向map，map是一个连续空间，\n                        //每一个元素是一个指针(称为节点)，指向一块缓冲区\n    size_type map_size; //指定map可以容纳多少指针\n}\n```\n**map是一个二级指针，指向型别是T**。见图解：\n![map](http://p3ax8ersb.bkt.clouddn.com/201802031030_124.png)\n###### 4.4.3 deque的迭代器\n维持deque是一块连续空间的假象，用迭代器的operator++和operator--实现。迭代器起码要实现两个功能：一、可以指出分段连续空间(缓冲区)在哪里。二、能够判断是否处于缓冲区的边缘，如果是，向前移动或向后移动可以跳到上一个缓冲区或下一个缓冲区。需要正确跳段，需要掌控map。结构如下：\n```c++\ntemplate <class T, class Ref, class Ptr, size_t BufSiz>\nstruct __deque_iterator{\n    typedef __deque_iterator<T, Ref, Ptr, BufSiz> iterator;\n    typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;\n    static size_t buffer_size() { return __deque_buf_size(BufSiz, sizeof(T)); }\n\n    //没有继承std::iterator,所以需要自己写五个必要的迭代器相应型别(第三章)\n    typedef random_access_iterator_tag iterator_category;   //1\n    typedef T value_type;   //2\n    typedef Ptr pointer;    //3\n    typedef Ref reference;  //4\n    typedef ptrdiff_t difference_type;  //5\n\n    typedef size_t size_type;\n    typedef T** map_pointer;\n    typedef __deque_iterator self;\n\n    //保持与容器的联系\n    T* cur;     //当前缓冲区中当前元素\n    T* first;   //当前缓冲区的头\n    T* last;    //当前缓冲区的尾\n    map_pointer node;   //指向中控器map\n    //...\n}\n//上段决定缓冲区大小的函数buffer_size()，调用__deque_buf_size(),这是一个全局函数，如下：\n//当n不为0，传回n，表示buffer_size用户自定义了\n//当n为0，buffer_size使用默认值\ninline size_t __deque_buf_size(size_t n, size_t sz){\n    return n != 0 ? n : (sz < 512 ? size_t(512 / sz) : size_t(1));\n}\n```\n下图是deque的中控器，缓冲区，迭代器的相互关系：\n![deque的中控器，缓冲区，迭代器的相互关系](http://p3ax8ersb.bkt.clouddn.com/201802031110_957.png)","slug":"浅读《STL源码剖析》笔记","published":0,"date":"2018-02-03T03:33:06.260Z","updated":"2018-02-03T03:43:34.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nqyc000104d87h90nbre","content":"<h4 id=\"1-STL概论与版本简介\"><a href=\"#1-STL概论与版本简介\" class=\"headerlink\" title=\"1 STL概论与版本简介\"></a>1 STL概论与版本简介</h4><h5 id=\"1-2-STL六大组件\"><a href=\"#1-2-STL六大组件\" class=\"headerlink\" title=\"1.2 STL六大组件\"></a>1.2 STL六大组件</h5><ol>\n<li>容器(containers):<code>vector,list,deque,set,map</code>,用来存放数据</li>\n<li>算法(algorithms):<code>sort,search,copy,erase</code></li>\n<li>迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，<a id=\"more\"></a>迭代器器将<code>operator*,operator++,operator--,operator-&gt;</code>等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。</li>\n<li>仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。</li>\n<li>配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。</li>\n<li>配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</li>\n</ol>\n<h5 id=\"1-5-1-8-STL版本之二\"><a href=\"#1-5-1-8-STL版本之二\" class=\"headerlink\" title=\"1.5~1.8 STL版本之二\"></a>1.5~1.8 STL版本之二</h5><ol>\n<li>P.J.Plauger (Microsoft Visual C++)</li>\n<li>SGI STL (Linux GCC)<br> C++标准规范下的C头文件: <code>cstdio,cstdlib,cstring</code><br> C++标准程序库中不属于STL范畴: <code>stream,string</code><br> STL标准头文件: <code>vector,deque,list,map,algorithm,functional</code><br> C++Standard定案前，HP所规范的STL头文件: <code>vector.h,deque.h,list.h,algo.h,function.h</code><br> SGI STL内部文件(STL真正实现于此): <code>stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h</code></li>\n</ol>\n<h5 id=\"1-9-可能令你困惑的C-语法\"><a href=\"#1-9-可能令你困惑的C-语法\" class=\"headerlink\" title=\"1.9 可能令你困惑的C++语法\"></a>1.9 可能令你困惑的C++语法</h5><h6 id=\"1-9-2-临时对象的产生与运用\"><a href=\"#1-9-2-临时对象的产生与运用\" class=\"headerlink\" title=\"1.9.2 临时对象的产生与运用\"></a>1.9.2 临时对象的产生与运用</h6><p>临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。<strong>STL中最常将此技巧用在仿函数(functor)中。</strong>临时对象的生命周期只有这一行指令。</p>\n<h6 id=\"1-9-3-静态常量整数成员在class内部直接初始化\"><a href=\"#1-9-3-静态常量整数成员在class内部直接初始化\" class=\"headerlink\" title=\"1.9.3 静态常量整数成员在class内部直接初始化\"></a>1.9.3 静态常量整数成员在class内部直接初始化</h6><p>class内含有<code>const static integral data member</code>，我们可以直接给予初值。<br>    <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.9.3测试代码如下</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">testclass</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> datai = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">long</span> datal = <span class=\"number\">3L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> datac = <span class=\"string\">'c'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datai &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datal &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datac &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801291947_629.png\" alt=\"运行结果\"></p>\n<h6 id=\"1-9-5-前闭后开区间表示法\"><a href=\"#1-9-5-前闭后开区间表示法\" class=\"headerlink\" title=\"1.9.5 前闭后开区间表示法[)\"></a>1.9.5 前闭后开区间表示法[)</h6><p><strong>STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。</strong></p>\n<h6 id=\"1-9-6-function-call操作符-operator\"><a href=\"#1-9-6-function-call操作符-operator\" class=\"headerlink\" title=\"1.9.6 function call操作符(operator())\"></a>1.9.6 function call操作符(operator())</h6><p>function call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。<strong>如果你针对某个class进行operator()重载，它就成为一个仿函数。</strong><br>    <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.9.6测试代码如下</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">Add</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//重载了operator()</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp;x, <span class=\"keyword\">const</span> T&amp;y)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x+y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Add&lt;<span class=\"keyword\">int</span>&gt; addxy;</span><br><span class=\"line\">    system( <span class=\"string\">\"clear\"</span> );</span><br><span class=\"line\">    <span class=\"comment\">//调用重载函数</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; addxy(<span class=\"number\">3</span>,<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//调用匿名对象</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; Add&lt;<span class=\"keyword\">int</span>&gt;()(<span class=\"number\">5</span>,<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801292024_990.png\" alt=\"仿函数\"></p>\n<h4 id=\"2-空间配置器-allocator\"><a href=\"#2-空间配置器-allocator\" class=\"headerlink\" title=\"2 空间配置器(allocator)\"></a>2 空间配置器(allocator)</h4><p>空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。</p>\n<h5 id=\"2-2-具备此配置力的SGI空间配置器\"><a href=\"#2-2-具备此配置力的SGI空间配置器\" class=\"headerlink\" title=\"2.2 具备此配置力的SGI空间配置器\"></a>2.2 具备此配置力的SGI空间配置器</h5><h6 id=\"2-2-1-SGI标准的空间配置器-std-allocator\"><a href=\"#2-2-1-SGI标准的空间配置器-std-allocator\" class=\"headerlink\" title=\"2.2.1 SGI标准的空间配置器,std::allocator\"></a>2.2.1 SGI标准的空间配置器,std::allocator</h6><p>SGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：<code>vector&lt;int,std::allocator&lt;int&gt;&gt;</code>;SGI STL写法如下：<code>vector&lt;int, std::aloc&gt;</code>绝大多数情况下，我们都是使用缺省的空间配置器。</p>\n<h6 id=\"2-2-2-SGI特殊的空间配置器，std-alloc\"><a href=\"#2-2-2-SGI特殊的空间配置器，std-alloc\" class=\"headerlink\" title=\"2.2.2 SGI特殊的空间配置器，std::alloc\"></a>2.2.2 SGI特殊的空间配置器，std::alloc</h6><ul>\n<li>SGI同时也配备了标准空间配置器<code>std::allocator</code>，但是这只是对C++的<code>operator new和operator delete</code>做了一层封装，效率低下，<strong>SGI并不使用，只是为了向前兼容语法。</strong></li>\n<li><p><strong>SGI自身使用的空间配置器是<code>std::alloc</code></strong>一般来说，我们习惯的C++内存操作和释放操作是这样的：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&#123;</span>&#125;;</span><br><span class=\"line\">Foo* pf = <span class=\"keyword\">new</span> Foo;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> pf;</span><br></pre></td></tr></table></figure>\n<p>  这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。<strong>为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。</strong></p>\n</li>\n<li>STL的配置器(allocator)定于于<code>&lt;memory&gt;</code>，其中包含两个文件,一个是负责内存空间的配置与释放&lt;stl_alloc.h&gt;,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构&lt;stl_construct.h&gt;，定义了全局函数construct()和destroy()。</li>\n</ul>\n<h6 id=\"2-2-3-构造和析构基本工具-construct-和destroy\"><a href=\"#2-2-3-构造和析构基本工具-construct-和destroy\" class=\"headerlink\" title=\"2.2.3 构造和析构基本工具:construct()和destroy()\"></a>2.2.3 构造和析构基本工具:construct()和destroy()</h6><ul>\n<li><p>construct()的实现如下：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;new.h&gt;    //使用placement new 需要这个头文件</span></span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>, <span class=\"title\">class</span> <span class=\"title\">T2</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">construct</span>(<span class=\"title\">T1</span>* <span class=\"title\">p</span>, <span class=\"title\">const</span> <span class=\"title\">T2</span>&amp; <span class=\"title\">value</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> (p) T1(value);  <span class=\"comment\">//使用了placement new;调用T1:T1(value);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  代码解释：<code>construct()</code>接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，<strong>通过<code>placement new</code>实现</strong>。</p>\n</li>\n<li><p>destroy()有两个版本，实现如下:</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一个版本，接受一个指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">destroy</span>(<span class=\"title\">T</span>* <span class=\"title\">pointer</span>)&#123;</span></span><br><span class=\"line\">    pointer-&gt;~T();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits&lt;&gt;求取最适当的措施。</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">destroy</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>)&#123;</span></span><br><span class=\"line\">    __destroy(first, last, value_type(first));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//判断元素的数值型别(value type)是否有 trivial destructor</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>, <span class=\"title\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> __<span class=\"title\">destroy</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>, <span class=\"title\">T</span>*)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class=\"line\">    __destroy_aux(first, last, trivial_destructor());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果元素的数值型别(value type)有non-truvial destructor，循环释放</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> __<span class=\"title\">destroy_aux</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>, __<span class=\"title\">false_type</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; first &lt; last; ++first)</span><br><span class=\"line\">        <span class=\"comment\">//调用第一个版本的destroy()</span></span><br><span class=\"line\">        destroy(&amp;* first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果元素的数值型别(value type)有trivial destructor,函数什么也不做</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>, <span class=\"title\">ForwardIterator</span>, __<span class=\"title\">true_type</span>&gt;&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __true_type)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">desroy</span><span class=\"params\">(<span class=\"keyword\">char</span>*, <span class=\"keyword\">char</span>*)</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">(<span class=\"keyword\">wchar_t</span>*,<span class=\"keyword\">wchar_t</span>*)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>  代码解释：<code>destroy()</code>有两个版本，<strong>第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可</strong>。第二个版本接收first和last两个迭代器，准备将<code>[firat, last)</code>范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓<code>trivial destructor</code>),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，<strong>这里首先利用<code>value_type()</code>获得迭代器所指对象的型别，再利用<code>__type_traits&lt;T&gt;</code>判断该型别的析构函数是否无关痛痒。若是<code>(__true_type)</code>，则什么都不做结束；若不是<code>(__false_type)</code>,这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的<code>destroy()</code>。</strong></p>\n</li>\n<li>construct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits&lt;&gt;在3.7节。<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011438_654.png\" alt=\"construct()和destroy()图解\"></li>\n</ul>\n<h6 id=\"2-2-4-空间的配置与释放，std-alloc\"><a href=\"#2-2-4-空间的配置与释放，std-alloc\" class=\"headerlink\" title=\"2.2.4 空间的配置与释放，std::alloc\"></a>2.2.4 空间的配置与释放，std::alloc</h6><ul>\n<li>对象构造前的空间配置和对象析构后的空间释放，由<code>&lt;stl_alloc.h&gt;</code>负责。<ul>\n<li>向 system heap 要求空间</li>\n<li>考虑多线程(multi-threads)状态(这里不考虑多线程的情况)</li>\n<li>考虑内存不足时的应变措施</li>\n<li>考虑过多“小型区域”可能造成的内存碎片(fragment)问题</li>\n</ul>\n</li>\n<li><strong>C++内存配置的基本操作是:<code>:operator new()</code>，内存释放的基本操作是<code>::operator delete()</code>。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。</strong></li>\n<li>为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，<strong>第一级配置器<code>(__malloc_alloc_template)</code>用malloc()和free()，第二级配置器<code>(__default_alloc_template)</code>看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池<code>memory bool</code>整理方式。</strong>其中具体是开放了第一级配置器还是两级配置器都开放了由<strong>USE_MEALLOC是否定义决定，定义了</strong>USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。</li>\n<li><p>无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口<code>simple_alloc</code>，使其能够符合STL的接口规格。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>,<span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">simple_alloc</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span> == n?<span class=\"number\">0</span> : (T*) Alloc::allocate(n* <span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T*) Alloc::allocatte(<span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dallocate</span><span class=\"params\">(T* p, <span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">0</span> != n)</span><br><span class=\"line\">            Alloc::deallocate(p, n*<span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deallocat</span><span class=\"params\">(T* p)</span></span>&#123;</span><br><span class=\"line\">        Alloc::deallocate(p, <span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。</p>\n</li>\n<li>图解如下：<ul>\n<li>第一级配置器和第二级配置器：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011620_34.png\" alt=\"第一级配置器和第二级配置器\"></li>\n<li>包装接口和运用：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011647_747.png\" alt=\"包装接口和运用\"></li>\n</ul>\n</li>\n</ul>\n<p>接下来几节，暂时先压住……</p>\n<h6 id=\"2-2-5-第一级配置器-malloc-alloc-template-剖析\"><a href=\"#2-2-5-第一级配置器-malloc-alloc-template-剖析\" class=\"headerlink\" title=\"2.2.5 第一级配置器 __malloc_alloc_template 剖析\"></a>2.2.5 第一级配置器 __malloc_alloc_template 剖析</h6><h6 id=\"2-2-6-第二级配置器-default-alloc-template-剖析\"><a href=\"#2-2-6-第二级配置器-default-alloc-template-剖析\" class=\"headerlink\" title=\"2.2.6 第二级配置器__default_alloc_template 剖析\"></a>2.2.6 第二级配置器__default_alloc_template 剖析</h6><h6 id=\"2-2-7-空间配置函数allocate\"><a href=\"#2-2-7-空间配置函数allocate\" class=\"headerlink\" title=\"2.2.7 空间配置函数allocate()\"></a>2.2.7 空间配置函数allocate()</h6><h6 id=\"2-2-8-空间释放函数-deallocate\"><a href=\"#2-2-8-空间释放函数-deallocate\" class=\"headerlink\" title=\"2.2.8 空间释放函数 deallocate()\"></a>2.2.8 空间释放函数 deallocate()</h6><h6 id=\"2-2-9-重新填充-free-lists\"><a href=\"#2-2-9-重新填充-free-lists\" class=\"headerlink\" title=\"2.2.9 重新填充 free lists\"></a>2.2.9 重新填充 free lists</h6><h6 id=\"2-2-10-内存池-memory-pool\"><a href=\"#2-2-10-内存池-memory-pool\" class=\"headerlink\" title=\"2.2.10 内存池(memory pool)\"></a>2.2.10 内存池(memory pool)</h6><h5 id=\"2-3-内存基本处理工具\"><a href=\"#2-3-内存基本处理工具\" class=\"headerlink\" title=\"2.3 内存基本处理工具\"></a>2.3 内存基本处理工具</h5><p>STL定义了五个全局函数，作用于未初始化化空间上：用于构造的<code>construct()</code>和析构的<code>destroy()</code>,另外三个是：<code>uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()</code>(定于于<code>&lt;memory&gt;</code>),分别对应于高层次函数<code>copy(),fill(),fill_n()</code>,这些都是STL的算法。</p>\n<h6 id=\"2-3-1-uninitialized-copy\"><a href=\"#2-3-1-uninitialized-copy\" class=\"headerlink\" title=\"2.3.1 uninitialized_copy\"></a>2.3.1 uninitialized_copy</h6><h6 id=\"2-3-2-uninitialized-fill\"><a href=\"#2-3-2-uninitialized-fill\" class=\"headerlink\" title=\"2.3.2 uninitialized_fill\"></a>2.3.2 uninitialized_fill</h6><h6 id=\"2-3-3-uninitialized-fill-n\"><a href=\"#2-3-3-uninitialized-fill-n\" class=\"headerlink\" title=\"2.3.3 uninitialized_fill_n\"></a>2.3.3 uninitialized_fill_n</h6><h4 id=\"3-迭代器-iterator-概念与traits编程技法\"><a href=\"#3-迭代器-iterator-概念与traits编程技法\" class=\"headerlink\" title=\"3 迭代器(iterator)概念与traits编程技法\"></a>3 迭代器(iterator)概念与traits编程技法</h4><p>迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式</p>\n<h5 id=\"3-1-迭代器设计思维\"><a href=\"#3-1-迭代器设计思维\" class=\"headerlink\" title=\"3.1 迭代器设计思维\"></a>3.1 迭代器设计思维</h5><p><strong>STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//3.1举例说明迭代器的使用</span></span><br><span class=\"line\"><span class=\"comment\">//find()的定义。</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator</span>, <span class=\"title\">chass</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">InputIterator</span> <span class=\"title\">find</span>( <span class=\"title\">InputIterator</span> <span class=\"title\">first</span>, <span class=\"title\">InputIterator</span> <span class=\"title\">last</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>&amp; <span class=\"title\">value</span> )&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( first != last &amp;&amp; *first != value )</span><br><span class=\"line\">        ++first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> arraySiza = <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ia[arraySiza] = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivect(ia, ia+arraySiza);</span><br><span class=\"line\">    <span class=\"comment\">//调用vector的iterator用于find()</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator it1 = find(ivect.begin(), ivect.end(), <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( it1 == ivect.end() )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"4 not found.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"4 found:\"</span> &lt;&lt; *it1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    it1 = find(ivect.begin(), ivect.end(), <span class=\"number\">8</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( it1 == ivect.end() )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"8 not found.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"8 found\"</span> &lt;&lt; *it1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011511_588.png\" alt=\"迭代器\"></p>\n<h5 id=\"3-2-迭代器-ierator-是一种smart-pointer\"><a href=\"#3-2-迭代器-ierator-是一种smart-pointer\" class=\"headerlink\" title=\"3.2 迭代器(ierator)是一种smart pointer\"></a>3.2 迭代器(ierator)是一种smart pointer</h5><p><strong>迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-&gt; 进行重载工作。</strong><br>以下，简单模拟一个list的结构，然后设计对应的iterator。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//listnode</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListItem</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123; <span class=\"keyword\">return</span> _value; &#125;</span><br><span class=\"line\">    <span class=\"function\">ListItem* <span class=\"title\">next</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123; <span class=\"keyword\">return</span> _next; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T _value;</span><br><span class=\"line\">    ListItem* _next; <span class=\"comment\">//单向链表(single linked list)</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//list</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_front</span><span class=\"params\">(T value)</span></span>; <span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_end</span><span class=\"params\">(T value)</span></span>;   <span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"function\">voide <span class=\"title\">display</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os = <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    ListItem&lt;T&gt;* _end;</span><br><span class=\"line\">    ListItem&lt;T&gt;* _front;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> _size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//iterator</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Item</span>&gt;//<span class=\"title\">Item</span>可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的<span class=\"title\">operator</span>++只适用于链表。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">ListIter</span>&#123;</span></span><br><span class=\"line\">    Item* ptr;  <span class=\"comment\">//保持与容器之间的一个联系</span></span><br><span class=\"line\">    ListIter( Item* p = <span class=\"number\">0</span> )</span><br><span class=\"line\">        :ptr(p)</span><br><span class=\"line\">        &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//不必实现copy ctor，因为编译器提供的缺省行为已经足够</span></span><br><span class=\"line\">    <span class=\"comment\">//不必实现operator=，因为编译器提供的缺省行为已经足够</span></span><br><span class=\"line\">    Item&amp; <span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> *ptr; &#125;</span><br><span class=\"line\">    Item* <span class=\"keyword\">operator</span>-&gt;() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> ptr; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator)</span></span><br><span class=\"line\">    <span class=\"comment\">//pre-increament operator</span></span><br><span class=\"line\">    ListIter&amp; <span class=\"keyword\">operator</span>++()&#123;</span><br><span class=\"line\">        ptr = ptr-&gt;next();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//post-incteament operator</span></span><br><span class=\"line\">    LostIter <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)&#123;</span><br><span class=\"line\">        ListIter tmp = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        ++*<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> LostIter&amp; i)<span class=\"keyword\">const</span>&#123; <span class=\"keyword\">return</span> ptr == i.ptr; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> LostIter&amp; i)<span class=\"keyword\">const</span>&#123; <span class=\"keyword\">return</span> ptr != i.ptr; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来，将List和find()由ListIter粘合起来：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>&gt; mylist;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i )&#123;</span><br><span class=\"line\">        mylist.insert_front(i);</span><br><span class=\"line\">        mylist.insert_end(i+<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mylist.displau();   <span class=\"comment\">//10( 4 3 2 1 0 2 3 4 5 6)</span></span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; begin(mylist.front());</span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; end;</span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; iter;</span><br><span class=\"line\"></span><br><span class=\"line\">    iter = find(begin, end, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( iter == end )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not found\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"found.\"</span> &lt;&lt; iter-&gt;value() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//执行结果：found.3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于find() 函数以<code>*iter != value</code>来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 <code>ListIterm&lt;int&gt;</code>,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和<code>ListIterm&lt;int&gt;</code>。如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> ListItem&lt;T&gt;&amp; item, T n)&#123; <span class=\"keyword\">return</span> item.value() != n; &#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3-3-迭代器相应型别-associated-types\"><a href=\"#3-3-迭代器相应型别-associated-types\" class=\"headerlink\" title=\"3.3 迭代器相应型别(associated types)\"></a>3.3 迭代器相应型别(associated types)</h5><p>当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011841_231.png\" alt=\"function template的例子\"><br>以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。</p>\n<h5 id=\"3-4-Traits-编程技法——STL源代码门钥\"><a href=\"#3-4-Traits-编程技法——STL源代码门钥\" class=\"headerlink\" title=\"3.4 Traits 编程技法——STL源代码门钥\"></a>3.4 Traits 编程技法——STL源代码门钥</h5><ul>\n<li><p><strong>value type：迭代器所指对象的型别。</strong>上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的”template参数推导机制”推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">MyIter</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;   <span class=\"comment\">//内嵌型别声明(nested type)</span></span><br><span class=\"line\">    MyIter(T* p = <span class=\"number\">0</span>)</span><br><span class=\"line\">        :ptr(p)</span><br><span class=\"line\">        &#123;&#125;</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> *ptr; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    T* ptr; <span class=\"comment\">//成员变量</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">typename</span> <span class=\"title\">I</span>:</span>:<span class=\"function\">value_type <span class=\"title\">func</span><span class=\"params\">( I ite )</span></span>&#123; <span class=\"keyword\">return</span> *ite; &#125;    <span class=\"comment\">//typename I::value_type  这是func的返回值型别；</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">MyIter&lt;<span class=\"keyword\">int</span>&gt; ite(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>));</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; func(ite);  <span class=\"comment\">//输出:8</span></span><br></pre></td></tr></table></figure>\n<p>  <code>typename I::value_type</code>必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。<strong>加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。</strong></p>\n</li>\n<li><p>这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 <strong>偏特化(template partial specialization)</strong>。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//class template</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>&#123;</span>    <span class=\"comment\">//这个泛化版本接受T为任何型别</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//prartial specialization</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>&lt;T*&gt;&#123;</span>    <span class=\"comment\">//这个特化版本只适用于\"T 为原生指针\"的情况</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下面这个例子，<strong>专门用来萃取迭代器的特性，value type正是迭代器的特性之一</strong></p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&#123;</span> <span class=\"comment\">//traits意思为“特性”</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::value_type value_type;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  这样，前面那个func函数可以修改成这样。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">//<span class=\"title\">typename</span> <span class=\"title\">iterator_traits</span>&lt;I&gt;:</span>:value_type 是函数的返回型别</span><br><span class=\"line\"><span class=\"keyword\">typename</span> iterator_traits&lt;I&gt;::<span class=\"function\">value_type <span class=\"title\">func</span><span class=\"params\">(I ite)</span></span>&#123; <span class=\"keyword\">return</span> *ite; &#125;</span><br></pre></td></tr></table></figure>\n<p>  跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&lt;T*&gt;&#123;</span> <span class=\"comment\">//偏特化版本--迭代器是一个原生指针</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的<code>iterator_traits&lt;const int*&gt;::value_type</code>得到的是const int。所以我们另外设计一个特化版本，让<code>const T*</code>转变为T*：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&lt;const T*&gt;&#123;</span>   <span class=\"comment\">//偏特化版本，当迭代器是一个const指针的时候，</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;           <span class=\"comment\">//萃取出来的是T，而不是const T</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  到这里为止，<strong>不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。</strong></p>\n</li>\n<li>图解iterator_traits：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802012217_572.png\" alt=\"iterator_traits\"></li>\n<li><p>常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::iterator_category iterator_category;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::value_type value_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::difference_type difference_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::pointer pointer;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::reference reference;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  <strong>其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。</strong></p>\n</li>\n</ul>\n<p>本章先到这里，往下就是对STL原原本本的探究了。</p>\n<h6 id=\"3-4-1-value-type-如上\"><a href=\"#3-4-1-value-type-如上\" class=\"headerlink\" title=\"3.4.1 value type 如上\"></a>3.4.1 value type 如上</h6><h6 id=\"3-4-2-difference-type\"><a href=\"#3-4-2-difference-type\" class=\"headerlink\" title=\"3.4.2 difference type\"></a>3.4.2 difference type</h6><h6 id=\"3-4-3-reference-type\"><a href=\"#3-4-3-reference-type\" class=\"headerlink\" title=\"3.4.3 reference type\"></a>3.4.3 reference type</h6><h6 id=\"3-4-4-pointer-type\"><a href=\"#3-4-4-pointer-type\" class=\"headerlink\" title=\"3.4.4 pointer type\"></a>3.4.4 pointer type</h6><h6 id=\"3-4-5-iterator-catrgory\"><a href=\"#3-4-5-iterator-catrgory\" class=\"headerlink\" title=\"3.4.5 iterator_catrgory\"></a>3.4.5 iterator_catrgory</h6><h4 id=\"4-序列式容器\"><a href=\"#4-序列式容器\" class=\"headerlink\" title=\"4 序列式容器\"></a>4 序列式容器</h4><h5 id=\"4-1-容器的概观与分类\"><a href=\"#4-1-容器的概观与分类\" class=\"headerlink\" title=\"4.1 容器的概观与分类\"></a>4.1 容器的概观与分类</h5><p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801311638_540.png\" alt=\"SGI STL的各个容器\"><br>所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。</p>\n<h5 id=\"4-2-vector\"><a href=\"#4-2-vector\" class=\"headerlink\" title=\"4.2 vector\"></a>4.2 vector</h5><h6 id=\"4-2-1-vector概述\"><a href=\"#4-2-1-vector概述\" class=\"headerlink\" title=\"4.2.1 vector概述\"></a>4.2.1 vector概述</h6><p>array是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。</p>\n<h6 id=\"4-2-3-vector的迭代器\"><a href=\"#4-2-3-vector的迭代器\" class=\"headerlink\" title=\"4.2.3 vector的迭代器\"></a>4.2.3 vector的迭代器</h6><p>由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。<code>vector&lt;int&gt; :: iterator ivite;vector&lt;Shape&gt; :: iterator svite;</code>其中 <code>ivite</code>的类型就是<code>int*</code>，<code>svite</code>的类型就是<code>Shape*</code> 。</p>\n<h6 id=\"4-2-4-vector的数据结构\"><a href=\"#4-2-4-vector的数据结构\" class=\"headerlink\" title=\"4.2.4 vector的数据结构\"></a>4.2.4 vector的数据结构</h6><ul>\n<li><p>vector的数据结构如下：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span> = <span class=\"title\">alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">vecotr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置</span></span><br><span class=\"line\">        iterator start;             <span class=\"comment\">//表示目前使用空间的头部</span></span><br><span class=\"line\">        iterator finish;            <span class=\"comment\">//表示目前使用空间的尾部</span></span><br><span class=\"line\">        iterator end_of_storage;    <span class=\"comment\">//表示目前可用空间的尾部</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。</p>\n</li>\n<li>运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。</li>\n</ul>\n<h6 id=\"4-2-5-vector的构造与内存管理：constructor，push-back\"><a href=\"#4-2-5-vector的构造与内存管理：constructor，push-back\" class=\"headerlink\" title=\"4.2.5 vector的构造与内存管理：constructor，push_back\"></a>4.2.5 vector的构造与内存管理：constructor，push_back</h6><p>push_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。<strong>因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。</strong>push_back源代码节选如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">( <span class=\"keyword\">const</span> T&amp; x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( finish != end_of_storage )&#123;</span><br><span class=\"line\">        construct( finish, x );</span><br><span class=\"line\">        ++finish;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>    <span class=\"comment\">//无备用空间</span></span><br><span class=\"line\">    insert_aux(end(), x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">vector</span>&lt;T, Alloc&gt;:</span>:insert_aux( iterator positon, <span class=\"keyword\">const</span> T&amp; x )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( finish != end_of_storage )&#123; <span class=\"comment\">//为什么还要再次判断</span></span><br><span class=\"line\">        construct( finish, *(finish - <span class=\"number\">1</span>));</span><br><span class=\"line\">        ++finish;</span><br><span class=\"line\">        T x_copy = x;</span><br><span class=\"line\">        <span class=\"comment\">//不懂</span></span><br><span class=\"line\">        copy_backward(position, finish - <span class=\"number\">2</span>, finish - <span class=\"number\">1</span>);</span><br><span class=\"line\">        *position = x_copy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//无备用空间</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> size_type old_size = size();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> size_type len = old_size != <span class=\"number\">0</span> ? <span class=\"number\">2</span>*old_size : <span class=\"number\">1</span>;</span><br><span class=\"line\">        iterator new_start = data_allocator::allocatr(len); <span class=\"comment\">//实际配置空间</span></span><br><span class=\"line\">        iterator new_finish = new_start;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//将原来vector内容拷贝到新的vector</span></span><br><span class=\"line\">            new_finish = uninitialized_copy(start, position, new_start);</span><br><span class=\"line\">            <span class=\"comment\">//为新元素设定初值x</span></span><br><span class=\"line\">            construct(new_finish, x);</span><br><span class=\"line\">            ++new_finish;</span><br><span class=\"line\">            <span class=\"comment\">//将安插点的原内容也拷贝过来//不懂</span></span><br><span class=\"line\">            new_finish = uninitialized_copy(posiition, finish, new_finish);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span>(...)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//开辟失败</span></span><br><span class=\"line\">            destroy(new_start, new_finish);</span><br><span class=\"line\">            data_allocator::deallocate(new_start, len);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//析构并释放原vector</span></span><br><span class=\"line\">        destory(begin(), end());</span><br><span class=\"line\">        deallocate();</span><br><span class=\"line\">        <span class=\"comment\">//调整迭代器，指向新的vector</span></span><br><span class=\"line\">        start = new_start;</span><br><span class=\"line\">        finish = new_finish;</span><br><span class=\"line\">        end_of_storage = new_start+len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"4-2-6-vector的元素操作：pop-back-erase-clear-insert\"><a href=\"#4-2-6-vector的元素操作：pop-back-erase-clear-insert\" class=\"headerlink\" title=\"4.2.6 vector的元素操作：pop_back, erase, clear, insert\"></a>4.2.6 vector的元素操作：pop_back, erase, clear, insert</h6><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//清除[first, last)中的元素</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">    iterator ii = copy(last, finish, first);    <span class=\"comment\">//copy是全局函数，第六章</span></span><br><span class=\"line\">    destory(i, finish);</span><br><span class=\"line\">    finish = finish - (last - first);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//清除某个位置上的元素</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator position)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(position + <span class=\"number\">1</span> != end())</span><br><span class=\"line\">        copy(position + <span class=\"number\">1</span>, finish, position);</span><br><span class=\"line\">    --finish;</span><br><span class=\"line\">    destroy(finish);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>&#123; erase(begin(), end()); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从position开始，插入n个元素，元素初值为x</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">vector</span>&lt;T, Alloc&gt;:</span>:insert(iterator position, size_type n ,<span class=\"keyword\">const</span> T&amp; x)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//备用空间大于等于新增元素个数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(size_type(end_of_storage - finish) &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            T x_copy = x;</span><br><span class=\"line\">            <span class=\"comment\">//计算插入点之后的现有元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type elems_after = finish - position;</span><br><span class=\"line\">            iterator old_finish = finish;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(elems_after &gt; n)&#123;    <span class=\"comment\">//插入点之后的现有元素个数 &gt; 新增元素个数</span></span><br><span class=\"line\">                uninitialized_copy(finish - n, finish, finish);</span><br><span class=\"line\">                finish += n;    <span class=\"comment\">//将vector 尾端标记后移</span></span><br><span class=\"line\">                copy_backward(position, old_finish - n, old_finish);</span><br><span class=\"line\">                fill(position, position+n, x_copy); <span class=\"comment\">//从插入点开始填入新值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                uninitialized_fill_n(finish, n-elems_affter, x_copy);</span><br><span class=\"line\">                finish += n - elems_after;</span><br><span class=\"line\">                uninitialized_copy(position, old_finish, finish);</span><br><span class=\"line\">                finish += elems_after;</span><br><span class=\"line\">                fill(position, old_finish, x_copy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//备用空间 &lt; 新增元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type old_size = size();</span><br><span class=\"line\">            <span class=\"comment\">//决定新的长度为旧长度+新增元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type len = old_size + max(old_size, n);</span><br><span class=\"line\">            <span class=\"comment\">//配置新的vector空间</span></span><br><span class=\"line\">            iterator new_start = data_allocaator::allocate(len);</span><br><span class=\"line\">            iterator new_finish = new_start;</span><br><span class=\"line\">            __STL_TRY&#123;  <span class=\"comment\">//&lt;-- 这个是什么</span></span><br><span class=\"line\">                <span class=\"comment\">//将旧的vector在插入点之前的元素复制到新空间</span></span><br><span class=\"line\">                new_finish = uninitialized_copy(start, position, new_start);</span><br><span class=\"line\">                <span class=\"comment\">//将新增元素(初值为x)填入新空间</span></span><br><span class=\"line\">                new_finish = uninitialized_fill_n(new_finish, n, x);</span><br><span class=\"line\">                <span class=\"comment\">//将旧的vector在插入点之后的元素复制到新空间</span></span><br><span class=\"line\">                nwe_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//异常处理</span></span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//清除释放旧的空间</span></span><br><span class=\"line\">            destroy(start，finish);</span><br><span class=\"line\">            deallocate();</span><br><span class=\"line\">            <span class=\"comment\">//调整迭代器指向新的空间</span></span><br><span class=\"line\">            start = new_start;</span><br><span class=\"line\">            finish = new_finish;</span><br><span class=\"line\">            end_of_storage = new_start+len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//插入操作完成之后，新增节点应位于position的后面。</span></span><br></pre></td></tr></table></figure>\n<p>图解如下：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021439_772.png\" alt=\"insert\"></p>\n<h5 id=\"4-3-list\"><a href=\"#4-3-list\" class=\"headerlink\" title=\"4.3 list\"></a>4.3 list</h5><h6 id=\"4-3-1-list概述\"><a href=\"#4-3-1-list概述\" class=\"headerlink\" title=\"4.3.1 list概述\"></a>4.3.1 list概述</h6><p>list每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。</p>\n<h6 id=\"4-3-2-list的节点-node\"><a href=\"#4-3-2-list的节点-node\" class=\"headerlink\" title=\"4.3.2 list的节点(node)\"></a>4.3.2 list的节点(node)</h6><p>list的节点和list本身的设计是分开的。以下是STL list的节点结构：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> __<span class=\"title\">list_node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* void_pointer;</span><br><span class=\"line\">    void_pointer prev;  <span class=\"comment\">//型别为void*，其实可以是__list_node&lt;T&gt;</span></span><br><span class=\"line\">    void_pointer next;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//这是一个双向链表节点</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"4-3-3-list的迭代器\"><a href=\"#4-3-3-list的迭代器\" class=\"headerlink\" title=\"4.3.3 list的迭代器\"></a>4.3.3 list的迭代器</h6><p><strong>list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效</strong></p>\n<h6 id=\"4-3-4-list的数据结构\"><a href=\"#4-3-4-list的数据结构\" class=\"headerlink\" title=\"4.3.4 list的数据结构\"></a>4.3.4 list的数据结构</h6><p>SGI list 是一个双向循环链表。list结构如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span> = <span class=\"title\">alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">list</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> list_node* link_type;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    link_type node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> (link_type)((*node).next); &#125;</span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> node; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> node-&gt;next == node; &#125;</span><br><span class=\"line\"><span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    size_type result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    distance(begin(), end(), result);   <span class=\"comment\">//全局函数，第三章//计算两个迭代器之间的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">reference <span class=\"title\">front</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> *begin(); &#125;</span><br><span class=\"line\"><span class=\"function\">reference <span class=\"title\">back</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> *(--end()); &#125;</span><br></pre></td></tr></table></figure></p>\n<p>图解如下：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021641_929.png\" alt=\"list\"></p>\n<h6 id=\"4-3-5-list的构造与内存管理：constructor，-push-back-insert\"><a href=\"#4-3-5-list的构造与内存管理：constructor，-push-back-insert\" class=\"headerlink\" title=\"4.3.5 list的构造与内存管理：constructor， push_back, insert\"></a>4.3.5 list的构造与内存管理：constructor， push_back, insert</h6><p>list缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。<code>list_node_alloctor(n)</code>表示配置n个节点空间。同时有四个函数，如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//配置一个节点并传回</span></span><br><span class=\"line\"><span class=\"function\">link_type <span class=\"title\">get_node</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//释放一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put_node</span><span class=\"params\">(link_type p)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//配置并构造一个节点，带有元素值</span></span><br><span class=\"line\"><span class=\"function\">link_type <span class=\"title\">create_node</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; x)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//析构并释放一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy_node</span><span class=\"params\">(link_type p)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>list众多构造函数中，有一个允许我们构造一个空list出来：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">list</span>()&#123; empty_initialize(); &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">empty_initialize</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//next、prev指针都指向自己</span></span><br><span class=\"line\">        node = get_node();</span><br><span class=\"line\">        node-&gt;next = node;</span><br><span class=\"line\">        node-&gt;prev = node;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>空节点对象模型：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021656_767.png\" alt=\"空节点\"><br>当我们用push_back()插入新节点的时候，函数内部调用insert()<code>void push_back(const T&amp; x) { inset( end(), x ); }</code>insert()有很多的重载函数，最简单的如下:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在迭代器position所指位置插入一个节点，值为x</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">insert</span><span class=\"params\">(iterator position, <span class=\"keyword\">const</span> T&amp; x)</span></span>&#123;</span><br><span class=\"line\">    link_type tmp = create_node(x);</span><br><span class=\"line\">    <span class=\"comment\">//插入位置在position之前,这是STL规范。</span></span><br><span class=\"line\">    tmp-&gt;next = position.node;</span><br><span class=\"line\">    tmp-&gt;prev = position.node-&gt;prev;</span><br><span class=\"line\">    (link_type(position.node-&gt;node-&gt;prev))-&gt;next = tmp;</span><br><span class=\"line\">    position.node-&gt;prev = tmp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"4-3-6-list的元素操作：push-front-push-back-erase-pop-front-pop-back-clear-remove-unique-splice-merge-reverse-sort\"><a href=\"#4-3-6-list的元素操作：push-front-push-back-erase-pop-front-pop-back-clear-remove-unique-splice-merge-reverse-sort\" class=\"headerlink\" title=\"4.3.6 list的元素操作：push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort\"></a>4.3.6 list的元素操作：<code>push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort</code></h6><p>push_front, push_back复用insert；pop_front, pop_back复用erase。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//移除迭代器position所指节点</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator position)</span></span>&#123;</span><br><span class=\"line\">    link_type next_node = link_type(position.node-&gt;next);</span><br><span class=\"line\">    link_type prev_node = link_type(position.node-&gt;prev);</span><br><span class=\"line\">    prev_node-&gt;next = next_node;</span><br><span class=\"line\">    next_node-&gt;prev = prev_node;</span><br><span class=\"line\">    destroy_node(position.node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> iterator(next_node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//清除所有节点</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:clear()&#123;</span><br><span class=\"line\">    link_type cur = (link__type) node-&gt;next;    <span class=\"comment\">//begin();</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur != node )&#123;</span><br><span class=\"line\">        link_type tmp - cur;</span><br><span class=\"line\">        cur = (link_type)cur-&gt;next;</span><br><span class=\"line\">        destroy_node(tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//恢复成空节点的初始结构</span></span><br><span class=\"line\">    node-&gt;next = node;</span><br><span class=\"line\">    node-&gt;prev = node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//将数值为value的所有元素移除</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:remove(<span class=\"keyword\">const</span> T&amp; value)&#123;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    iterator last = end();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first != last)&#123;</span><br><span class=\"line\">        iterator next = first;</span><br><span class=\"line\">        ++next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first == value) erase(first);</span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个</span></span><br><span class=\"line\"><span class=\"comment\">//很帅啊</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:unique()&#123;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    iterator last = end();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(first == last) <span class=\"keyword\">return</span>;   <span class=\"comment\">//判空</span></span><br><span class=\"line\">    iterator next = first;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(++next != last)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first == *next)</span><br><span class=\"line\">            erase(next);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            first = next;</span><br><span class=\"line\">        next = first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>list 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//将[first, last)内的所有元素移动到position之前。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(iterator position, iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(position != last)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//先处理各节点的next</span></span><br><span class=\"line\">            (*(link_type((*last.node).prev))).next = position.node;</span><br><span class=\"line\">            (*(link_type((*first.node).prev))).next = last.node;</span><br><span class=\"line\">            (*(link_type((*position.node).prev))).next = first.node;</span><br><span class=\"line\">            <span class=\"comment\">//tmp为position的prev节点</span></span><br><span class=\"line\">            link_type tmp = link_type((*position.node).prev);</span><br><span class=\"line\">            <span class=\"comment\">//处理各节点的prev</span></span><br><span class=\"line\">            (*position.node).prev = (*last.node).prev;</span><br><span class=\"line\">            (*last.node).prev = (*first.node).prev;</span><br><span class=\"line\">            (*first.node).prev = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>splice各个版本：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//将list x接合与position所指位置之前，x必须不同于*this</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator position, <span class=\"built_in\">list</span>&amp; x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x.empty())</span><br><span class=\"line\">            transfer(position, x.begin(), x.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将i 所指元素接合于position所指元素之前。position和i可指向同一个list</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator position, <span class=\"built_in\">list</span>&amp;, iterator i)</span></span>&#123;</span><br><span class=\"line\">        iterator j = i;</span><br><span class=\"line\">        ++j;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(position == i || position == j) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        trasfer(position, i, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将[first, last)内的所有元素接合于position所指位置之前，</span></span><br><span class=\"line\">    <span class=\"comment\">//position和[first, last)可指向同一个list。</span></span><br><span class=\"line\">    <span class=\"comment\">//但是position不能在[first, last)范围之内</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator posiition, <span class=\"built_in\">list</span>&amp;, iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first != last)</span><br><span class=\"line\">            transfer(position, first, last);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>merge(), reverse(), sort()源码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//merge()将x合并到*this上，两个list必须是递增排序的</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:merge(<span class=\"built_in\">list</span>&lt;T, Alloc&gt;&amp; x)&#123;</span><br><span class=\"line\">    iterator first1 = begin();</span><br><span class=\"line\">    iterator last1 = end();</span><br><span class=\"line\">    iterator first2 = x.begin();</span><br><span class=\"line\">    iterator last2 = x.end();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first1 != last1 &amp;&amp; first2 != last2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first2 &lt; *first1)&#123;</span><br><span class=\"line\">            iterator next = first2;</span><br><span class=\"line\">            transfer(first1, first2, ++next);</span><br><span class=\"line\">            first2 = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            ++first1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first2 !=  last2) transfer(last1, first2,last2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//reverse()将*this的内容逆置</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:reverse()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判空或只有一个节点，用size() == 0 || size() == 1速度比较慢</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    ++first;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first != end())&#123;</span><br><span class=\"line\">        iterator old = first;</span><br><span class=\"line\">        ++first;</span><br><span class=\"line\">        transfer(begin(), old, first);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//list不能使用STL中的sort()算法，只能使用自己的sort()</span></span><br><span class=\"line\"><span class=\"comment\">//因为STL的sort()只接受RamdonAccessIterator</span></span><br><span class=\"line\"><span class=\"comment\">//本函数使用quick sort</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:sort()&#123;</span><br><span class=\"line\">     <span class=\"comment\">//判空或只有一个节点，用size() == 0 || size() == 1速度比较慢</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建新的list空间，作为中介数据存放区</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;T, Alloc&gt; carry;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;T, Alloc&gt; counter[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fill = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!empty())&#123;</span><br><span class=\"line\">        carry.splice(carry.begin(), *<span class=\"keyword\">this</span>, begin());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; fill &amp;&amp; !counter[i].empty())&#123;</span><br><span class=\"line\">            counter[i].merge(carry);</span><br><span class=\"line\">            carry.swap(counter[i++]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        carry.swap(counter[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == fill)</span><br><span class=\"line\">            ++fill;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; fill; ++i)</span><br><span class=\"line\">        counter[i].merge(counter[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    swap(counter[fill<span class=\"number\">-1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"4-4-deque\"><a href=\"#4-4-deque\" class=\"headerlink\" title=\"4.4 deque\"></a>4.4 deque</h5><h6 id=\"4-4-1-deque概述\"><a href=\"#4-4-1-deque概述\" class=\"headerlink\" title=\"4.4.1 deque概述\"></a>4.4.1 deque概述</h6><p>deque是双向开口的连续性空间。可以在头尾两端分贝做元素的插入和删除操作。vector从技术层面也可以实现，但是头部操作效果奇差。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021818_269.png\" alt=\"deque\"><br>deque和vector的最大区别在于二：一是deque对头部的常数时间操作。二是deque没有capacity的概念，因为deque是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</p>\n<h6 id=\"4-4-2-deque的中控器\"><a href=\"#4-4-2-deque的中控器\" class=\"headerlink\" title=\"4.4.2 deque的中控器\"></a>4.4.2 deque的中控器</h6><p>deque是由一段一段的定量连续空间构成。deque的最大任务就是，在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存储的接口。避开了vector那样的重新分配、复制、释放的轮回，而是以复杂的迭代器架构为代价。</p>\n<p>deque采用一块所谓的map(非STL中的map容器)作为主控。这个map是一块连续空间，其中每个元素(称为节点node)都是指针，指向另一段较大的连续线性空间(缓冲区)。缓冲区才是deque的存储空间主题。SGI STL允许我们指定缓冲区的大小，默认值0代表使用512bytes缓冲区。结构如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>=<span class=\"title\">alloc</span>, <span class=\"title\">size_t</span> <span class=\"title\">BufSiz</span> = 0&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">deque</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> value_type* pointer;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//元素的指针的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> pointer* map_pointer;</span><br><span class=\"line\">    map_pointer <span class=\"built_in\">map</span>;    <span class=\"comment\">//指向map，map是一个连续空间，</span></span><br><span class=\"line\">                        <span class=\"comment\">//每一个元素是一个指针(称为节点)，指向一块缓冲区</span></span><br><span class=\"line\">    size_type map_size; <span class=\"comment\">//指定map可以容纳多少指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>map是一个二级指针，指向型别是T</strong>。见图解：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802031030_124.png\" alt=\"map\"></p>\n<h6 id=\"4-4-3-deque的迭代器\"><a href=\"#4-4-3-deque的迭代器\" class=\"headerlink\" title=\"4.4.3 deque的迭代器\"></a>4.4.3 deque的迭代器</h6><p>维持deque是一块连续空间的假象，用迭代器的operator++和operator–实现。迭代器起码要实现两个功能：一、可以指出分段连续空间(缓冲区)在哪里。二、能够判断是否处于缓冲区的边缘，如果是，向前移动或向后移动可以跳到上一个缓冲区或下一个缓冲区。需要正确跳段，需要掌控map。结构如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Ref</span>, <span class=\"title\">class</span> <span class=\"title\">Ptr</span>, <span class=\"title\">size_t</span> <span class=\"title\">BufSiz</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> __<span class=\"title\">deque_iterator</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> __deque_iterator&lt;T, Ref, Ptr, BufSiz&gt; iterator;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> __deque_iterator&lt;T, <span class=\"keyword\">const</span> T&amp;, <span class=\"keyword\">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> size_t <span class=\"title\">buffer_size</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> __deque_buf_size(BufSiz, <span class=\"keyword\">sizeof</span>(T)); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//没有继承std::iterator,所以需要自己写五个必要的迭代器相应型别(第三章)</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> random_access_iterator_tag iterator_category;   <span class=\"comment\">//1</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;   <span class=\"comment\">//2</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> Ptr pointer;    <span class=\"comment\">//3</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> Ref reference;  <span class=\"comment\">//4</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">ptrdiff_t</span> difference_type;  <span class=\"comment\">//5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">size_t</span> size_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T** map_pointer;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> __deque_iterator self;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//保持与容器的联系</span></span><br><span class=\"line\">    T* cur;     <span class=\"comment\">//当前缓冲区中当前元素</span></span><br><span class=\"line\">    T* first;   <span class=\"comment\">//当前缓冲区的头</span></span><br><span class=\"line\">    T* last;    <span class=\"comment\">//当前缓冲区的尾</span></span><br><span class=\"line\">    map_pointer node;   <span class=\"comment\">//指向中控器map</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//上段决定缓冲区大小的函数buffer_size()，调用__deque_buf_size(),这是一个全局函数，如下：</span></span><br><span class=\"line\"><span class=\"comment\">//当n不为0，传回n，表示buffer_size用户自定义了</span></span><br><span class=\"line\"><span class=\"comment\">//当n为0，buffer_size使用默认值</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> __deque_buf_size(<span class=\"keyword\">size_t</span> n, <span class=\"keyword\">size_t</span> sz)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n != <span class=\"number\">0</span> ? n : (sz &lt; <span class=\"number\">512</span> ? <span class=\"keyword\">size_t</span>(<span class=\"number\">512</span> / sz) : <span class=\"keyword\">size_t</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下图是deque的中控器，缓冲区，迭代器的相互关系：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802031110_957.png\" alt=\"deque的中控器，缓冲区，迭代器的相互关系\"></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-STL概论与版本简介\"><a href=\"#1-STL概论与版本简介\" class=\"headerlink\" title=\"1 STL概论与版本简介\"></a>1 STL概论与版本简介</h4><h5 id=\"1-2-STL六大组件\"><a href=\"#1-2-STL六大组件\" class=\"headerlink\" title=\"1.2 STL六大组件\"></a>1.2 STL六大组件</h5><ol>\n<li>容器(containers):<code>vector,list,deque,set,map</code>,用来存放数据</li>\n<li>算法(algorithms):<code>sort,search,copy,erase</code></li>\n<li>迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，","more":"迭代器器将<code>operator*,operator++,operator--,operator-&gt;</code>等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。</li>\n<li>仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。</li>\n<li>配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。</li>\n<li>配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</li>\n</ol>\n<h5 id=\"1-5-1-8-STL版本之二\"><a href=\"#1-5-1-8-STL版本之二\" class=\"headerlink\" title=\"1.5~1.8 STL版本之二\"></a>1.5~1.8 STL版本之二</h5><ol>\n<li>P.J.Plauger (Microsoft Visual C++)</li>\n<li>SGI STL (Linux GCC)<br> C++标准规范下的C头文件: <code>cstdio,cstdlib,cstring</code><br> C++标准程序库中不属于STL范畴: <code>stream,string</code><br> STL标准头文件: <code>vector,deque,list,map,algorithm,functional</code><br> C++Standard定案前，HP所规范的STL头文件: <code>vector.h,deque.h,list.h,algo.h,function.h</code><br> SGI STL内部文件(STL真正实现于此): <code>stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h</code></li>\n</ol>\n<h5 id=\"1-9-可能令你困惑的C-语法\"><a href=\"#1-9-可能令你困惑的C-语法\" class=\"headerlink\" title=\"1.9 可能令你困惑的C++语法\"></a>1.9 可能令你困惑的C++语法</h5><h6 id=\"1-9-2-临时对象的产生与运用\"><a href=\"#1-9-2-临时对象的产生与运用\" class=\"headerlink\" title=\"1.9.2 临时对象的产生与运用\"></a>1.9.2 临时对象的产生与运用</h6><p>临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。<strong>STL中最常将此技巧用在仿函数(functor)中。</strong>临时对象的生命周期只有这一行指令。</p>\n<h6 id=\"1-9-3-静态常量整数成员在class内部直接初始化\"><a href=\"#1-9-3-静态常量整数成员在class内部直接初始化\" class=\"headerlink\" title=\"1.9.3 静态常量整数成员在class内部直接初始化\"></a>1.9.3 静态常量整数成员在class内部直接初始化</h6><p>class内含有<code>const static integral data member</code>，我们可以直接给予初值。<br>    <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.9.3测试代码如下</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">testclass</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> datai = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">long</span> datal = <span class=\"number\">3L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> datac = <span class=\"string\">'c'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datai &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datal &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datac &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801291947_629.png\" alt=\"运行结果\"></p>\n<h6 id=\"1-9-5-前闭后开区间表示法\"><a href=\"#1-9-5-前闭后开区间表示法\" class=\"headerlink\" title=\"1.9.5 前闭后开区间表示法[)\"></a>1.9.5 前闭后开区间表示法[)</h6><p><strong>STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。</strong></p>\n<h6 id=\"1-9-6-function-call操作符-operator\"><a href=\"#1-9-6-function-call操作符-operator\" class=\"headerlink\" title=\"1.9.6 function call操作符(operator())\"></a>1.9.6 function call操作符(operator())</h6><p>function call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。<strong>如果你针对某个class进行operator()重载，它就成为一个仿函数。</strong><br>    <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.9.6测试代码如下</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">Add</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//重载了operator()</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp;x, <span class=\"keyword\">const</span> T&amp;y)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x+y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Add&lt;<span class=\"keyword\">int</span>&gt; addxy;</span><br><span class=\"line\">    system( <span class=\"string\">\"clear\"</span> );</span><br><span class=\"line\">    <span class=\"comment\">//调用重载函数</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; addxy(<span class=\"number\">3</span>,<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//调用匿名对象</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; Add&lt;<span class=\"keyword\">int</span>&gt;()(<span class=\"number\">5</span>,<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801292024_990.png\" alt=\"仿函数\"></p>\n<h4 id=\"2-空间配置器-allocator\"><a href=\"#2-空间配置器-allocator\" class=\"headerlink\" title=\"2 空间配置器(allocator)\"></a>2 空间配置器(allocator)</h4><p>空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。</p>\n<h5 id=\"2-2-具备此配置力的SGI空间配置器\"><a href=\"#2-2-具备此配置力的SGI空间配置器\" class=\"headerlink\" title=\"2.2 具备此配置力的SGI空间配置器\"></a>2.2 具备此配置力的SGI空间配置器</h5><h6 id=\"2-2-1-SGI标准的空间配置器-std-allocator\"><a href=\"#2-2-1-SGI标准的空间配置器-std-allocator\" class=\"headerlink\" title=\"2.2.1 SGI标准的空间配置器,std::allocator\"></a>2.2.1 SGI标准的空间配置器,std::allocator</h6><p>SGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：<code>vector&lt;int,std::allocator&lt;int&gt;&gt;</code>;SGI STL写法如下：<code>vector&lt;int, std::aloc&gt;</code>绝大多数情况下，我们都是使用缺省的空间配置器。</p>\n<h6 id=\"2-2-2-SGI特殊的空间配置器，std-alloc\"><a href=\"#2-2-2-SGI特殊的空间配置器，std-alloc\" class=\"headerlink\" title=\"2.2.2 SGI特殊的空间配置器，std::alloc\"></a>2.2.2 SGI特殊的空间配置器，std::alloc</h6><ul>\n<li>SGI同时也配备了标准空间配置器<code>std::allocator</code>，但是这只是对C++的<code>operator new和operator delete</code>做了一层封装，效率低下，<strong>SGI并不使用，只是为了向前兼容语法。</strong></li>\n<li><p><strong>SGI自身使用的空间配置器是<code>std::alloc</code></strong>一般来说，我们习惯的C++内存操作和释放操作是这样的：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&#123;</span>&#125;;</span><br><span class=\"line\">Foo* pf = <span class=\"keyword\">new</span> Foo;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> pf;</span><br></pre></td></tr></table></figure>\n<p>  这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。<strong>为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。</strong></p>\n</li>\n<li>STL的配置器(allocator)定于于<code>&lt;memory&gt;</code>，其中包含两个文件,一个是负责内存空间的配置与释放&lt;stl_alloc.h&gt;,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构&lt;stl_construct.h&gt;，定义了全局函数construct()和destroy()。</li>\n</ul>\n<h6 id=\"2-2-3-构造和析构基本工具-construct-和destroy\"><a href=\"#2-2-3-构造和析构基本工具-construct-和destroy\" class=\"headerlink\" title=\"2.2.3 构造和析构基本工具:construct()和destroy()\"></a>2.2.3 构造和析构基本工具:construct()和destroy()</h6><ul>\n<li><p>construct()的实现如下：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;new.h&gt;    //使用placement new 需要这个头文件</span></span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>, <span class=\"title\">class</span> <span class=\"title\">T2</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">construct</span>(<span class=\"title\">T1</span>* <span class=\"title\">p</span>, <span class=\"title\">const</span> <span class=\"title\">T2</span>&amp; <span class=\"title\">value</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> (p) T1(value);  <span class=\"comment\">//使用了placement new;调用T1:T1(value);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  代码解释：<code>construct()</code>接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，<strong>通过<code>placement new</code>实现</strong>。</p>\n</li>\n<li><p>destroy()有两个版本，实现如下:</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一个版本，接受一个指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">destroy</span>(<span class=\"title\">T</span>* <span class=\"title\">pointer</span>)&#123;</span></span><br><span class=\"line\">    pointer-&gt;~T();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits&lt;&gt;求取最适当的措施。</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">destroy</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>)&#123;</span></span><br><span class=\"line\">    __destroy(first, last, value_type(first));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//判断元素的数值型别(value type)是否有 trivial destructor</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>, <span class=\"title\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> __<span class=\"title\">destroy</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>, <span class=\"title\">T</span>*)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class=\"line\">    __destroy_aux(first, last, trivial_destructor());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果元素的数值型别(value type)有non-truvial destructor，循环释放</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> __<span class=\"title\">destroy_aux</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>, __<span class=\"title\">false_type</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; first &lt; last; ++first)</span><br><span class=\"line\">        <span class=\"comment\">//调用第一个版本的destroy()</span></span><br><span class=\"line\">        destroy(&amp;* first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果元素的数值型别(value type)有trivial destructor,函数什么也不做</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>, <span class=\"title\">ForwardIterator</span>, __<span class=\"title\">true_type</span>&gt;&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __true_type)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">desroy</span><span class=\"params\">(<span class=\"keyword\">char</span>*, <span class=\"keyword\">char</span>*)</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">(<span class=\"keyword\">wchar_t</span>*,<span class=\"keyword\">wchar_t</span>*)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>  代码解释：<code>destroy()</code>有两个版本，<strong>第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可</strong>。第二个版本接收first和last两个迭代器，准备将<code>[firat, last)</code>范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓<code>trivial destructor</code>),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，<strong>这里首先利用<code>value_type()</code>获得迭代器所指对象的型别，再利用<code>__type_traits&lt;T&gt;</code>判断该型别的析构函数是否无关痛痒。若是<code>(__true_type)</code>，则什么都不做结束；若不是<code>(__false_type)</code>,这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的<code>destroy()</code>。</strong></p>\n</li>\n<li>construct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits&lt;&gt;在3.7节。<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011438_654.png\" alt=\"construct()和destroy()图解\"></li>\n</ul>\n<h6 id=\"2-2-4-空间的配置与释放，std-alloc\"><a href=\"#2-2-4-空间的配置与释放，std-alloc\" class=\"headerlink\" title=\"2.2.4 空间的配置与释放，std::alloc\"></a>2.2.4 空间的配置与释放，std::alloc</h6><ul>\n<li>对象构造前的空间配置和对象析构后的空间释放，由<code>&lt;stl_alloc.h&gt;</code>负责。<ul>\n<li>向 system heap 要求空间</li>\n<li>考虑多线程(multi-threads)状态(这里不考虑多线程的情况)</li>\n<li>考虑内存不足时的应变措施</li>\n<li>考虑过多“小型区域”可能造成的内存碎片(fragment)问题</li>\n</ul>\n</li>\n<li><strong>C++内存配置的基本操作是:<code>:operator new()</code>，内存释放的基本操作是<code>::operator delete()</code>。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。</strong></li>\n<li>为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，<strong>第一级配置器<code>(__malloc_alloc_template)</code>用malloc()和free()，第二级配置器<code>(__default_alloc_template)</code>看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池<code>memory bool</code>整理方式。</strong>其中具体是开放了第一级配置器还是两级配置器都开放了由<strong>USE_MEALLOC是否定义决定，定义了</strong>USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。</li>\n<li><p>无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口<code>simple_alloc</code>，使其能够符合STL的接口规格。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>,<span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">simple_alloc</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span> == n?<span class=\"number\">0</span> : (T*) Alloc::allocate(n* <span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T*) Alloc::allocatte(<span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dallocate</span><span class=\"params\">(T* p, <span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">0</span> != n)</span><br><span class=\"line\">            Alloc::deallocate(p, n*<span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deallocat</span><span class=\"params\">(T* p)</span></span>&#123;</span><br><span class=\"line\">        Alloc::deallocate(p, <span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。</p>\n</li>\n<li>图解如下：<ul>\n<li>第一级配置器和第二级配置器：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011620_34.png\" alt=\"第一级配置器和第二级配置器\"></li>\n<li>包装接口和运用：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011647_747.png\" alt=\"包装接口和运用\"></li>\n</ul>\n</li>\n</ul>\n<p>接下来几节，暂时先压住……</p>\n<h6 id=\"2-2-5-第一级配置器-malloc-alloc-template-剖析\"><a href=\"#2-2-5-第一级配置器-malloc-alloc-template-剖析\" class=\"headerlink\" title=\"2.2.5 第一级配置器 __malloc_alloc_template 剖析\"></a>2.2.5 第一级配置器 __malloc_alloc_template 剖析</h6><h6 id=\"2-2-6-第二级配置器-default-alloc-template-剖析\"><a href=\"#2-2-6-第二级配置器-default-alloc-template-剖析\" class=\"headerlink\" title=\"2.2.6 第二级配置器__default_alloc_template 剖析\"></a>2.2.6 第二级配置器__default_alloc_template 剖析</h6><h6 id=\"2-2-7-空间配置函数allocate\"><a href=\"#2-2-7-空间配置函数allocate\" class=\"headerlink\" title=\"2.2.7 空间配置函数allocate()\"></a>2.2.7 空间配置函数allocate()</h6><h6 id=\"2-2-8-空间释放函数-deallocate\"><a href=\"#2-2-8-空间释放函数-deallocate\" class=\"headerlink\" title=\"2.2.8 空间释放函数 deallocate()\"></a>2.2.8 空间释放函数 deallocate()</h6><h6 id=\"2-2-9-重新填充-free-lists\"><a href=\"#2-2-9-重新填充-free-lists\" class=\"headerlink\" title=\"2.2.9 重新填充 free lists\"></a>2.2.9 重新填充 free lists</h6><h6 id=\"2-2-10-内存池-memory-pool\"><a href=\"#2-2-10-内存池-memory-pool\" class=\"headerlink\" title=\"2.2.10 内存池(memory pool)\"></a>2.2.10 内存池(memory pool)</h6><h5 id=\"2-3-内存基本处理工具\"><a href=\"#2-3-内存基本处理工具\" class=\"headerlink\" title=\"2.3 内存基本处理工具\"></a>2.3 内存基本处理工具</h5><p>STL定义了五个全局函数，作用于未初始化化空间上：用于构造的<code>construct()</code>和析构的<code>destroy()</code>,另外三个是：<code>uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()</code>(定于于<code>&lt;memory&gt;</code>),分别对应于高层次函数<code>copy(),fill(),fill_n()</code>,这些都是STL的算法。</p>\n<h6 id=\"2-3-1-uninitialized-copy\"><a href=\"#2-3-1-uninitialized-copy\" class=\"headerlink\" title=\"2.3.1 uninitialized_copy\"></a>2.3.1 uninitialized_copy</h6><h6 id=\"2-3-2-uninitialized-fill\"><a href=\"#2-3-2-uninitialized-fill\" class=\"headerlink\" title=\"2.3.2 uninitialized_fill\"></a>2.3.2 uninitialized_fill</h6><h6 id=\"2-3-3-uninitialized-fill-n\"><a href=\"#2-3-3-uninitialized-fill-n\" class=\"headerlink\" title=\"2.3.3 uninitialized_fill_n\"></a>2.3.3 uninitialized_fill_n</h6><h4 id=\"3-迭代器-iterator-概念与traits编程技法\"><a href=\"#3-迭代器-iterator-概念与traits编程技法\" class=\"headerlink\" title=\"3 迭代器(iterator)概念与traits编程技法\"></a>3 迭代器(iterator)概念与traits编程技法</h4><p>迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式</p>\n<h5 id=\"3-1-迭代器设计思维\"><a href=\"#3-1-迭代器设计思维\" class=\"headerlink\" title=\"3.1 迭代器设计思维\"></a>3.1 迭代器设计思维</h5><p><strong>STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//3.1举例说明迭代器的使用</span></span><br><span class=\"line\"><span class=\"comment\">//find()的定义。</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator</span>, <span class=\"title\">chass</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">InputIterator</span> <span class=\"title\">find</span>( <span class=\"title\">InputIterator</span> <span class=\"title\">first</span>, <span class=\"title\">InputIterator</span> <span class=\"title\">last</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>&amp; <span class=\"title\">value</span> )&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( first != last &amp;&amp; *first != value )</span><br><span class=\"line\">        ++first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> arraySiza = <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ia[arraySiza] = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivect(ia, ia+arraySiza);</span><br><span class=\"line\">    <span class=\"comment\">//调用vector的iterator用于find()</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator it1 = find(ivect.begin(), ivect.end(), <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( it1 == ivect.end() )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"4 not found.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"4 found:\"</span> &lt;&lt; *it1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    it1 = find(ivect.begin(), ivect.end(), <span class=\"number\">8</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( it1 == ivect.end() )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"8 not found.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"8 found\"</span> &lt;&lt; *it1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011511_588.png\" alt=\"迭代器\"></p>\n<h5 id=\"3-2-迭代器-ierator-是一种smart-pointer\"><a href=\"#3-2-迭代器-ierator-是一种smart-pointer\" class=\"headerlink\" title=\"3.2 迭代器(ierator)是一种smart pointer\"></a>3.2 迭代器(ierator)是一种smart pointer</h5><p><strong>迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-&gt; 进行重载工作。</strong><br>以下，简单模拟一个list的结构，然后设计对应的iterator。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//listnode</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListItem</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123; <span class=\"keyword\">return</span> _value; &#125;</span><br><span class=\"line\">    <span class=\"function\">ListItem* <span class=\"title\">next</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123; <span class=\"keyword\">return</span> _next; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T _value;</span><br><span class=\"line\">    ListItem* _next; <span class=\"comment\">//单向链表(single linked list)</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//list</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_front</span><span class=\"params\">(T value)</span></span>; <span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_end</span><span class=\"params\">(T value)</span></span>;   <span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"function\">voide <span class=\"title\">display</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os = <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    ListItem&lt;T&gt;* _end;</span><br><span class=\"line\">    ListItem&lt;T&gt;* _front;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> _size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//iterator</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Item</span>&gt;//<span class=\"title\">Item</span>可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的<span class=\"title\">operator</span>++只适用于链表。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">ListIter</span>&#123;</span></span><br><span class=\"line\">    Item* ptr;  <span class=\"comment\">//保持与容器之间的一个联系</span></span><br><span class=\"line\">    ListIter( Item* p = <span class=\"number\">0</span> )</span><br><span class=\"line\">        :ptr(p)</span><br><span class=\"line\">        &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//不必实现copy ctor，因为编译器提供的缺省行为已经足够</span></span><br><span class=\"line\">    <span class=\"comment\">//不必实现operator=，因为编译器提供的缺省行为已经足够</span></span><br><span class=\"line\">    Item&amp; <span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> *ptr; &#125;</span><br><span class=\"line\">    Item* <span class=\"keyword\">operator</span>-&gt;() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> ptr; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator)</span></span><br><span class=\"line\">    <span class=\"comment\">//pre-increament operator</span></span><br><span class=\"line\">    ListIter&amp; <span class=\"keyword\">operator</span>++()&#123;</span><br><span class=\"line\">        ptr = ptr-&gt;next();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//post-incteament operator</span></span><br><span class=\"line\">    LostIter <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)&#123;</span><br><span class=\"line\">        ListIter tmp = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        ++*<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> LostIter&amp; i)<span class=\"keyword\">const</span>&#123; <span class=\"keyword\">return</span> ptr == i.ptr; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> LostIter&amp; i)<span class=\"keyword\">const</span>&#123; <span class=\"keyword\">return</span> ptr != i.ptr; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来，将List和find()由ListIter粘合起来：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>&gt; mylist;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i )&#123;</span><br><span class=\"line\">        mylist.insert_front(i);</span><br><span class=\"line\">        mylist.insert_end(i+<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mylist.displau();   <span class=\"comment\">//10( 4 3 2 1 0 2 3 4 5 6)</span></span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; begin(mylist.front());</span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; end;</span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; iter;</span><br><span class=\"line\"></span><br><span class=\"line\">    iter = find(begin, end, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( iter == end )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not found\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"found.\"</span> &lt;&lt; iter-&gt;value() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//执行结果：found.3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于find() 函数以<code>*iter != value</code>来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 <code>ListIterm&lt;int&gt;</code>,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和<code>ListIterm&lt;int&gt;</code>。如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> ListItem&lt;T&gt;&amp; item, T n)&#123; <span class=\"keyword\">return</span> item.value() != n; &#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3-3-迭代器相应型别-associated-types\"><a href=\"#3-3-迭代器相应型别-associated-types\" class=\"headerlink\" title=\"3.3 迭代器相应型别(associated types)\"></a>3.3 迭代器相应型别(associated types)</h5><p>当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011841_231.png\" alt=\"function template的例子\"><br>以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。</p>\n<h5 id=\"3-4-Traits-编程技法——STL源代码门钥\"><a href=\"#3-4-Traits-编程技法——STL源代码门钥\" class=\"headerlink\" title=\"3.4 Traits 编程技法——STL源代码门钥\"></a>3.4 Traits 编程技法——STL源代码门钥</h5><ul>\n<li><p><strong>value type：迭代器所指对象的型别。</strong>上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的”template参数推导机制”推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">MyIter</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;   <span class=\"comment\">//内嵌型别声明(nested type)</span></span><br><span class=\"line\">    MyIter(T* p = <span class=\"number\">0</span>)</span><br><span class=\"line\">        :ptr(p)</span><br><span class=\"line\">        &#123;&#125;</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> *ptr; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    T* ptr; <span class=\"comment\">//成员变量</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">typename</span> <span class=\"title\">I</span>:</span>:<span class=\"function\">value_type <span class=\"title\">func</span><span class=\"params\">( I ite )</span></span>&#123; <span class=\"keyword\">return</span> *ite; &#125;    <span class=\"comment\">//typename I::value_type  这是func的返回值型别；</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">MyIter&lt;<span class=\"keyword\">int</span>&gt; ite(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>));</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; func(ite);  <span class=\"comment\">//输出:8</span></span><br></pre></td></tr></table></figure>\n<p>  <code>typename I::value_type</code>必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。<strong>加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。</strong></p>\n</li>\n<li><p>这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 <strong>偏特化(template partial specialization)</strong>。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//class template</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>&#123;</span>    <span class=\"comment\">//这个泛化版本接受T为任何型别</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//prartial specialization</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>&lt;T*&gt;&#123;</span>    <span class=\"comment\">//这个特化版本只适用于\"T 为原生指针\"的情况</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下面这个例子，<strong>专门用来萃取迭代器的特性，value type正是迭代器的特性之一</strong></p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&#123;</span> <span class=\"comment\">//traits意思为“特性”</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::value_type value_type;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  这样，前面那个func函数可以修改成这样。</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">//<span class=\"title\">typename</span> <span class=\"title\">iterator_traits</span>&lt;I&gt;:</span>:value_type 是函数的返回型别</span><br><span class=\"line\"><span class=\"keyword\">typename</span> iterator_traits&lt;I&gt;::<span class=\"function\">value_type <span class=\"title\">func</span><span class=\"params\">(I ite)</span></span>&#123; <span class=\"keyword\">return</span> *ite; &#125;</span><br></pre></td></tr></table></figure>\n<p>  跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&lt;T*&gt;&#123;</span> <span class=\"comment\">//偏特化版本--迭代器是一个原生指针</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的<code>iterator_traits&lt;const int*&gt;::value_type</code>得到的是const int。所以我们另外设计一个特化版本，让<code>const T*</code>转变为T*：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&lt;const T*&gt;&#123;</span>   <span class=\"comment\">//偏特化版本，当迭代器是一个const指针的时候，</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;           <span class=\"comment\">//萃取出来的是T，而不是const T</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  到这里为止，<strong>不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。</strong></p>\n</li>\n<li>图解iterator_traits：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802012217_572.png\" alt=\"iterator_traits\"></li>\n<li><p>常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::iterator_category iterator_category;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::value_type value_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::difference_type difference_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::pointer pointer;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::reference reference;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  <strong>其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。</strong></p>\n</li>\n</ul>\n<p>本章先到这里，往下就是对STL原原本本的探究了。</p>\n<h6 id=\"3-4-1-value-type-如上\"><a href=\"#3-4-1-value-type-如上\" class=\"headerlink\" title=\"3.4.1 value type 如上\"></a>3.4.1 value type 如上</h6><h6 id=\"3-4-2-difference-type\"><a href=\"#3-4-2-difference-type\" class=\"headerlink\" title=\"3.4.2 difference type\"></a>3.4.2 difference type</h6><h6 id=\"3-4-3-reference-type\"><a href=\"#3-4-3-reference-type\" class=\"headerlink\" title=\"3.4.3 reference type\"></a>3.4.3 reference type</h6><h6 id=\"3-4-4-pointer-type\"><a href=\"#3-4-4-pointer-type\" class=\"headerlink\" title=\"3.4.4 pointer type\"></a>3.4.4 pointer type</h6><h6 id=\"3-4-5-iterator-catrgory\"><a href=\"#3-4-5-iterator-catrgory\" class=\"headerlink\" title=\"3.4.5 iterator_catrgory\"></a>3.4.5 iterator_catrgory</h6><h4 id=\"4-序列式容器\"><a href=\"#4-序列式容器\" class=\"headerlink\" title=\"4 序列式容器\"></a>4 序列式容器</h4><h5 id=\"4-1-容器的概观与分类\"><a href=\"#4-1-容器的概观与分类\" class=\"headerlink\" title=\"4.1 容器的概观与分类\"></a>4.1 容器的概观与分类</h5><p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801311638_540.png\" alt=\"SGI STL的各个容器\"><br>所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。</p>\n<h5 id=\"4-2-vector\"><a href=\"#4-2-vector\" class=\"headerlink\" title=\"4.2 vector\"></a>4.2 vector</h5><h6 id=\"4-2-1-vector概述\"><a href=\"#4-2-1-vector概述\" class=\"headerlink\" title=\"4.2.1 vector概述\"></a>4.2.1 vector概述</h6><p>array是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。</p>\n<h6 id=\"4-2-3-vector的迭代器\"><a href=\"#4-2-3-vector的迭代器\" class=\"headerlink\" title=\"4.2.3 vector的迭代器\"></a>4.2.3 vector的迭代器</h6><p>由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。<code>vector&lt;int&gt; :: iterator ivite;vector&lt;Shape&gt; :: iterator svite;</code>其中 <code>ivite</code>的类型就是<code>int*</code>，<code>svite</code>的类型就是<code>Shape*</code> 。</p>\n<h6 id=\"4-2-4-vector的数据结构\"><a href=\"#4-2-4-vector的数据结构\" class=\"headerlink\" title=\"4.2.4 vector的数据结构\"></a>4.2.4 vector的数据结构</h6><ul>\n<li><p>vector的数据结构如下：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span> = <span class=\"title\">alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">vecotr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置</span></span><br><span class=\"line\">        iterator start;             <span class=\"comment\">//表示目前使用空间的头部</span></span><br><span class=\"line\">        iterator finish;            <span class=\"comment\">//表示目前使用空间的尾部</span></span><br><span class=\"line\">        iterator end_of_storage;    <span class=\"comment\">//表示目前可用空间的尾部</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。</p>\n</li>\n<li>运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。</li>\n</ul>\n<h6 id=\"4-2-5-vector的构造与内存管理：constructor，push-back\"><a href=\"#4-2-5-vector的构造与内存管理：constructor，push-back\" class=\"headerlink\" title=\"4.2.5 vector的构造与内存管理：constructor，push_back\"></a>4.2.5 vector的构造与内存管理：constructor，push_back</h6><p>push_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。<strong>因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。</strong>push_back源代码节选如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">( <span class=\"keyword\">const</span> T&amp; x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( finish != end_of_storage )&#123;</span><br><span class=\"line\">        construct( finish, x );</span><br><span class=\"line\">        ++finish;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>    <span class=\"comment\">//无备用空间</span></span><br><span class=\"line\">    insert_aux(end(), x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">vector</span>&lt;T, Alloc&gt;:</span>:insert_aux( iterator positon, <span class=\"keyword\">const</span> T&amp; x )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( finish != end_of_storage )&#123; <span class=\"comment\">//为什么还要再次判断</span></span><br><span class=\"line\">        construct( finish, *(finish - <span class=\"number\">1</span>));</span><br><span class=\"line\">        ++finish;</span><br><span class=\"line\">        T x_copy = x;</span><br><span class=\"line\">        <span class=\"comment\">//不懂</span></span><br><span class=\"line\">        copy_backward(position, finish - <span class=\"number\">2</span>, finish - <span class=\"number\">1</span>);</span><br><span class=\"line\">        *position = x_copy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//无备用空间</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> size_type old_size = size();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> size_type len = old_size != <span class=\"number\">0</span> ? <span class=\"number\">2</span>*old_size : <span class=\"number\">1</span>;</span><br><span class=\"line\">        iterator new_start = data_allocator::allocatr(len); <span class=\"comment\">//实际配置空间</span></span><br><span class=\"line\">        iterator new_finish = new_start;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//将原来vector内容拷贝到新的vector</span></span><br><span class=\"line\">            new_finish = uninitialized_copy(start, position, new_start);</span><br><span class=\"line\">            <span class=\"comment\">//为新元素设定初值x</span></span><br><span class=\"line\">            construct(new_finish, x);</span><br><span class=\"line\">            ++new_finish;</span><br><span class=\"line\">            <span class=\"comment\">//将安插点的原内容也拷贝过来//不懂</span></span><br><span class=\"line\">            new_finish = uninitialized_copy(posiition, finish, new_finish);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span>(...)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//开辟失败</span></span><br><span class=\"line\">            destroy(new_start, new_finish);</span><br><span class=\"line\">            data_allocator::deallocate(new_start, len);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//析构并释放原vector</span></span><br><span class=\"line\">        destory(begin(), end());</span><br><span class=\"line\">        deallocate();</span><br><span class=\"line\">        <span class=\"comment\">//调整迭代器，指向新的vector</span></span><br><span class=\"line\">        start = new_start;</span><br><span class=\"line\">        finish = new_finish;</span><br><span class=\"line\">        end_of_storage = new_start+len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"4-2-6-vector的元素操作：pop-back-erase-clear-insert\"><a href=\"#4-2-6-vector的元素操作：pop-back-erase-clear-insert\" class=\"headerlink\" title=\"4.2.6 vector的元素操作：pop_back, erase, clear, insert\"></a>4.2.6 vector的元素操作：pop_back, erase, clear, insert</h6><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//清除[first, last)中的元素</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">    iterator ii = copy(last, finish, first);    <span class=\"comment\">//copy是全局函数，第六章</span></span><br><span class=\"line\">    destory(i, finish);</span><br><span class=\"line\">    finish = finish - (last - first);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//清除某个位置上的元素</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator position)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(position + <span class=\"number\">1</span> != end())</span><br><span class=\"line\">        copy(position + <span class=\"number\">1</span>, finish, position);</span><br><span class=\"line\">    --finish;</span><br><span class=\"line\">    destroy(finish);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>&#123; erase(begin(), end()); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从position开始，插入n个元素，元素初值为x</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">vector</span>&lt;T, Alloc&gt;:</span>:insert(iterator position, size_type n ,<span class=\"keyword\">const</span> T&amp; x)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//备用空间大于等于新增元素个数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(size_type(end_of_storage - finish) &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            T x_copy = x;</span><br><span class=\"line\">            <span class=\"comment\">//计算插入点之后的现有元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type elems_after = finish - position;</span><br><span class=\"line\">            iterator old_finish = finish;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(elems_after &gt; n)&#123;    <span class=\"comment\">//插入点之后的现有元素个数 &gt; 新增元素个数</span></span><br><span class=\"line\">                uninitialized_copy(finish - n, finish, finish);</span><br><span class=\"line\">                finish += n;    <span class=\"comment\">//将vector 尾端标记后移</span></span><br><span class=\"line\">                copy_backward(position, old_finish - n, old_finish);</span><br><span class=\"line\">                fill(position, position+n, x_copy); <span class=\"comment\">//从插入点开始填入新值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                uninitialized_fill_n(finish, n-elems_affter, x_copy);</span><br><span class=\"line\">                finish += n - elems_after;</span><br><span class=\"line\">                uninitialized_copy(position, old_finish, finish);</span><br><span class=\"line\">                finish += elems_after;</span><br><span class=\"line\">                fill(position, old_finish, x_copy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//备用空间 &lt; 新增元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type old_size = size();</span><br><span class=\"line\">            <span class=\"comment\">//决定新的长度为旧长度+新增元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type len = old_size + max(old_size, n);</span><br><span class=\"line\">            <span class=\"comment\">//配置新的vector空间</span></span><br><span class=\"line\">            iterator new_start = data_allocaator::allocate(len);</span><br><span class=\"line\">            iterator new_finish = new_start;</span><br><span class=\"line\">            __STL_TRY&#123;  <span class=\"comment\">//&lt;-- 这个是什么</span></span><br><span class=\"line\">                <span class=\"comment\">//将旧的vector在插入点之前的元素复制到新空间</span></span><br><span class=\"line\">                new_finish = uninitialized_copy(start, position, new_start);</span><br><span class=\"line\">                <span class=\"comment\">//将新增元素(初值为x)填入新空间</span></span><br><span class=\"line\">                new_finish = uninitialized_fill_n(new_finish, n, x);</span><br><span class=\"line\">                <span class=\"comment\">//将旧的vector在插入点之后的元素复制到新空间</span></span><br><span class=\"line\">                nwe_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//异常处理</span></span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//清除释放旧的空间</span></span><br><span class=\"line\">            destroy(start，finish);</span><br><span class=\"line\">            deallocate();</span><br><span class=\"line\">            <span class=\"comment\">//调整迭代器指向新的空间</span></span><br><span class=\"line\">            start = new_start;</span><br><span class=\"line\">            finish = new_finish;</span><br><span class=\"line\">            end_of_storage = new_start+len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//插入操作完成之后，新增节点应位于position的后面。</span></span><br></pre></td></tr></table></figure>\n<p>图解如下：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021439_772.png\" alt=\"insert\"></p>\n<h5 id=\"4-3-list\"><a href=\"#4-3-list\" class=\"headerlink\" title=\"4.3 list\"></a>4.3 list</h5><h6 id=\"4-3-1-list概述\"><a href=\"#4-3-1-list概述\" class=\"headerlink\" title=\"4.3.1 list概述\"></a>4.3.1 list概述</h6><p>list每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。</p>\n<h6 id=\"4-3-2-list的节点-node\"><a href=\"#4-3-2-list的节点-node\" class=\"headerlink\" title=\"4.3.2 list的节点(node)\"></a>4.3.2 list的节点(node)</h6><p>list的节点和list本身的设计是分开的。以下是STL list的节点结构：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> __<span class=\"title\">list_node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* void_pointer;</span><br><span class=\"line\">    void_pointer prev;  <span class=\"comment\">//型别为void*，其实可以是__list_node&lt;T&gt;</span></span><br><span class=\"line\">    void_pointer next;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//这是一个双向链表节点</span></span><br></pre></td></tr></table></figure></p>\n<h6 id=\"4-3-3-list的迭代器\"><a href=\"#4-3-3-list的迭代器\" class=\"headerlink\" title=\"4.3.3 list的迭代器\"></a>4.3.3 list的迭代器</h6><p><strong>list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效</strong></p>\n<h6 id=\"4-3-4-list的数据结构\"><a href=\"#4-3-4-list的数据结构\" class=\"headerlink\" title=\"4.3.4 list的数据结构\"></a>4.3.4 list的数据结构</h6><p>SGI list 是一个双向循环链表。list结构如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span> = <span class=\"title\">alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">list</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> list_node* link_type;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    link_type node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> (link_type)((*node).next); &#125;</span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> node; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> node-&gt;next == node; &#125;</span><br><span class=\"line\"><span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    size_type result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    distance(begin(), end(), result);   <span class=\"comment\">//全局函数，第三章//计算两个迭代器之间的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">reference <span class=\"title\">front</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> *begin(); &#125;</span><br><span class=\"line\"><span class=\"function\">reference <span class=\"title\">back</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> *(--end()); &#125;</span><br></pre></td></tr></table></figure></p>\n<p>图解如下：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021641_929.png\" alt=\"list\"></p>\n<h6 id=\"4-3-5-list的构造与内存管理：constructor，-push-back-insert\"><a href=\"#4-3-5-list的构造与内存管理：constructor，-push-back-insert\" class=\"headerlink\" title=\"4.3.5 list的构造与内存管理：constructor， push_back, insert\"></a>4.3.5 list的构造与内存管理：constructor， push_back, insert</h6><p>list缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。<code>list_node_alloctor(n)</code>表示配置n个节点空间。同时有四个函数，如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//配置一个节点并传回</span></span><br><span class=\"line\"><span class=\"function\">link_type <span class=\"title\">get_node</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//释放一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put_node</span><span class=\"params\">(link_type p)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//配置并构造一个节点，带有元素值</span></span><br><span class=\"line\"><span class=\"function\">link_type <span class=\"title\">create_node</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; x)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//析构并释放一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy_node</span><span class=\"params\">(link_type p)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>list众多构造函数中，有一个允许我们构造一个空list出来：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">list</span>()&#123; empty_initialize(); &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">empty_initialize</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//next、prev指针都指向自己</span></span><br><span class=\"line\">        node = get_node();</span><br><span class=\"line\">        node-&gt;next = node;</span><br><span class=\"line\">        node-&gt;prev = node;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>空节点对象模型：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021656_767.png\" alt=\"空节点\"><br>当我们用push_back()插入新节点的时候，函数内部调用insert()<code>void push_back(const T&amp; x) { inset( end(), x ); }</code>insert()有很多的重载函数，最简单的如下:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在迭代器position所指位置插入一个节点，值为x</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">insert</span><span class=\"params\">(iterator position, <span class=\"keyword\">const</span> T&amp; x)</span></span>&#123;</span><br><span class=\"line\">    link_type tmp = create_node(x);</span><br><span class=\"line\">    <span class=\"comment\">//插入位置在position之前,这是STL规范。</span></span><br><span class=\"line\">    tmp-&gt;next = position.node;</span><br><span class=\"line\">    tmp-&gt;prev = position.node-&gt;prev;</span><br><span class=\"line\">    (link_type(position.node-&gt;node-&gt;prev))-&gt;next = tmp;</span><br><span class=\"line\">    position.node-&gt;prev = tmp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"4-3-6-list的元素操作：push-front-push-back-erase-pop-front-pop-back-clear-remove-unique-splice-merge-reverse-sort\"><a href=\"#4-3-6-list的元素操作：push-front-push-back-erase-pop-front-pop-back-clear-remove-unique-splice-merge-reverse-sort\" class=\"headerlink\" title=\"4.3.6 list的元素操作：push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort\"></a>4.3.6 list的元素操作：<code>push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort</code></h6><p>push_front, push_back复用insert；pop_front, pop_back复用erase。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//移除迭代器position所指节点</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator position)</span></span>&#123;</span><br><span class=\"line\">    link_type next_node = link_type(position.node-&gt;next);</span><br><span class=\"line\">    link_type prev_node = link_type(position.node-&gt;prev);</span><br><span class=\"line\">    prev_node-&gt;next = next_node;</span><br><span class=\"line\">    next_node-&gt;prev = prev_node;</span><br><span class=\"line\">    destroy_node(position.node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> iterator(next_node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//清除所有节点</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:clear()&#123;</span><br><span class=\"line\">    link_type cur = (link__type) node-&gt;next;    <span class=\"comment\">//begin();</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur != node )&#123;</span><br><span class=\"line\">        link_type tmp - cur;</span><br><span class=\"line\">        cur = (link_type)cur-&gt;next;</span><br><span class=\"line\">        destroy_node(tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//恢复成空节点的初始结构</span></span><br><span class=\"line\">    node-&gt;next = node;</span><br><span class=\"line\">    node-&gt;prev = node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//将数值为value的所有元素移除</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:remove(<span class=\"keyword\">const</span> T&amp; value)&#123;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    iterator last = end();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first != last)&#123;</span><br><span class=\"line\">        iterator next = first;</span><br><span class=\"line\">        ++next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first == value) erase(first);</span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个</span></span><br><span class=\"line\"><span class=\"comment\">//很帅啊</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:unique()&#123;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    iterator last = end();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(first == last) <span class=\"keyword\">return</span>;   <span class=\"comment\">//判空</span></span><br><span class=\"line\">    iterator next = first;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(++next != last)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first == *next)</span><br><span class=\"line\">            erase(next);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            first = next;</span><br><span class=\"line\">        next = first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>list 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//将[first, last)内的所有元素移动到position之前。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(iterator position, iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(position != last)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//先处理各节点的next</span></span><br><span class=\"line\">            (*(link_type((*last.node).prev))).next = position.node;</span><br><span class=\"line\">            (*(link_type((*first.node).prev))).next = last.node;</span><br><span class=\"line\">            (*(link_type((*position.node).prev))).next = first.node;</span><br><span class=\"line\">            <span class=\"comment\">//tmp为position的prev节点</span></span><br><span class=\"line\">            link_type tmp = link_type((*position.node).prev);</span><br><span class=\"line\">            <span class=\"comment\">//处理各节点的prev</span></span><br><span class=\"line\">            (*position.node).prev = (*last.node).prev;</span><br><span class=\"line\">            (*last.node).prev = (*first.node).prev;</span><br><span class=\"line\">            (*first.node).prev = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>splice各个版本：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//将list x接合与position所指位置之前，x必须不同于*this</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator position, <span class=\"built_in\">list</span>&amp; x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x.empty())</span><br><span class=\"line\">            transfer(position, x.begin(), x.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将i 所指元素接合于position所指元素之前。position和i可指向同一个list</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator position, <span class=\"built_in\">list</span>&amp;, iterator i)</span></span>&#123;</span><br><span class=\"line\">        iterator j = i;</span><br><span class=\"line\">        ++j;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(position == i || position == j) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        trasfer(position, i, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将[first, last)内的所有元素接合于position所指位置之前，</span></span><br><span class=\"line\">    <span class=\"comment\">//position和[first, last)可指向同一个list。</span></span><br><span class=\"line\">    <span class=\"comment\">//但是position不能在[first, last)范围之内</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator posiition, <span class=\"built_in\">list</span>&amp;, iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first != last)</span><br><span class=\"line\">            transfer(position, first, last);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>merge(), reverse(), sort()源码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//merge()将x合并到*this上，两个list必须是递增排序的</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:merge(<span class=\"built_in\">list</span>&lt;T, Alloc&gt;&amp; x)&#123;</span><br><span class=\"line\">    iterator first1 = begin();</span><br><span class=\"line\">    iterator last1 = end();</span><br><span class=\"line\">    iterator first2 = x.begin();</span><br><span class=\"line\">    iterator last2 = x.end();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first1 != last1 &amp;&amp; first2 != last2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first2 &lt; *first1)&#123;</span><br><span class=\"line\">            iterator next = first2;</span><br><span class=\"line\">            transfer(first1, first2, ++next);</span><br><span class=\"line\">            first2 = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            ++first1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first2 !=  last2) transfer(last1, first2,last2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//reverse()将*this的内容逆置</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:reverse()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判空或只有一个节点，用size() == 0 || size() == 1速度比较慢</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    ++first;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first != end())&#123;</span><br><span class=\"line\">        iterator old = first;</span><br><span class=\"line\">        ++first;</span><br><span class=\"line\">        transfer(begin(), old, first);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//list不能使用STL中的sort()算法，只能使用自己的sort()</span></span><br><span class=\"line\"><span class=\"comment\">//因为STL的sort()只接受RamdonAccessIterator</span></span><br><span class=\"line\"><span class=\"comment\">//本函数使用quick sort</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:sort()&#123;</span><br><span class=\"line\">     <span class=\"comment\">//判空或只有一个节点，用size() == 0 || size() == 1速度比较慢</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建新的list空间，作为中介数据存放区</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;T, Alloc&gt; carry;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;T, Alloc&gt; counter[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fill = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!empty())&#123;</span><br><span class=\"line\">        carry.splice(carry.begin(), *<span class=\"keyword\">this</span>, begin());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; fill &amp;&amp; !counter[i].empty())&#123;</span><br><span class=\"line\">            counter[i].merge(carry);</span><br><span class=\"line\">            carry.swap(counter[i++]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        carry.swap(counter[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == fill)</span><br><span class=\"line\">            ++fill;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; fill; ++i)</span><br><span class=\"line\">        counter[i].merge(counter[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    swap(counter[fill<span class=\"number\">-1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"4-4-deque\"><a href=\"#4-4-deque\" class=\"headerlink\" title=\"4.4 deque\"></a>4.4 deque</h5><h6 id=\"4-4-1-deque概述\"><a href=\"#4-4-1-deque概述\" class=\"headerlink\" title=\"4.4.1 deque概述\"></a>4.4.1 deque概述</h6><p>deque是双向开口的连续性空间。可以在头尾两端分贝做元素的插入和删除操作。vector从技术层面也可以实现，但是头部操作效果奇差。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021818_269.png\" alt=\"deque\"><br>deque和vector的最大区别在于二：一是deque对头部的常数时间操作。二是deque没有capacity的概念，因为deque是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</p>\n<h6 id=\"4-4-2-deque的中控器\"><a href=\"#4-4-2-deque的中控器\" class=\"headerlink\" title=\"4.4.2 deque的中控器\"></a>4.4.2 deque的中控器</h6><p>deque是由一段一段的定量连续空间构成。deque的最大任务就是，在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存储的接口。避开了vector那样的重新分配、复制、释放的轮回，而是以复杂的迭代器架构为代价。</p>\n<p>deque采用一块所谓的map(非STL中的map容器)作为主控。这个map是一块连续空间，其中每个元素(称为节点node)都是指针，指向另一段较大的连续线性空间(缓冲区)。缓冲区才是deque的存储空间主题。SGI STL允许我们指定缓冲区的大小，默认值0代表使用512bytes缓冲区。结构如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>=<span class=\"title\">alloc</span>, <span class=\"title\">size_t</span> <span class=\"title\">BufSiz</span> = 0&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">deque</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> value_type* pointer;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//元素的指针的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> pointer* map_pointer;</span><br><span class=\"line\">    map_pointer <span class=\"built_in\">map</span>;    <span class=\"comment\">//指向map，map是一个连续空间，</span></span><br><span class=\"line\">                        <span class=\"comment\">//每一个元素是一个指针(称为节点)，指向一块缓冲区</span></span><br><span class=\"line\">    size_type map_size; <span class=\"comment\">//指定map可以容纳多少指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>map是一个二级指针，指向型别是T</strong>。见图解：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802031030_124.png\" alt=\"map\"></p>\n<h6 id=\"4-4-3-deque的迭代器\"><a href=\"#4-4-3-deque的迭代器\" class=\"headerlink\" title=\"4.4.3 deque的迭代器\"></a>4.4.3 deque的迭代器</h6><p>维持deque是一块连续空间的假象，用迭代器的operator++和operator–实现。迭代器起码要实现两个功能：一、可以指出分段连续空间(缓冲区)在哪里。二、能够判断是否处于缓冲区的边缘，如果是，向前移动或向后移动可以跳到上一个缓冲区或下一个缓冲区。需要正确跳段，需要掌控map。结构如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Ref</span>, <span class=\"title\">class</span> <span class=\"title\">Ptr</span>, <span class=\"title\">size_t</span> <span class=\"title\">BufSiz</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> __<span class=\"title\">deque_iterator</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> __deque_iterator&lt;T, Ref, Ptr, BufSiz&gt; iterator;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> __deque_iterator&lt;T, <span class=\"keyword\">const</span> T&amp;, <span class=\"keyword\">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> size_t <span class=\"title\">buffer_size</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> __deque_buf_size(BufSiz, <span class=\"keyword\">sizeof</span>(T)); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//没有继承std::iterator,所以需要自己写五个必要的迭代器相应型别(第三章)</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> random_access_iterator_tag iterator_category;   <span class=\"comment\">//1</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;   <span class=\"comment\">//2</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> Ptr pointer;    <span class=\"comment\">//3</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> Ref reference;  <span class=\"comment\">//4</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">ptrdiff_t</span> difference_type;  <span class=\"comment\">//5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">size_t</span> size_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T** map_pointer;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> __deque_iterator self;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//保持与容器的联系</span></span><br><span class=\"line\">    T* cur;     <span class=\"comment\">//当前缓冲区中当前元素</span></span><br><span class=\"line\">    T* first;   <span class=\"comment\">//当前缓冲区的头</span></span><br><span class=\"line\">    T* last;    <span class=\"comment\">//当前缓冲区的尾</span></span><br><span class=\"line\">    map_pointer node;   <span class=\"comment\">//指向中控器map</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//上段决定缓冲区大小的函数buffer_size()，调用__deque_buf_size(),这是一个全局函数，如下：</span></span><br><span class=\"line\"><span class=\"comment\">//当n不为0，传回n，表示buffer_size用户自定义了</span></span><br><span class=\"line\"><span class=\"comment\">//当n为0，buffer_size使用默认值</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> __deque_buf_size(<span class=\"keyword\">size_t</span> n, <span class=\"keyword\">size_t</span> sz)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n != <span class=\"number\">0</span> ? n : (sz &lt; <span class=\"number\">512</span> ? <span class=\"keyword\">size_t</span>(<span class=\"number\">512</span> / sz) : <span class=\"keyword\">size_t</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下图是deque的中控器，缓冲区，迭代器的相互关系：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802031110_957.png\" alt=\"deque的中控器，缓冲区，迭代器的相互关系\"></p>"},{"title":"收集","date":"2018-01-25T10:18:01.000Z","_content":"## **1、Linux**\n\n### 命令相关\n\n1. Linux命令大全：[http://man.linuxde.net/](http://man.linuxde.net/)\n2. 修改时间查看时间：[https://www.cnblogs.com/jiu0821/p/5999566.html](https://www.cnblogs.com/jiu0821/p/5999566.html)\n3. 移动、重命名文件/目录：[https://linux.cn/article-2688-1.html](https://linux.cn/article-2688-1.html)\n4. 查看系统版本：[http://www.linuxidc.com/Linux/2015-07/119897.htm](http://www.linuxidc.com/Linux/2015-07/119897.htm)\n<!--more-->\n\n### vim相关\n1. vim的配置：[http://blog.csdn.net/footmart_c/article/details/51588524](http://blog.csdn.net/footmart_c/article/details/51588524)\n2. 多行删除复制：[https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html](https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html)\n3. vim安装报错EXTERN.h：[http://tieba.baidu.com/p/4471948063](http://tieba.baidu.com/p/4471948063)\n4. vim升级8.0+YouCompleteMe补全插件：[http://blog.csdn.net/nzyalj/article/details/75331822](http://blog.csdn.net/nzyalj/article/details/75331822)\n5. vim8.0升级后添加到路径中：[http://blog.csdn.net/u013388603/article/details/72780586](http://blog.csdn.net/u013388603/article/details/72780586)\n6. YouCompleteMe：[http://blog.51cto.com/990487026/1905427](http://blog.51cto.com/990487026/1905427)\n\n### git相关\n1. git安装：[https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html](https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html)\n2. git安装：[http://blog.csdn.net/u013256816/article/details/54743470](http://blog.csdn.net/u013256816/article/details/54743470)\n3. git升级2.7.3：[https://www.cnblogs.com/yexinw/p/6401663.html](https://www.cnblogs.com/yexinw/p/6401663.html)\n\n### python相关\n1. 2.6升级2.7：[https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html](https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html)\n2. 安装3.5.2并与python2共存：[https://www.ywlib.com/archives/96-1.html](https://www.ywlib.com/archives/96-1.html)\n\n### 输入相关\n1. python造成 input method preferences无效：[http://blog.csdn.net/jaket5219999/article/details/52912321](http://blog.csdn.net/jaket5219999/article/details/52912321)\n2. 安装Fcitx 4.0.0：[https://www.douban.com/note/319236531/](https://www.douban.com/note/319236531/)\n3. 设置Fcitx默认：[https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html](https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html)\n4. ibus开启：[http://blog.csdn.net/zitong_ccnu/article/details/40110583](http://blog.csdn.net/zitong_ccnu/article/details/40110583)\n\n### 源相关\n1. Nux Dextop源：[http://www.linuxidc.com/Linux/2016-06/132101.htm](http://www.linuxidc.com/Linux/2016-06/132101.htm)\n2. yum源解析（详细）：[https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html](https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html)\n\n### Hexo相关\n- gcc升级：[http://www.cnblogs.com/lpbottle/p/install_gcc.html](http://www.cnblogs.com/lpbottle/p/install_gcc.html)\n- gcc升级：[http://blog.csdn.net/furzoom/article/details/53322510](http://blog.csdn.net/furzoom/article/details/53322510)\n- gcc升级：[http://blog.csdn.net/zr1076311296/article/details/51334538](http://blog.csdn.net/zr1076311296/article/details/51334538)\n- Nodejs安装：[https://www.cnblogs.com/lpbottle/p/7733397.html](https://www.cnblogs.com/lpbottle/p/7733397.html)\n\n### 其它\n1. /mnt/hgfs没有共享文件夹：[http://www.mamicode.com/info-detail-1655589.html](http://www.mamicode.com/info-detail-1655589.html)\n2. Linux就该这么学：[http://www.linuxprobe.com/chapter-00.html](http://www.linuxprobe.com/chapter-00.html)\n\n## **2、C语言**\n1. 链表相关笔试题：[http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html](http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html)\n\n## **3、GitHub**\n1. 知乎：[https://www.zhihu.com/question/20070065](https://www.zhihu.com/question/20070065)\n2. 他的网站里有：[http://youngxhui.github.io/](http://youngxhui.github.io/)\n\n- 以下，搭建自己的github博客：\n- 配置详细：[https://www.jianshu.com/p/b7886271e21a](https://www.jianshu.com/p/b7886271e21a)\n- 很强大的一个：[http://kchen.cc/2016/11/12/hexo-instructions/](http://kchen.cc/2016/11/12/hexo-instructions/)\n- WordPress和Hexo以及md编辑器：[https://www.imooc.com/article/12257](https://www.imooc.com/article/12257)\n- localhost:4000出问题：[http://blog.csdn.net/u012246342/article/details/51543370](http://blog.csdn.net/u012246342/article/details/51543370)\n- Hexo问题总结：[http://blog.csdn.net/wx_962464/article/details/44786929](http://blog.csdn.net/wx_962464/article/details/44786929)\n\n## **4、blog**\n1. [http://www.zipperary.com/](http://www.zipperary.com/)\n2. 陈皓：[https://coolshell.cn/featured](https://coolshell.cn/featured)\n\n\n## **5、其它**\n1. msdn：[https://msdn.itellyou.cn/](https://msdn.itellyou.cn/)\n2. NTFS和FAT32区别：[http://www.ntfsformac.cn/qita-nytqubie.html](http://www.ntfsformac.cn/qita-nytqubie.html)\n3. SQL源码剖析：[http://deepfuture.iteye.com/blog/718478](http://deepfuture.iteye.com/blog/718478)","source":"_posts/Linux相关网站.md","raw":"---\ntitle: 收集\ndate: 2018-01-25 18:18:01\ncategory:\n    - \"网站收集\"\n---\n## **1、Linux**\n\n### 命令相关\n\n1. Linux命令大全：[http://man.linuxde.net/](http://man.linuxde.net/)\n2. 修改时间查看时间：[https://www.cnblogs.com/jiu0821/p/5999566.html](https://www.cnblogs.com/jiu0821/p/5999566.html)\n3. 移动、重命名文件/目录：[https://linux.cn/article-2688-1.html](https://linux.cn/article-2688-1.html)\n4. 查看系统版本：[http://www.linuxidc.com/Linux/2015-07/119897.htm](http://www.linuxidc.com/Linux/2015-07/119897.htm)\n<!--more-->\n\n### vim相关\n1. vim的配置：[http://blog.csdn.net/footmart_c/article/details/51588524](http://blog.csdn.net/footmart_c/article/details/51588524)\n2. 多行删除复制：[https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html](https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html)\n3. vim安装报错EXTERN.h：[http://tieba.baidu.com/p/4471948063](http://tieba.baidu.com/p/4471948063)\n4. vim升级8.0+YouCompleteMe补全插件：[http://blog.csdn.net/nzyalj/article/details/75331822](http://blog.csdn.net/nzyalj/article/details/75331822)\n5. vim8.0升级后添加到路径中：[http://blog.csdn.net/u013388603/article/details/72780586](http://blog.csdn.net/u013388603/article/details/72780586)\n6. YouCompleteMe：[http://blog.51cto.com/990487026/1905427](http://blog.51cto.com/990487026/1905427)\n\n### git相关\n1. git安装：[https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html](https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html)\n2. git安装：[http://blog.csdn.net/u013256816/article/details/54743470](http://blog.csdn.net/u013256816/article/details/54743470)\n3. git升级2.7.3：[https://www.cnblogs.com/yexinw/p/6401663.html](https://www.cnblogs.com/yexinw/p/6401663.html)\n\n### python相关\n1. 2.6升级2.7：[https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html](https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html)\n2. 安装3.5.2并与python2共存：[https://www.ywlib.com/archives/96-1.html](https://www.ywlib.com/archives/96-1.html)\n\n### 输入相关\n1. python造成 input method preferences无效：[http://blog.csdn.net/jaket5219999/article/details/52912321](http://blog.csdn.net/jaket5219999/article/details/52912321)\n2. 安装Fcitx 4.0.0：[https://www.douban.com/note/319236531/](https://www.douban.com/note/319236531/)\n3. 设置Fcitx默认：[https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html](https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html)\n4. ibus开启：[http://blog.csdn.net/zitong_ccnu/article/details/40110583](http://blog.csdn.net/zitong_ccnu/article/details/40110583)\n\n### 源相关\n1. Nux Dextop源：[http://www.linuxidc.com/Linux/2016-06/132101.htm](http://www.linuxidc.com/Linux/2016-06/132101.htm)\n2. yum源解析（详细）：[https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html](https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html)\n\n### Hexo相关\n- gcc升级：[http://www.cnblogs.com/lpbottle/p/install_gcc.html](http://www.cnblogs.com/lpbottle/p/install_gcc.html)\n- gcc升级：[http://blog.csdn.net/furzoom/article/details/53322510](http://blog.csdn.net/furzoom/article/details/53322510)\n- gcc升级：[http://blog.csdn.net/zr1076311296/article/details/51334538](http://blog.csdn.net/zr1076311296/article/details/51334538)\n- Nodejs安装：[https://www.cnblogs.com/lpbottle/p/7733397.html](https://www.cnblogs.com/lpbottle/p/7733397.html)\n\n### 其它\n1. /mnt/hgfs没有共享文件夹：[http://www.mamicode.com/info-detail-1655589.html](http://www.mamicode.com/info-detail-1655589.html)\n2. Linux就该这么学：[http://www.linuxprobe.com/chapter-00.html](http://www.linuxprobe.com/chapter-00.html)\n\n## **2、C语言**\n1. 链表相关笔试题：[http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html](http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html)\n\n## **3、GitHub**\n1. 知乎：[https://www.zhihu.com/question/20070065](https://www.zhihu.com/question/20070065)\n2. 他的网站里有：[http://youngxhui.github.io/](http://youngxhui.github.io/)\n\n- 以下，搭建自己的github博客：\n- 配置详细：[https://www.jianshu.com/p/b7886271e21a](https://www.jianshu.com/p/b7886271e21a)\n- 很强大的一个：[http://kchen.cc/2016/11/12/hexo-instructions/](http://kchen.cc/2016/11/12/hexo-instructions/)\n- WordPress和Hexo以及md编辑器：[https://www.imooc.com/article/12257](https://www.imooc.com/article/12257)\n- localhost:4000出问题：[http://blog.csdn.net/u012246342/article/details/51543370](http://blog.csdn.net/u012246342/article/details/51543370)\n- Hexo问题总结：[http://blog.csdn.net/wx_962464/article/details/44786929](http://blog.csdn.net/wx_962464/article/details/44786929)\n\n## **4、blog**\n1. [http://www.zipperary.com/](http://www.zipperary.com/)\n2. 陈皓：[https://coolshell.cn/featured](https://coolshell.cn/featured)\n\n\n## **5、其它**\n1. msdn：[https://msdn.itellyou.cn/](https://msdn.itellyou.cn/)\n2. NTFS和FAT32区别：[http://www.ntfsformac.cn/qita-nytqubie.html](http://www.ntfsformac.cn/qita-nytqubie.html)\n3. SQL源码剖析：[http://deepfuture.iteye.com/blog/718478](http://deepfuture.iteye.com/blog/718478)","slug":"Linux相关网站","published":1,"updated":"2018-02-09T02:33:52.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nqyj000204d88k0hf42v","content":"<h2 id=\"1、Linux\"><a href=\"#1、Linux\" class=\"headerlink\" title=\"1、Linux\"></a><strong>1、Linux</strong></h2><h3 id=\"命令相关\"><a href=\"#命令相关\" class=\"headerlink\" title=\"命令相关\"></a>命令相关</h3><ol>\n<li>Linux命令大全：<a href=\"http://man.linuxde.net/\" target=\"_blank\" rel=\"noopener\">http://man.linuxde.net/</a></li>\n<li>修改时间查看时间：<a href=\"https://www.cnblogs.com/jiu0821/p/5999566.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/jiu0821/p/5999566.html</a></li>\n<li>移动、重命名文件/目录：<a href=\"https://linux.cn/article-2688-1.html\" target=\"_blank\" rel=\"noopener\">https://linux.cn/article-2688-1.html</a></li>\n<li>查看系统版本：<a href=\"http://www.linuxidc.com/Linux/2015-07/119897.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxidc.com/Linux/2015-07/119897.htm</a><a id=\"more\"></a>\n</li>\n</ol>\n<h3 id=\"vim相关\"><a href=\"#vim相关\" class=\"headerlink\" title=\"vim相关\"></a>vim相关</h3><ol>\n<li>vim的配置：<a href=\"http://blog.csdn.net/footmart_c/article/details/51588524\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/footmart_c/article/details/51588524</a></li>\n<li>多行删除复制：<a href=\"https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html</a></li>\n<li>vim安装报错EXTERN.h：<a href=\"http://tieba.baidu.com/p/4471948063\" target=\"_blank\" rel=\"noopener\">http://tieba.baidu.com/p/4471948063</a></li>\n<li>vim升级8.0+YouCompleteMe补全插件：<a href=\"http://blog.csdn.net/nzyalj/article/details/75331822\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/nzyalj/article/details/75331822</a></li>\n<li>vim8.0升级后添加到路径中：<a href=\"http://blog.csdn.net/u013388603/article/details/72780586\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u013388603/article/details/72780586</a></li>\n<li>YouCompleteMe：<a href=\"http://blog.51cto.com/990487026/1905427\" target=\"_blank\" rel=\"noopener\">http://blog.51cto.com/990487026/1905427</a></li>\n</ol>\n<h3 id=\"git相关\"><a href=\"#git相关\" class=\"headerlink\" title=\"git相关\"></a>git相关</h3><ol>\n<li>git安装：<a href=\"https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html\" target=\"_blank\" rel=\"noopener\">https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html</a></li>\n<li>git安装：<a href=\"http://blog.csdn.net/u013256816/article/details/54743470\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u013256816/article/details/54743470</a></li>\n<li>git升级2.7.3：<a href=\"https://www.cnblogs.com/yexinw/p/6401663.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yexinw/p/6401663.html</a></li>\n</ol>\n<h3 id=\"python相关\"><a href=\"#python相关\" class=\"headerlink\" title=\"python相关\"></a>python相关</h3><ol>\n<li>2.6升级2.7：<a href=\"https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html</a></li>\n<li>安装3.5.2并与python2共存：<a href=\"https://www.ywlib.com/archives/96-1.html\" target=\"_blank\" rel=\"noopener\">https://www.ywlib.com/archives/96-1.html</a></li>\n</ol>\n<h3 id=\"输入相关\"><a href=\"#输入相关\" class=\"headerlink\" title=\"输入相关\"></a>输入相关</h3><ol>\n<li>python造成 input method preferences无效：<a href=\"http://blog.csdn.net/jaket5219999/article/details/52912321\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/jaket5219999/article/details/52912321</a></li>\n<li>安装Fcitx 4.0.0：<a href=\"https://www.douban.com/note/319236531/\" target=\"_blank\" rel=\"noopener\">https://www.douban.com/note/319236531/</a></li>\n<li>设置Fcitx默认：<a href=\"https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html\" target=\"_blank\" rel=\"noopener\">https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html</a></li>\n<li>ibus开启：<a href=\"http://blog.csdn.net/zitong_ccnu/article/details/40110583\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zitong_ccnu/article/details/40110583</a></li>\n</ol>\n<h3 id=\"源相关\"><a href=\"#源相关\" class=\"headerlink\" title=\"源相关\"></a>源相关</h3><ol>\n<li>Nux Dextop源：<a href=\"http://www.linuxidc.com/Linux/2016-06/132101.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxidc.com/Linux/2016-06/132101.htm</a></li>\n<li>yum源解析（详细）：<a href=\"https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html</a></li>\n</ol>\n<h3 id=\"Hexo相关\"><a href=\"#Hexo相关\" class=\"headerlink\" title=\"Hexo相关\"></a>Hexo相关</h3><ul>\n<li>gcc升级：<a href=\"http://www.cnblogs.com/lpbottle/p/install_gcc.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/lpbottle/p/install_gcc.html</a></li>\n<li>gcc升级：<a href=\"http://blog.csdn.net/furzoom/article/details/53322510\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/furzoom/article/details/53322510</a></li>\n<li>gcc升级：<a href=\"http://blog.csdn.net/zr1076311296/article/details/51334538\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zr1076311296/article/details/51334538</a></li>\n<li>Nodejs安装：<a href=\"https://www.cnblogs.com/lpbottle/p/7733397.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lpbottle/p/7733397.html</a></li>\n</ul>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><ol>\n<li>/mnt/hgfs没有共享文件夹：<a href=\"http://www.mamicode.com/info-detail-1655589.html\" target=\"_blank\" rel=\"noopener\">http://www.mamicode.com/info-detail-1655589.html</a></li>\n<li>Linux就该这么学：<a href=\"http://www.linuxprobe.com/chapter-00.html\" target=\"_blank\" rel=\"noopener\">http://www.linuxprobe.com/chapter-00.html</a></li>\n</ol>\n<h2 id=\"2、C语言\"><a href=\"#2、C语言\" class=\"headerlink\" title=\"2、C语言\"></a><strong>2、C语言</strong></h2><ol>\n<li>链表相关笔试题：<a href=\"http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html</a></li>\n</ol>\n<h2 id=\"3、GitHub\"><a href=\"#3、GitHub\" class=\"headerlink\" title=\"3、GitHub\"></a><strong>3、GitHub</strong></h2><ol>\n<li>知乎：<a href=\"https://www.zhihu.com/question/20070065\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/20070065</a></li>\n<li>他的网站里有：<a href=\"http://youngxhui.github.io/\" target=\"_blank\" rel=\"noopener\">http://youngxhui.github.io/</a></li>\n</ol>\n<ul>\n<li>以下，搭建自己的github博客：</li>\n<li>配置详细：<a href=\"https://www.jianshu.com/p/b7886271e21a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b7886271e21a</a></li>\n<li>很强大的一个：<a href=\"http://kchen.cc/2016/11/12/hexo-instructions/\" target=\"_blank\" rel=\"noopener\">http://kchen.cc/2016/11/12/hexo-instructions/</a></li>\n<li>WordPress和Hexo以及md编辑器：<a href=\"https://www.imooc.com/article/12257\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/article/12257</a></li>\n<li>localhost:4000出问题：<a href=\"http://blog.csdn.net/u012246342/article/details/51543370\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u012246342/article/details/51543370</a></li>\n<li>Hexo问题总结：<a href=\"http://blog.csdn.net/wx_962464/article/details/44786929\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/wx_962464/article/details/44786929</a></li>\n</ul>\n<h2 id=\"4、blog\"><a href=\"#4、blog\" class=\"headerlink\" title=\"4、blog\"></a><strong>4、blog</strong></h2><ol>\n<li><a href=\"http://www.zipperary.com/\" target=\"_blank\" rel=\"noopener\">http://www.zipperary.com/</a></li>\n<li>陈皓：<a href=\"https://coolshell.cn/featured\" target=\"_blank\" rel=\"noopener\">https://coolshell.cn/featured</a></li>\n</ol>\n<h2 id=\"5、其它\"><a href=\"#5、其它\" class=\"headerlink\" title=\"5、其它\"></a><strong>5、其它</strong></h2><ol>\n<li>msdn：<a href=\"https://msdn.itellyou.cn/\" target=\"_blank\" rel=\"noopener\">https://msdn.itellyou.cn/</a></li>\n<li>NTFS和FAT32区别：<a href=\"http://www.ntfsformac.cn/qita-nytqubie.html\" target=\"_blank\" rel=\"noopener\">http://www.ntfsformac.cn/qita-nytqubie.html</a></li>\n<li>SQL源码剖析：<a href=\"http://deepfuture.iteye.com/blog/718478\" target=\"_blank\" rel=\"noopener\">http://deepfuture.iteye.com/blog/718478</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"1、Linux\"><a href=\"#1、Linux\" class=\"headerlink\" title=\"1、Linux\"></a><strong>1、Linux</strong></h2><h3 id=\"命令相关\"><a href=\"#命令相关\" class=\"headerlink\" title=\"命令相关\"></a>命令相关</h3><ol>\n<li>Linux命令大全：<a href=\"http://man.linuxde.net/\" target=\"_blank\" rel=\"noopener\">http://man.linuxde.net/</a></li>\n<li>修改时间查看时间：<a href=\"https://www.cnblogs.com/jiu0821/p/5999566.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/jiu0821/p/5999566.html</a></li>\n<li>移动、重命名文件/目录：<a href=\"https://linux.cn/article-2688-1.html\" target=\"_blank\" rel=\"noopener\">https://linux.cn/article-2688-1.html</a></li>\n<li>查看系统版本：<a href=\"http://www.linuxidc.com/Linux/2015-07/119897.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxidc.com/Linux/2015-07/119897.htm</a>","more":"</li>\n</ol>\n<h3 id=\"vim相关\"><a href=\"#vim相关\" class=\"headerlink\" title=\"vim相关\"></a>vim相关</h3><ol>\n<li>vim的配置：<a href=\"http://blog.csdn.net/footmart_c/article/details/51588524\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/footmart_c/article/details/51588524</a></li>\n<li>多行删除复制：<a href=\"https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html</a></li>\n<li>vim安装报错EXTERN.h：<a href=\"http://tieba.baidu.com/p/4471948063\" target=\"_blank\" rel=\"noopener\">http://tieba.baidu.com/p/4471948063</a></li>\n<li>vim升级8.0+YouCompleteMe补全插件：<a href=\"http://blog.csdn.net/nzyalj/article/details/75331822\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/nzyalj/article/details/75331822</a></li>\n<li>vim8.0升级后添加到路径中：<a href=\"http://blog.csdn.net/u013388603/article/details/72780586\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u013388603/article/details/72780586</a></li>\n<li>YouCompleteMe：<a href=\"http://blog.51cto.com/990487026/1905427\" target=\"_blank\" rel=\"noopener\">http://blog.51cto.com/990487026/1905427</a></li>\n</ol>\n<h3 id=\"git相关\"><a href=\"#git相关\" class=\"headerlink\" title=\"git相关\"></a>git相关</h3><ol>\n<li>git安装：<a href=\"https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html\" target=\"_blank\" rel=\"noopener\">https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html</a></li>\n<li>git安装：<a href=\"http://blog.csdn.net/u013256816/article/details/54743470\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u013256816/article/details/54743470</a></li>\n<li>git升级2.7.3：<a href=\"https://www.cnblogs.com/yexinw/p/6401663.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yexinw/p/6401663.html</a></li>\n</ol>\n<h3 id=\"python相关\"><a href=\"#python相关\" class=\"headerlink\" title=\"python相关\"></a>python相关</h3><ol>\n<li>2.6升级2.7：<a href=\"https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html</a></li>\n<li>安装3.5.2并与python2共存：<a href=\"https://www.ywlib.com/archives/96-1.html\" target=\"_blank\" rel=\"noopener\">https://www.ywlib.com/archives/96-1.html</a></li>\n</ol>\n<h3 id=\"输入相关\"><a href=\"#输入相关\" class=\"headerlink\" title=\"输入相关\"></a>输入相关</h3><ol>\n<li>python造成 input method preferences无效：<a href=\"http://blog.csdn.net/jaket5219999/article/details/52912321\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/jaket5219999/article/details/52912321</a></li>\n<li>安装Fcitx 4.0.0：<a href=\"https://www.douban.com/note/319236531/\" target=\"_blank\" rel=\"noopener\">https://www.douban.com/note/319236531/</a></li>\n<li>设置Fcitx默认：<a href=\"https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html\" target=\"_blank\" rel=\"noopener\">https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html</a></li>\n<li>ibus开启：<a href=\"http://blog.csdn.net/zitong_ccnu/article/details/40110583\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zitong_ccnu/article/details/40110583</a></li>\n</ol>\n<h3 id=\"源相关\"><a href=\"#源相关\" class=\"headerlink\" title=\"源相关\"></a>源相关</h3><ol>\n<li>Nux Dextop源：<a href=\"http://www.linuxidc.com/Linux/2016-06/132101.htm\" target=\"_blank\" rel=\"noopener\">http://www.linuxidc.com/Linux/2016-06/132101.htm</a></li>\n<li>yum源解析（详细）：<a href=\"https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html</a></li>\n</ol>\n<h3 id=\"Hexo相关\"><a href=\"#Hexo相关\" class=\"headerlink\" title=\"Hexo相关\"></a>Hexo相关</h3><ul>\n<li>gcc升级：<a href=\"http://www.cnblogs.com/lpbottle/p/install_gcc.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/lpbottle/p/install_gcc.html</a></li>\n<li>gcc升级：<a href=\"http://blog.csdn.net/furzoom/article/details/53322510\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/furzoom/article/details/53322510</a></li>\n<li>gcc升级：<a href=\"http://blog.csdn.net/zr1076311296/article/details/51334538\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zr1076311296/article/details/51334538</a></li>\n<li>Nodejs安装：<a href=\"https://www.cnblogs.com/lpbottle/p/7733397.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lpbottle/p/7733397.html</a></li>\n</ul>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><ol>\n<li>/mnt/hgfs没有共享文件夹：<a href=\"http://www.mamicode.com/info-detail-1655589.html\" target=\"_blank\" rel=\"noopener\">http://www.mamicode.com/info-detail-1655589.html</a></li>\n<li>Linux就该这么学：<a href=\"http://www.linuxprobe.com/chapter-00.html\" target=\"_blank\" rel=\"noopener\">http://www.linuxprobe.com/chapter-00.html</a></li>\n</ol>\n<h2 id=\"2、C语言\"><a href=\"#2、C语言\" class=\"headerlink\" title=\"2、C语言\"></a><strong>2、C语言</strong></h2><ol>\n<li>链表相关笔试题：<a href=\"http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html</a></li>\n</ol>\n<h2 id=\"3、GitHub\"><a href=\"#3、GitHub\" class=\"headerlink\" title=\"3、GitHub\"></a><strong>3、GitHub</strong></h2><ol>\n<li>知乎：<a href=\"https://www.zhihu.com/question/20070065\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/20070065</a></li>\n<li>他的网站里有：<a href=\"http://youngxhui.github.io/\" target=\"_blank\" rel=\"noopener\">http://youngxhui.github.io/</a></li>\n</ol>\n<ul>\n<li>以下，搭建自己的github博客：</li>\n<li>配置详细：<a href=\"https://www.jianshu.com/p/b7886271e21a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b7886271e21a</a></li>\n<li>很强大的一个：<a href=\"http://kchen.cc/2016/11/12/hexo-instructions/\" target=\"_blank\" rel=\"noopener\">http://kchen.cc/2016/11/12/hexo-instructions/</a></li>\n<li>WordPress和Hexo以及md编辑器：<a href=\"https://www.imooc.com/article/12257\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/article/12257</a></li>\n<li>localhost:4000出问题：<a href=\"http://blog.csdn.net/u012246342/article/details/51543370\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u012246342/article/details/51543370</a></li>\n<li>Hexo问题总结：<a href=\"http://blog.csdn.net/wx_962464/article/details/44786929\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/wx_962464/article/details/44786929</a></li>\n</ul>\n<h2 id=\"4、blog\"><a href=\"#4、blog\" class=\"headerlink\" title=\"4、blog\"></a><strong>4、blog</strong></h2><ol>\n<li><a href=\"http://www.zipperary.com/\" target=\"_blank\" rel=\"noopener\">http://www.zipperary.com/</a></li>\n<li>陈皓：<a href=\"https://coolshell.cn/featured\" target=\"_blank\" rel=\"noopener\">https://coolshell.cn/featured</a></li>\n</ol>\n<h2 id=\"5、其它\"><a href=\"#5、其它\" class=\"headerlink\" title=\"5、其它\"></a><strong>5、其它</strong></h2><ol>\n<li>msdn：<a href=\"https://msdn.itellyou.cn/\" target=\"_blank\" rel=\"noopener\">https://msdn.itellyou.cn/</a></li>\n<li>NTFS和FAT32区别：<a href=\"http://www.ntfsformac.cn/qita-nytqubie.html\" target=\"_blank\" rel=\"noopener\">http://www.ntfsformac.cn/qita-nytqubie.html</a></li>\n<li>SQL源码剖析：<a href=\"http://deepfuture.iteye.com/blog/718478\" target=\"_blank\" rel=\"noopener\">http://deepfuture.iteye.com/blog/718478</a></li>\n</ol>"},{"title":"1+2+……+n的特殊求法","date":"2018-01-26T16:44:40.000Z","_content":"## 题目：\n**求1+2+3+...+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。**\n\n自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&&的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。\n\n### 更新：18.1.28\n发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了[柔性数组](https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html)，这种数组的长度的可变的，不需要用常量定义。\n\n<!-- more -->\n\n```c++\nclass Solution{\n    public:\n        int Sum_Solution( int n ){\n            bool a[n][n+1];\n            return sizeof(a)>>1;\n        }\n};\nint main(){\n    Solution s;\n    cout << s.Sum_Solution(10) << endl;\n    return 0;\n}\n```\n\n---\n原文：\n### 利用&&操作符，|| 也一样的做法。\n\n思路：当result = 0 的时候，&&不再判断右操作数，递归停止。\n\n```c++\nint sum( int n ){\n    int result = n;\n    result && (result += sum(n-1));\n    return result;\n}\nint main(){\n    cout << sum(100) << endl;\n    return 0;\n}\n```\n\n### 利用构造函数以及静态成员变量\n思路：构造N次对象，每次对静态变量sum++，对n赋值。利用静态变量对所有同类对象有效的特点。\n\n```c++\nclass tmp{\npublic:\n    //构造\n    tmp( ){\n        ++n;\n        sum += n;\n    }\n    //初始化\n    void static init(){\n        n = 0;\n        sum = 0;\n    }\n    //获得sum\n    int static getsum(){\n        return sum;\n    }\nprivate:\n    static int n;\n    static int sum;\n};\n\nint tmp::n = 0;\nint tmp::sum = 0;\n//运行的函数\nint count(int n){\n    tmp::init();\n    tmp* a = new tmp[n];\n    delete[] a;\n    a = NULL;\n    tmp::getsum();\n}\nint main(){\n    cout << count(100) << endl;\n    return 0;\n}\n```\n\n### 利用虚函数、继承和函数指针\n思路：\n1. 定义两个类，A是基类，B是子类。\n2. 定义一个`A* Array[2]`,其中Array[0]存放A对象的地址，Array[1]存放B对象的地址。\n3. 调用函数Sum中调用Sum的递归。同时对变量n两次取反`Array[!!n]->Sum(n-1)+n`,这样当n不为0的时候，得到bool值1。`Array[!!n] = Array[1]`\n4. 当n=0调用基类A的sum。充分利用虚函数参数与类型有关的性质。\n\n```c++\n//1、虚函数\n#include <iostream>\nusing namespace std;\nclass A;\nA* Array[2];\nclass A{\npublic:\n    virtual int Sum( int n ){\n        return 0;\n    }\n};\nclass B:public A{\npublic:\n    virtual int Sum( int n ){\n        //当 n != 0, !!n = 1\n        return Array[!!n]->Sum(n-1)+n;\n    }\n};\n\nint Sum2( int n ){\n    A a;\n    B b;\n    Array[0] = &a;\n    Array[1] = &b;\n    //调用虚函数\n    int value = Array[1]->Sum(n);\n    return value;\n}\nint main(){\n    cout << Sum2(100) << endl;\n    return 0;\n}\n\n//2、同上，这里利用函数指针来实现。\ntypedef int (*fun)(int);\n\nint Sum( int i ){\n    return 0;\n}\nint Sum2( int i ){\n    fun f[2] = { Sum, Sum2 };\n    return i + f[!!n](i-1);\n}\n```\n\n### 利用异常处理的机制\n思路：try接收到的异常会在catch中捕获。\n\n```c++\nint sum(int n){\n    try{\n        //n = 2 的时候，出现异常，程序流跳转到catch\n        int[] array = new int[n-2];\n        return n+sum(n-1);\n    }\n    catch(Exception e){\n        //返回1到上一个递归处，n = 2处。\n        return 1;\n    }\n}\n```\n\n### 利用模板\n思路：利用了模板的特化作为递归结束的条件，并借用枚举类型。\n\n```c++\n#include <iostream>\nusing namespace std;\n\ntemplate <unsigned N>\nclass Sum{\n    public:\n        enum{\n            sum = N+Sum<N-1>::sum\n        };\n};\n//模板特化，当N=1 的时候，调用\ntemplate<>\nclass Sum<1>{\n    public:\n        enum{\n            sum = 1\n        };\n};\nint main(){\n    cout << Sum<100>::sum << endl;\n    return 0;\n}\n\n```\n### [方法来源地址](http://blog.csdn.net/u010993983/article/details/37730317)","source":"_posts/1-……-n的特殊求法.md","raw":"---\ntitle: 1+2+……+n的特殊求法\ndate: 2018-01-27 00:44:40\ncategory:\n    - \"practice\"\n    - \"C/C++\"\n---\n## 题目：\n**求1+2+3+...+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。**\n\n自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&&的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。\n\n### 更新：18.1.28\n发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了[柔性数组](https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html)，这种数组的长度的可变的，不需要用常量定义。\n\n<!-- more -->\n\n```c++\nclass Solution{\n    public:\n        int Sum_Solution( int n ){\n            bool a[n][n+1];\n            return sizeof(a)>>1;\n        }\n};\nint main(){\n    Solution s;\n    cout << s.Sum_Solution(10) << endl;\n    return 0;\n}\n```\n\n---\n原文：\n### 利用&&操作符，|| 也一样的做法。\n\n思路：当result = 0 的时候，&&不再判断右操作数，递归停止。\n\n```c++\nint sum( int n ){\n    int result = n;\n    result && (result += sum(n-1));\n    return result;\n}\nint main(){\n    cout << sum(100) << endl;\n    return 0;\n}\n```\n\n### 利用构造函数以及静态成员变量\n思路：构造N次对象，每次对静态变量sum++，对n赋值。利用静态变量对所有同类对象有效的特点。\n\n```c++\nclass tmp{\npublic:\n    //构造\n    tmp( ){\n        ++n;\n        sum += n;\n    }\n    //初始化\n    void static init(){\n        n = 0;\n        sum = 0;\n    }\n    //获得sum\n    int static getsum(){\n        return sum;\n    }\nprivate:\n    static int n;\n    static int sum;\n};\n\nint tmp::n = 0;\nint tmp::sum = 0;\n//运行的函数\nint count(int n){\n    tmp::init();\n    tmp* a = new tmp[n];\n    delete[] a;\n    a = NULL;\n    tmp::getsum();\n}\nint main(){\n    cout << count(100) << endl;\n    return 0;\n}\n```\n\n### 利用虚函数、继承和函数指针\n思路：\n1. 定义两个类，A是基类，B是子类。\n2. 定义一个`A* Array[2]`,其中Array[0]存放A对象的地址，Array[1]存放B对象的地址。\n3. 调用函数Sum中调用Sum的递归。同时对变量n两次取反`Array[!!n]->Sum(n-1)+n`,这样当n不为0的时候，得到bool值1。`Array[!!n] = Array[1]`\n4. 当n=0调用基类A的sum。充分利用虚函数参数与类型有关的性质。\n\n```c++\n//1、虚函数\n#include <iostream>\nusing namespace std;\nclass A;\nA* Array[2];\nclass A{\npublic:\n    virtual int Sum( int n ){\n        return 0;\n    }\n};\nclass B:public A{\npublic:\n    virtual int Sum( int n ){\n        //当 n != 0, !!n = 1\n        return Array[!!n]->Sum(n-1)+n;\n    }\n};\n\nint Sum2( int n ){\n    A a;\n    B b;\n    Array[0] = &a;\n    Array[1] = &b;\n    //调用虚函数\n    int value = Array[1]->Sum(n);\n    return value;\n}\nint main(){\n    cout << Sum2(100) << endl;\n    return 0;\n}\n\n//2、同上，这里利用函数指针来实现。\ntypedef int (*fun)(int);\n\nint Sum( int i ){\n    return 0;\n}\nint Sum2( int i ){\n    fun f[2] = { Sum, Sum2 };\n    return i + f[!!n](i-1);\n}\n```\n\n### 利用异常处理的机制\n思路：try接收到的异常会在catch中捕获。\n\n```c++\nint sum(int n){\n    try{\n        //n = 2 的时候，出现异常，程序流跳转到catch\n        int[] array = new int[n-2];\n        return n+sum(n-1);\n    }\n    catch(Exception e){\n        //返回1到上一个递归处，n = 2处。\n        return 1;\n    }\n}\n```\n\n### 利用模板\n思路：利用了模板的特化作为递归结束的条件，并借用枚举类型。\n\n```c++\n#include <iostream>\nusing namespace std;\n\ntemplate <unsigned N>\nclass Sum{\n    public:\n        enum{\n            sum = N+Sum<N-1>::sum\n        };\n};\n//模板特化，当N=1 的时候，调用\ntemplate<>\nclass Sum<1>{\n    public:\n        enum{\n            sum = 1\n        };\n};\nint main(){\n    cout << Sum<100>::sum << endl;\n    return 0;\n}\n\n```\n### [方法来源地址](http://blog.csdn.net/u010993983/article/details/37730317)","slug":"1-……-n的特殊求法","published":1,"updated":"2018-02-08T06:20:15.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nqyo000404d84l1ffc2o","content":"<h2 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h2><p><strong>求1+2+3+…+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。</strong></p>\n<p>自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&amp;&amp;的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。</p>\n<h3 id=\"更新：18-1-28\"><a href=\"#更新：18-1-28\" class=\"headerlink\" title=\"更新：18.1.28\"></a>更新：18.1.28</h3><p>发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了<a href=\"https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html\" target=\"_blank\" rel=\"noopener\">柔性数组</a>，这种数组的长度的可变的，不需要用常量定义。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Sum_Solution</span><span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> a[n][n+<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(a)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Solution s;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.Sum_Solution(<span class=\"number\">10</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>原文：</p>\n<h3 id=\"利用-amp-amp-操作符，-也一样的做法。\"><a href=\"#利用-amp-amp-操作符，-也一样的做法。\" class=\"headerlink\" title=\"利用&amp;&amp;操作符，|| 也一样的做法。\"></a>利用&amp;&amp;操作符，|| 也一样的做法。</h3><p>思路：当result = 0 的时候，&amp;&amp;不再判断右操作数，递归停止。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = n;</span><br><span class=\"line\">    result &amp;&amp; (result += sum(n<span class=\"number\">-1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; sum(<span class=\"number\">100</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用构造函数以及静态成员变量\"><a href=\"#利用构造函数以及静态成员变量\" class=\"headerlink\" title=\"利用构造函数以及静态成员变量\"></a>利用构造函数以及静态成员变量</h3><p>思路：构造N次对象，每次对静态变量sum++，对n赋值。利用静态变量对所有同类对象有效的特点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tmp</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//构造</span></span><br><span class=\"line\">    tmp( )&#123;</span><br><span class=\"line\">        ++n;</span><br><span class=\"line\">        sum += n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">static</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获得sum</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"keyword\">static</span> <span class=\"title\">getsum</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp::n = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp::sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    tmp::init();</span><br><span class=\"line\">    tmp* a = <span class=\"keyword\">new</span> tmp[n];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] a;</span><br><span class=\"line\">    a = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    tmp::getsum();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; count(<span class=\"number\">100</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用虚函数、继承和函数指针\"><a href=\"#利用虚函数、继承和函数指针\" class=\"headerlink\" title=\"利用虚函数、继承和函数指针\"></a>利用虚函数、继承和函数指针</h3><p>思路：</p>\n<ol>\n<li>定义两个类，A是基类，B是子类。</li>\n<li>定义一个<code>A* Array[2]</code>,其中Array[0]存放A对象的地址，Array[1]存放B对象的地址。</li>\n<li>调用函数Sum中调用Sum的递归。同时对变量n两次取反<code>Array[!!n]-&gt;Sum(n-1)+n</code>,这样当n不为0的时候，得到bool值1。<code>Array[!!n] = Array[1]</code></li>\n<li>当n=0调用基类A的sum。充分利用虚函数参数与类型有关的性质。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、虚函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\">A* Array[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">Sum</span><span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span><span class=\"keyword\">public</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">Sum</span><span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//当 n != 0, !!n = 1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Array[!!n]-&gt;Sum(n<span class=\"number\">-1</span>)+n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Sum2</span><span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    A a;</span><br><span class=\"line\">    B b;</span><br><span class=\"line\">    Array[<span class=\"number\">0</span>] = &amp;a;</span><br><span class=\"line\">    Array[<span class=\"number\">1</span>] = &amp;b;</span><br><span class=\"line\">    <span class=\"comment\">//调用虚函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> value = Array[<span class=\"number\">1</span>]-&gt;Sum(n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; Sum2(<span class=\"number\">100</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、同上，这里利用函数指针来实现。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*fun)</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Sum</span><span class=\"params\">( <span class=\"keyword\">int</span> i )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Sum2</span><span class=\"params\">( <span class=\"keyword\">int</span> i )</span></span>&#123;</span><br><span class=\"line\">    fun f[<span class=\"number\">2</span>] = &#123; Sum, Sum2 &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i + f[!!n](i<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用异常处理的机制\"><a href=\"#利用异常处理的机制\" class=\"headerlink\" title=\"利用异常处理的机制\"></a>利用异常处理的机制</h3><p>思路：try接收到的异常会在catch中捕获。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//n = 2 的时候，出现异常，程序流跳转到catch</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] <span class=\"built_in\">array</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n<span class=\"number\">-2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n+sum(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//返回1到上一个递归处，n = 2处。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用模板\"><a href=\"#利用模板\" class=\"headerlink\" title=\"利用模板\"></a>利用模板</h3><p>思路：利用了模板的特化作为递归结束的条件，并借用枚举类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">unsigned</span> N&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sum</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">enum</span>&#123;</span><br><span class=\"line\">            sum = N+Sum&lt;N<span class=\"number\">-1</span>&gt;::sum</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//模板特化，当N=1 的时候，调用</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sum</span>&lt;1&gt;&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">enum</span>&#123;</span><br><span class=\"line\">            sum = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; Sum&lt;<span class=\"number\">100</span>&gt;::sum &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法来源地址\"><a href=\"#方法来源地址\" class=\"headerlink\" title=\"方法来源地址\"></a><a href=\"http://blog.csdn.net/u010993983/article/details/37730317\" target=\"_blank\" rel=\"noopener\">方法来源地址</a></h3>","site":{"data":{}},"excerpt":"<h2 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h2><p><strong>求1+2+3+…+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。</strong></p>\n<p>自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&amp;&amp;的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。</p>\n<h3 id=\"更新：18-1-28\"><a href=\"#更新：18-1-28\" class=\"headerlink\" title=\"更新：18.1.28\"></a>更新：18.1.28</h3><p>发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了<a href=\"https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html\" target=\"_blank\" rel=\"noopener\">柔性数组</a>，这种数组的长度的可变的，不需要用常量定义。</p>","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Sum_Solution</span><span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> a[n][n+<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(a)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Solution s;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.Sum_Solution(<span class=\"number\">10</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>原文：</p>\n<h3 id=\"利用-amp-amp-操作符，-也一样的做法。\"><a href=\"#利用-amp-amp-操作符，-也一样的做法。\" class=\"headerlink\" title=\"利用&amp;&amp;操作符，|| 也一样的做法。\"></a>利用&amp;&amp;操作符，|| 也一样的做法。</h3><p>思路：当result = 0 的时候，&amp;&amp;不再判断右操作数，递归停止。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = n;</span><br><span class=\"line\">    result &amp;&amp; (result += sum(n<span class=\"number\">-1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; sum(<span class=\"number\">100</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用构造函数以及静态成员变量\"><a href=\"#利用构造函数以及静态成员变量\" class=\"headerlink\" title=\"利用构造函数以及静态成员变量\"></a>利用构造函数以及静态成员变量</h3><p>思路：构造N次对象，每次对静态变量sum++，对n赋值。利用静态变量对所有同类对象有效的特点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tmp</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//构造</span></span><br><span class=\"line\">    tmp( )&#123;</span><br><span class=\"line\">        ++n;</span><br><span class=\"line\">        sum += n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">static</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获得sum</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"keyword\">static</span> <span class=\"title\">getsum</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp::n = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp::sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//运行的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    tmp::init();</span><br><span class=\"line\">    tmp* a = <span class=\"keyword\">new</span> tmp[n];</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] a;</span><br><span class=\"line\">    a = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    tmp::getsum();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; count(<span class=\"number\">100</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用虚函数、继承和函数指针\"><a href=\"#利用虚函数、继承和函数指针\" class=\"headerlink\" title=\"利用虚函数、继承和函数指针\"></a>利用虚函数、继承和函数指针</h3><p>思路：</p>\n<ol>\n<li>定义两个类，A是基类，B是子类。</li>\n<li>定义一个<code>A* Array[2]</code>,其中Array[0]存放A对象的地址，Array[1]存放B对象的地址。</li>\n<li>调用函数Sum中调用Sum的递归。同时对变量n两次取反<code>Array[!!n]-&gt;Sum(n-1)+n</code>,这样当n不为0的时候，得到bool值1。<code>Array[!!n] = Array[1]</code></li>\n<li>当n=0调用基类A的sum。充分利用虚函数参数与类型有关的性质。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、虚函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\">A* Array[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">Sum</span><span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span><span class=\"keyword\">public</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">Sum</span><span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//当 n != 0, !!n = 1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Array[!!n]-&gt;Sum(n<span class=\"number\">-1</span>)+n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Sum2</span><span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    A a;</span><br><span class=\"line\">    B b;</span><br><span class=\"line\">    Array[<span class=\"number\">0</span>] = &amp;a;</span><br><span class=\"line\">    Array[<span class=\"number\">1</span>] = &amp;b;</span><br><span class=\"line\">    <span class=\"comment\">//调用虚函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> value = Array[<span class=\"number\">1</span>]-&gt;Sum(n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; Sum2(<span class=\"number\">100</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、同上，这里利用函数指针来实现。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*fun)</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Sum</span><span class=\"params\">( <span class=\"keyword\">int</span> i )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Sum2</span><span class=\"params\">( <span class=\"keyword\">int</span> i )</span></span>&#123;</span><br><span class=\"line\">    fun f[<span class=\"number\">2</span>] = &#123; Sum, Sum2 &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i + f[!!n](i<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用异常处理的机制\"><a href=\"#利用异常处理的机制\" class=\"headerlink\" title=\"利用异常处理的机制\"></a>利用异常处理的机制</h3><p>思路：try接收到的异常会在catch中捕获。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//n = 2 的时候，出现异常，程序流跳转到catch</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] <span class=\"built_in\">array</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n<span class=\"number\">-2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n+sum(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//返回1到上一个递归处，n = 2处。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用模板\"><a href=\"#利用模板\" class=\"headerlink\" title=\"利用模板\"></a>利用模板</h3><p>思路：利用了模板的特化作为递归结束的条件，并借用枚举类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">unsigned</span> N&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sum</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">enum</span>&#123;</span><br><span class=\"line\">            sum = N+Sum&lt;N<span class=\"number\">-1</span>&gt;::sum</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//模板特化，当N=1 的时候，调用</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sum</span>&lt;1&gt;&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">enum</span>&#123;</span><br><span class=\"line\">            sum = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; Sum&lt;<span class=\"number\">100</span>&gt;::sum &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法来源地址\"><a href=\"#方法来源地址\" class=\"headerlink\" title=\"方法来源地址\"></a><a href=\"http://blog.csdn.net/u010993983/article/details/37730317\" target=\"_blank\" rel=\"noopener\">方法来源地址</a></h3>"},{"title":"Linux中时间的设置","date":"2018-03-08T03:36:45.000Z","keywords":["Linux","date"],"password":null,"_content":"test: CentOS Linux release 7.4.1708 (Core)\n#### 查看时区\n> **data -R**\n\n![查看时区](http://p3ax8ersb.bkt.clouddn.com/201803081634_167.png-960.jpg)\n+0800 表示在东八区\n其中：\nCST：中国标准时间（China Standard Time），这个解释可能是针对RedHat Linux。\nUTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。UTC较于GMT更准确。\nGMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。\n#### 修改时区\n> **tzselect**\n\n<!--more-->\n![tzselect1](http://p3ax8ersb.bkt.clouddn.com/201803081645_514.png-960.jpg)\n**这个命令并不是用来修改时区的**，这个命令可以通过你自己的选择然后清楚的知道每个时区的样式。然后你通过修改.progile、.bash_profile或者/etc/profile文件，设置正确的TZ环境变量并导出，可以成功改变时区。\n![tzselect2](http://p3ax8ersb.bkt.clouddn.com/201803081647_798.png-960.jpg)\n\n**tip：这些修改应该出现用户家目录下**\n下面例子，我将时区由东八区改变为波兰的时区，东一区：\n先通过tzselect查询波兰的时区书写格式：\n![tzselect3](http://p3ax8ersb.bkt.clouddn.com/201803081702_845.png-960.jpg)\n然后通过修改文件.bash_profile并应用得以修改。\n![tzselect4](http://p3ax8ersb.bkt.clouddn.com/201803081701_60.png-960.jpg)\n> **通过替换系统时区文件，或者创建链接文件**\n\n1、在目录/usr/share/zoneinfo中有所有的时区文件，通过复制替换到/etc/locatime即可\n![替换](http://p3ax8ersb.bkt.clouddn.com/201803081715_394.png-960.jpg)\n但是有的时候会出现没有效果的情况，比如上例子。这是因为修改了在profile或.bash_profile中设置了TZ。这个时候就需要重新修改TZ。\n\n2、创建链接文件\n这里如果出现修改失败，同上。\n![ln](http://p3ax8ersb.bkt.clouddn.com/201803081722_543.png-960.jpg)\n\n#### 查看和修改时间和日期\n> **date**\n> date用于查看和设置 **系统时间**\n\n![date](http://p3ax8ersb.bkt.clouddn.com/201803081733_375.png-960.jpg)\n如果不输入命令\"hwclock -w\"将时间写入硬件时间，电脑重启之后将会返回原样。\n> **hwclock**\n> hwclock用来查看设置 **硬件时间**。\n\n> **hwclock --hctosys**\n> hc代表硬件时间，sys代表系统时间，即用硬件时钟同步系统时钟\n\n> **hwclock --systohc**\n> 即用系统时钟同步硬件时钟,等于 **hwclock -w**\n\n执行完这两个命令系统没有任何反馈。\n![hwclock](http://p3ax8ersb.bkt.clouddn.com/201803081739_539.png-960.jpg)\n\n解释一下硬件时钟和系统时钟的区别：\n硬件时钟指的是主板上由电池供电的那个时间，可以在BIOS中设置。**Linux可以通过hwclock设置。当Linux启动的时候，硬件时钟会赋值给系统时钟。然后系统时钟会独立于硬件时钟工作。**\n系统时钟指的是当前Linux Kernel中的时钟。Linux中的所有命令包括函数都是采用系统时钟设置的。\n这就是为什么当我们用date修改了时间，没有同步到硬件时钟的时候，这个修改是无效的。\n\n#### 时间自动同步\n> **yum install -y ntpdate**\n首先安装ntpdate软件，用来同步Linux时间服务。\n\n> **ntpdate time.nist.gov**\n\n![ntpdate](http://p3ax8ersb.bkt.clouddn.com/201803081941_193.png-960.jpg)\n上面表示同步成功，调整时间为服务器129.6.15.29的时间，时间相差0.136318 sec\n\n> **hwclock -w**\n调整硬件时间\n\n> **crontab -e**\n设定crontab计划任务自动校时，并添加下列内容\n**0 1 * * * ntpdate time.nist.gov**\n这样设定一个小时自动进行网络校时。\n\n通过cat /etc/crontab 查看crontab的设置解释，如下：\n![crontab](http://p3ax8ersb.bkt.clouddn.com/201803082006_609.png-1920.jpg)\n[参考文章1](https://www.cnblogs.com/kerrycode/p/4217995.html)\n[参考文章2](https://www.cnblogs.com/wanghuaijun/p/6547046.html)","source":"_posts/Linux中时间的设置.md","raw":"---\ntitle: Linux中时间的设置\ndate: 2018-03-08 11:36:45\ntags:\ncategories:\n    - \"Linux\"\n    - \"method\"\nkeywords:\n    - \"Linux\"\n    - \"date\"\npassword:\n---\ntest: CentOS Linux release 7.4.1708 (Core)\n#### 查看时区\n> **data -R**\n\n![查看时区](http://p3ax8ersb.bkt.clouddn.com/201803081634_167.png-960.jpg)\n+0800 表示在东八区\n其中：\nCST：中国标准时间（China Standard Time），这个解释可能是针对RedHat Linux。\nUTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。UTC较于GMT更准确。\nGMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。\n#### 修改时区\n> **tzselect**\n\n<!--more-->\n![tzselect1](http://p3ax8ersb.bkt.clouddn.com/201803081645_514.png-960.jpg)\n**这个命令并不是用来修改时区的**，这个命令可以通过你自己的选择然后清楚的知道每个时区的样式。然后你通过修改.progile、.bash_profile或者/etc/profile文件，设置正确的TZ环境变量并导出，可以成功改变时区。\n![tzselect2](http://p3ax8ersb.bkt.clouddn.com/201803081647_798.png-960.jpg)\n\n**tip：这些修改应该出现用户家目录下**\n下面例子，我将时区由东八区改变为波兰的时区，东一区：\n先通过tzselect查询波兰的时区书写格式：\n![tzselect3](http://p3ax8ersb.bkt.clouddn.com/201803081702_845.png-960.jpg)\n然后通过修改文件.bash_profile并应用得以修改。\n![tzselect4](http://p3ax8ersb.bkt.clouddn.com/201803081701_60.png-960.jpg)\n> **通过替换系统时区文件，或者创建链接文件**\n\n1、在目录/usr/share/zoneinfo中有所有的时区文件，通过复制替换到/etc/locatime即可\n![替换](http://p3ax8ersb.bkt.clouddn.com/201803081715_394.png-960.jpg)\n但是有的时候会出现没有效果的情况，比如上例子。这是因为修改了在profile或.bash_profile中设置了TZ。这个时候就需要重新修改TZ。\n\n2、创建链接文件\n这里如果出现修改失败，同上。\n![ln](http://p3ax8ersb.bkt.clouddn.com/201803081722_543.png-960.jpg)\n\n#### 查看和修改时间和日期\n> **date**\n> date用于查看和设置 **系统时间**\n\n![date](http://p3ax8ersb.bkt.clouddn.com/201803081733_375.png-960.jpg)\n如果不输入命令\"hwclock -w\"将时间写入硬件时间，电脑重启之后将会返回原样。\n> **hwclock**\n> hwclock用来查看设置 **硬件时间**。\n\n> **hwclock --hctosys**\n> hc代表硬件时间，sys代表系统时间，即用硬件时钟同步系统时钟\n\n> **hwclock --systohc**\n> 即用系统时钟同步硬件时钟,等于 **hwclock -w**\n\n执行完这两个命令系统没有任何反馈。\n![hwclock](http://p3ax8ersb.bkt.clouddn.com/201803081739_539.png-960.jpg)\n\n解释一下硬件时钟和系统时钟的区别：\n硬件时钟指的是主板上由电池供电的那个时间，可以在BIOS中设置。**Linux可以通过hwclock设置。当Linux启动的时候，硬件时钟会赋值给系统时钟。然后系统时钟会独立于硬件时钟工作。**\n系统时钟指的是当前Linux Kernel中的时钟。Linux中的所有命令包括函数都是采用系统时钟设置的。\n这就是为什么当我们用date修改了时间，没有同步到硬件时钟的时候，这个修改是无效的。\n\n#### 时间自动同步\n> **yum install -y ntpdate**\n首先安装ntpdate软件，用来同步Linux时间服务。\n\n> **ntpdate time.nist.gov**\n\n![ntpdate](http://p3ax8ersb.bkt.clouddn.com/201803081941_193.png-960.jpg)\n上面表示同步成功，调整时间为服务器129.6.15.29的时间，时间相差0.136318 sec\n\n> **hwclock -w**\n调整硬件时间\n\n> **crontab -e**\n设定crontab计划任务自动校时，并添加下列内容\n**0 1 * * * ntpdate time.nist.gov**\n这样设定一个小时自动进行网络校时。\n\n通过cat /etc/crontab 查看crontab的设置解释，如下：\n![crontab](http://p3ax8ersb.bkt.clouddn.com/201803082006_609.png-1920.jpg)\n[参考文章1](https://www.cnblogs.com/kerrycode/p/4217995.html)\n[参考文章2](https://www.cnblogs.com/wanghuaijun/p/6547046.html)","slug":"Linux中时间的设置","published":1,"updated":"2018-03-08T12:33:37.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nqyr000504d8fsryf793","content":"<p>test: CentOS Linux release 7.4.1708 (Core)</p>\n<h4 id=\"查看时区\"><a href=\"#查看时区\" class=\"headerlink\" title=\"查看时区\"></a>查看时区</h4><blockquote>\n<p><strong>data -R</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081634_167.png-960.jpg\" alt=\"查看时区\"><br>+0800 表示在东八区<br>其中：<br>CST：中国标准时间（China Standard Time），这个解释可能是针对RedHat Linux。<br>UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。UTC较于GMT更准确。<br>GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。</p>\n<h4 id=\"修改时区\"><a href=\"#修改时区\" class=\"headerlink\" title=\"修改时区\"></a>修改时区</h4><blockquote>\n<p><strong>tzselect</strong></p>\n</blockquote>\n<a id=\"more\"></a>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081645_514.png-960.jpg\" alt=\"tzselect1\"><br><strong>这个命令并不是用来修改时区的</strong>，这个命令可以通过你自己的选择然后清楚的知道每个时区的样式。然后你通过修改.progile、.bash_profile或者/etc/profile文件，设置正确的TZ环境变量并导出，可以成功改变时区。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081647_798.png-960.jpg\" alt=\"tzselect2\"></p>\n<p><strong>tip：这些修改应该出现用户家目录下</strong><br>下面例子，我将时区由东八区改变为波兰的时区，东一区：<br>先通过tzselect查询波兰的时区书写格式：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081702_845.png-960.jpg\" alt=\"tzselect3\"><br>然后通过修改文件.bash_profile并应用得以修改。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081701_60.png-960.jpg\" alt=\"tzselect4\"></p>\n<blockquote>\n<p><strong>通过替换系统时区文件，或者创建链接文件</strong></p>\n</blockquote>\n<p>1、在目录/usr/share/zoneinfo中有所有的时区文件，通过复制替换到/etc/locatime即可<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081715_394.png-960.jpg\" alt=\"替换\"><br>但是有的时候会出现没有效果的情况，比如上例子。这是因为修改了在profile或.bash_profile中设置了TZ。这个时候就需要重新修改TZ。</p>\n<p>2、创建链接文件<br>这里如果出现修改失败，同上。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081722_543.png-960.jpg\" alt=\"ln\"></p>\n<h4 id=\"查看和修改时间和日期\"><a href=\"#查看和修改时间和日期\" class=\"headerlink\" title=\"查看和修改时间和日期\"></a>查看和修改时间和日期</h4><blockquote>\n<p><strong>date</strong><br>date用于查看和设置 <strong>系统时间</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081733_375.png-960.jpg\" alt=\"date\"><br>如果不输入命令”hwclock -w”将时间写入硬件时间，电脑重启之后将会返回原样。</p>\n<blockquote>\n<p><strong>hwclock</strong><br>hwclock用来查看设置 <strong>硬件时间</strong>。</p>\n</blockquote>\n<blockquote>\n<p><strong>hwclock –hctosys</strong><br>hc代表硬件时间，sys代表系统时间，即用硬件时钟同步系统时钟</p>\n</blockquote>\n<blockquote>\n<p><strong>hwclock –systohc</strong><br>即用系统时钟同步硬件时钟,等于 <strong>hwclock -w</strong></p>\n</blockquote>\n<p>执行完这两个命令系统没有任何反馈。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081739_539.png-960.jpg\" alt=\"hwclock\"></p>\n<p>解释一下硬件时钟和系统时钟的区别：<br>硬件时钟指的是主板上由电池供电的那个时间，可以在BIOS中设置。<strong>Linux可以通过hwclock设置。当Linux启动的时候，硬件时钟会赋值给系统时钟。然后系统时钟会独立于硬件时钟工作。</strong><br>系统时钟指的是当前Linux Kernel中的时钟。Linux中的所有命令包括函数都是采用系统时钟设置的。<br>这就是为什么当我们用date修改了时间，没有同步到硬件时钟的时候，这个修改是无效的。</p>\n<h4 id=\"时间自动同步\"><a href=\"#时间自动同步\" class=\"headerlink\" title=\"时间自动同步\"></a>时间自动同步</h4><blockquote>\n<p><strong>yum install -y ntpdate</strong><br>首先安装ntpdate软件，用来同步Linux时间服务。</p>\n</blockquote>\n<blockquote>\n<p><strong>ntpdate time.nist.gov</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081941_193.png-960.jpg\" alt=\"ntpdate\"><br>上面表示同步成功，调整时间为服务器129.6.15.29的时间，时间相差0.136318 sec</p>\n<blockquote>\n<p><strong>hwclock -w</strong><br>调整硬件时间</p>\n</blockquote>\n<blockquote>\n<p><strong>crontab -e</strong><br>设定crontab计划任务自动校时，并添加下列内容<br><strong>0 1 <em> </em> * ntpdate time.nist.gov</strong><br>这样设定一个小时自动进行网络校时。</p>\n</blockquote>\n<p>通过cat /etc/crontab 查看crontab的设置解释，如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803082006_609.png-1920.jpg\" alt=\"crontab\"><br><a href=\"https://www.cnblogs.com/kerrycode/p/4217995.html\" target=\"_blank\" rel=\"noopener\">参考文章1</a><br><a href=\"https://www.cnblogs.com/wanghuaijun/p/6547046.html\" target=\"_blank\" rel=\"noopener\">参考文章2</a></p>\n","site":{"data":{}},"excerpt":"<p>test: CentOS Linux release 7.4.1708 (Core)</p>\n<h4 id=\"查看时区\"><a href=\"#查看时区\" class=\"headerlink\" title=\"查看时区\"></a>查看时区</h4><blockquote>\n<p><strong>data -R</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081634_167.png-960.jpg\" alt=\"查看时区\"><br>+0800 表示在东八区<br>其中：<br>CST：中国标准时间（China Standard Time），这个解释可能是针对RedHat Linux。<br>UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。UTC较于GMT更准确。<br>GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。</p>\n<h4 id=\"修改时区\"><a href=\"#修改时区\" class=\"headerlink\" title=\"修改时区\"></a>修改时区</h4><blockquote>\n<p><strong>tzselect</strong></p>\n</blockquote>","more":"<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081645_514.png-960.jpg\" alt=\"tzselect1\"><br><strong>这个命令并不是用来修改时区的</strong>，这个命令可以通过你自己的选择然后清楚的知道每个时区的样式。然后你通过修改.progile、.bash_profile或者/etc/profile文件，设置正确的TZ环境变量并导出，可以成功改变时区。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081647_798.png-960.jpg\" alt=\"tzselect2\"></p>\n<p><strong>tip：这些修改应该出现用户家目录下</strong><br>下面例子，我将时区由东八区改变为波兰的时区，东一区：<br>先通过tzselect查询波兰的时区书写格式：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081702_845.png-960.jpg\" alt=\"tzselect3\"><br>然后通过修改文件.bash_profile并应用得以修改。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081701_60.png-960.jpg\" alt=\"tzselect4\"></p>\n<blockquote>\n<p><strong>通过替换系统时区文件，或者创建链接文件</strong></p>\n</blockquote>\n<p>1、在目录/usr/share/zoneinfo中有所有的时区文件，通过复制替换到/etc/locatime即可<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081715_394.png-960.jpg\" alt=\"替换\"><br>但是有的时候会出现没有效果的情况，比如上例子。这是因为修改了在profile或.bash_profile中设置了TZ。这个时候就需要重新修改TZ。</p>\n<p>2、创建链接文件<br>这里如果出现修改失败，同上。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081722_543.png-960.jpg\" alt=\"ln\"></p>\n<h4 id=\"查看和修改时间和日期\"><a href=\"#查看和修改时间和日期\" class=\"headerlink\" title=\"查看和修改时间和日期\"></a>查看和修改时间和日期</h4><blockquote>\n<p><strong>date</strong><br>date用于查看和设置 <strong>系统时间</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081733_375.png-960.jpg\" alt=\"date\"><br>如果不输入命令”hwclock -w”将时间写入硬件时间，电脑重启之后将会返回原样。</p>\n<blockquote>\n<p><strong>hwclock</strong><br>hwclock用来查看设置 <strong>硬件时间</strong>。</p>\n</blockquote>\n<blockquote>\n<p><strong>hwclock –hctosys</strong><br>hc代表硬件时间，sys代表系统时间，即用硬件时钟同步系统时钟</p>\n</blockquote>\n<blockquote>\n<p><strong>hwclock –systohc</strong><br>即用系统时钟同步硬件时钟,等于 <strong>hwclock -w</strong></p>\n</blockquote>\n<p>执行完这两个命令系统没有任何反馈。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081739_539.png-960.jpg\" alt=\"hwclock\"></p>\n<p>解释一下硬件时钟和系统时钟的区别：<br>硬件时钟指的是主板上由电池供电的那个时间，可以在BIOS中设置。<strong>Linux可以通过hwclock设置。当Linux启动的时候，硬件时钟会赋值给系统时钟。然后系统时钟会独立于硬件时钟工作。</strong><br>系统时钟指的是当前Linux Kernel中的时钟。Linux中的所有命令包括函数都是采用系统时钟设置的。<br>这就是为什么当我们用date修改了时间，没有同步到硬件时钟的时候，这个修改是无效的。</p>\n<h4 id=\"时间自动同步\"><a href=\"#时间自动同步\" class=\"headerlink\" title=\"时间自动同步\"></a>时间自动同步</h4><blockquote>\n<p><strong>yum install -y ntpdate</strong><br>首先安装ntpdate软件，用来同步Linux时间服务。</p>\n</blockquote>\n<blockquote>\n<p><strong>ntpdate time.nist.gov</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081941_193.png-960.jpg\" alt=\"ntpdate\"><br>上面表示同步成功，调整时间为服务器129.6.15.29的时间，时间相差0.136318 sec</p>\n<blockquote>\n<p><strong>hwclock -w</strong><br>调整硬件时间</p>\n</blockquote>\n<blockquote>\n<p><strong>crontab -e</strong><br>设定crontab计划任务自动校时，并添加下列内容<br><strong>0 1 <em> </em> * ntpdate time.nist.gov</strong><br>这样设定一个小时自动进行网络校时。</p>\n</blockquote>\n<p>通过cat /etc/crontab 查看crontab的设置解释，如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803082006_609.png-1920.jpg\" alt=\"crontab\"><br><a href=\"https://www.cnblogs.com/kerrycode/p/4217995.html\" target=\"_blank\" rel=\"noopener\">参考文章1</a><br><a href=\"https://www.cnblogs.com/wanghuaijun/p/6547046.html\" target=\"_blank\" rel=\"noopener\">参考文章2</a></p>"},{"title":"static const integral data member在类中的初始化","date":"2018-01-30T06:25:04.000Z","_content":"**当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。**该类的其它对象对这个静态变量也是可以进行修改的。\n```c++\n//非常量静态成员变量初始化对比\n#include <iostream>\nusing namespace std;\n\nclass person{\n    public:\n        static int num;\n        //static int num = 11;\n};\nint person::num = 10;\n\nint main(){\n    person bob;\n    system(\"clear\");\n    cout << bob.num << endl;\n    return 0;\n}\n```\n<!--more-->\n在类内初始化非常量静态成员变量失败\n![在类内初始化非常量静态成员变量](http://p3ax8ersb.bkt.clouddn.com/201801301358_611.png)\n在类外初始化静态成员变量成功\n![在类外初始化静态成员变量](http://p3ax8ersb.bkt.clouddn.com/201801301359_872.png)\n```c++\n//定义另外一个对象timmy\nperson timmy;\ncout << \"timmy:\" << timmy.num<< endl;\n```\n同一个类的不同对象共用一个静态成员变量\n![同一个类的不同对象共用一个静态成员变量](http://p3ax8ersb.bkt.clouddn.com/201801301406_632.png)\n\n**但是，常量的静态成员变量可以在类里面定义。**\n```c++\n#include <iostream>\nusing namespace std;\n\nclass person{\n    public:\n        static const int num = 11;\n        const static int age = 23;\n};\n\nint main(){\n    system(\"clear\");\n    person tom;\n    cout << \"tom:\" << tom.num << endl;\n    cout << \"tom:\" << tom.age << endl;\n    return 0;\n}\n```\nstatic const和const static一样的。\n![static const](http://p3ax8ersb.bkt.clouddn.com/201801301417_598.png)\n\n**可是只有integral data member才可以，像 int，long，char才行。double，float等都不行**\n```c++\n#include <iostream>\nusing namespace std;\n\nclass person{\n    public:\n        static const double num = 2.2;\n};\nint main(){\n    system(\"clear\");\n    person tom;\n    cout << \"tom:\" << tom.num << endl;\n    return 0;\n}\n```\n用 static const double 初始化失败\n![double失败](http://p3ax8ersb.bkt.clouddn.com/201801301421_850.png)\n","source":"_posts/static-const-integral-data-member在类中的初始化.md","raw":"---\ntitle: static const integral data member在类中的初始化\ndate: 2018-01-30 14:25:04\ntags:\ncategories:\n    - \"knowledge\"\n    - \"C/C++\"\n---\n**当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。**该类的其它对象对这个静态变量也是可以进行修改的。\n```c++\n//非常量静态成员变量初始化对比\n#include <iostream>\nusing namespace std;\n\nclass person{\n    public:\n        static int num;\n        //static int num = 11;\n};\nint person::num = 10;\n\nint main(){\n    person bob;\n    system(\"clear\");\n    cout << bob.num << endl;\n    return 0;\n}\n```\n<!--more-->\n在类内初始化非常量静态成员变量失败\n![在类内初始化非常量静态成员变量](http://p3ax8ersb.bkt.clouddn.com/201801301358_611.png)\n在类外初始化静态成员变量成功\n![在类外初始化静态成员变量](http://p3ax8ersb.bkt.clouddn.com/201801301359_872.png)\n```c++\n//定义另外一个对象timmy\nperson timmy;\ncout << \"timmy:\" << timmy.num<< endl;\n```\n同一个类的不同对象共用一个静态成员变量\n![同一个类的不同对象共用一个静态成员变量](http://p3ax8ersb.bkt.clouddn.com/201801301406_632.png)\n\n**但是，常量的静态成员变量可以在类里面定义。**\n```c++\n#include <iostream>\nusing namespace std;\n\nclass person{\n    public:\n        static const int num = 11;\n        const static int age = 23;\n};\n\nint main(){\n    system(\"clear\");\n    person tom;\n    cout << \"tom:\" << tom.num << endl;\n    cout << \"tom:\" << tom.age << endl;\n    return 0;\n}\n```\nstatic const和const static一样的。\n![static const](http://p3ax8ersb.bkt.clouddn.com/201801301417_598.png)\n\n**可是只有integral data member才可以，像 int，long，char才行。double，float等都不行**\n```c++\n#include <iostream>\nusing namespace std;\n\nclass person{\n    public:\n        static const double num = 2.2;\n};\nint main(){\n    system(\"clear\");\n    person tom;\n    cout << \"tom:\" << tom.num << endl;\n    return 0;\n}\n```\n用 static const double 初始化失败\n![double失败](http://p3ax8ersb.bkt.clouddn.com/201801301421_850.png)\n","slug":"static-const-integral-data-member在类中的初始化","published":1,"updated":"2018-02-09T02:36:56.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nqyv000604d8l0r84dxr","content":"<p><strong>当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。</strong>该类的其它对象对这个静态变量也是可以进行修改的。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非常量静态成员变量初始化对比</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">        <span class=\"comment\">//static int num = 11;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> person::num = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    person bob;</span><br><span class=\"line\">    system(<span class=\"string\">\"clear\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; bob.num &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>在类内初始化非常量静态成员变量失败<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801301358_611.png\" alt=\"在类内初始化非常量静态成员变量\"><br>在类外初始化静态成员变量成功<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801301359_872.png\" alt=\"在类外初始化静态成员变量\"><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义另外一个对象timmy</span></span><br><span class=\"line\">person timmy;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"timmy:\"</span> &lt;&lt; timmy.num&lt;&lt; <span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure></p>\n<p>同一个类的不同对象共用一个静态成员变量<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801301406_632.png\" alt=\"同一个类的不同对象共用一个静态成员变量\"></p>\n<p><strong>但是，常量的静态成员变量可以在类里面定义。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num = <span class=\"number\">11</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> age = <span class=\"number\">23</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    system(<span class=\"string\">\"clear\"</span>);</span><br><span class=\"line\">    person tom;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tom:\"</span> &lt;&lt; tom.num &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tom:\"</span> &lt;&lt; tom.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>static const和const static一样的。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801301417_598.png\" alt=\"static const\"></p>\n<p><strong>可是只有integral data member才可以，像 int，long，char才行。double，float等都不行</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">double</span> num = <span class=\"number\">2.2</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    system(<span class=\"string\">\"clear\"</span>);</span><br><span class=\"line\">    person tom;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tom:\"</span> &lt;&lt; tom.num &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用 static const double 初始化失败<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801301421_850.png\" alt=\"double失败\"></p>\n","site":{"data":{}},"excerpt":"<p><strong>当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。</strong>该类的其它对象对这个静态变量也是可以进行修改的。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非常量静态成员变量初始化对比</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">        <span class=\"comment\">//static int num = 11;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> person::num = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    person bob;</span><br><span class=\"line\">    system(<span class=\"string\">\"clear\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; bob.num &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>","more":"<p>在类内初始化非常量静态成员变量失败<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801301358_611.png\" alt=\"在类内初始化非常量静态成员变量\"><br>在类外初始化静态成员变量成功<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801301359_872.png\" alt=\"在类外初始化静态成员变量\"><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义另外一个对象timmy</span></span><br><span class=\"line\">person timmy;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"timmy:\"</span> &lt;&lt; timmy.num&lt;&lt; <span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure></p>\n<p>同一个类的不同对象共用一个静态成员变量<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801301406_632.png\" alt=\"同一个类的不同对象共用一个静态成员变量\"></p>\n<p><strong>但是，常量的静态成员变量可以在类里面定义。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num = <span class=\"number\">11</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> age = <span class=\"number\">23</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    system(<span class=\"string\">\"clear\"</span>);</span><br><span class=\"line\">    person tom;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tom:\"</span> &lt;&lt; tom.num &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tom:\"</span> &lt;&lt; tom.age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>static const和const static一样的。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801301417_598.png\" alt=\"static const\"></p>\n<p><strong>可是只有integral data member才可以，像 int，long，char才行。double，float等都不行</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">double</span> num = <span class=\"number\">2.2</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    system(<span class=\"string\">\"clear\"</span>);</span><br><span class=\"line\">    person tom;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tom:\"</span> &lt;&lt; tom.num &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>用 static const double 初始化失败<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801301421_850.png\" alt=\"double失败\"></p>"},{"title":"创建一个不能被继承的类","date":"2018-01-29T02:23:19.000Z","keywords":["类","继承"],"_content":"\n## 题目：\n**题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。**\n\n### 思路：\n- 题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。<!--more-->那么我们只要将构造函数或析构函数定义为私有成员函数就好了。\n- 第二个要求，能够正常使用，这样显然之前的方式是行不通的。构造函数为私有了，就无法创建对象了。那我再给他加一个友元函数，这样对象也可以创建了。\n- 可是题目的要求是正常使用这个类，显然通过一个友元函数是不符合我们正常使用类的方式。\n- 这个时候，正真正确的思路就出来了。我们借用一个中间类。例如：我们不能被继承的类是man，我们创建一个 **私有构造函数的父类person**，同时将 **man定义为person的友元类**。这样man就可以正常访问person的私有构造函数了。接着我们让 **man虚继承person**，到这里我们就完成了这个题目。\n- **让man虚继承person是为了让继承man的类，都需要在man的父类，即person中调用构造函数，但只有man是person的友元类，其他的类都不能访问person的构造函数。因此man就成为了不能被继承的类，而man本身可以正常使用。**\n\n### 代码如下：\n```c++\ninclude <iostream>\n\nusing namespace std;\n//设计一个不能被继承的类\nclass person{\n    public:\n        friend class man;\n    private:\n        //构造函数为private\n        person(){}\n};\n//man虚拟继承person\nclass man:virtual public person {\n    public:\n        man(){\n            age = 18;\n        }\n        void show(){\n            cout << age << endl;\n        }\n    private:\n        int age;\n};\n\n// class son:public man{\n//  public:\n//      son(){}\n// };\n\nint main(){\n    man bob;\n    system( \"clear\" );\n    bob.show();\n    //son tom;\n    return 0;\n}\n```\n不定义man的继承类son，正常输出man的age = 18\n![](http://p3ax8ersb.bkt.clouddn.com/201801291732_992.png-960.jpg)\n\n定义man的继承类son失败\n![](http://p3ax8ersb.bkt.clouddn.com/201801291733_414.png-<960 class=\"jpg\"></960>)","source":"_posts/创建一个不能被继承的类.md","raw":"---\ntitle: 创建一个不能被继承的类\ndate: 2018-01-29 10:23:19\ntags:\ncategories:\n    - \"practice\"\n    - \"C/C++\"\nkeywords:\n    - \"类\"\n    - \"继承\"\n---\n\n## 题目：\n**题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。**\n\n### 思路：\n- 题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。<!--more-->那么我们只要将构造函数或析构函数定义为私有成员函数就好了。\n- 第二个要求，能够正常使用，这样显然之前的方式是行不通的。构造函数为私有了，就无法创建对象了。那我再给他加一个友元函数，这样对象也可以创建了。\n- 可是题目的要求是正常使用这个类，显然通过一个友元函数是不符合我们正常使用类的方式。\n- 这个时候，正真正确的思路就出来了。我们借用一个中间类。例如：我们不能被继承的类是man，我们创建一个 **私有构造函数的父类person**，同时将 **man定义为person的友元类**。这样man就可以正常访问person的私有构造函数了。接着我们让 **man虚继承person**，到这里我们就完成了这个题目。\n- **让man虚继承person是为了让继承man的类，都需要在man的父类，即person中调用构造函数，但只有man是person的友元类，其他的类都不能访问person的构造函数。因此man就成为了不能被继承的类，而man本身可以正常使用。**\n\n### 代码如下：\n```c++\ninclude <iostream>\n\nusing namespace std;\n//设计一个不能被继承的类\nclass person{\n    public:\n        friend class man;\n    private:\n        //构造函数为private\n        person(){}\n};\n//man虚拟继承person\nclass man:virtual public person {\n    public:\n        man(){\n            age = 18;\n        }\n        void show(){\n            cout << age << endl;\n        }\n    private:\n        int age;\n};\n\n// class son:public man{\n//  public:\n//      son(){}\n// };\n\nint main(){\n    man bob;\n    system( \"clear\" );\n    bob.show();\n    //son tom;\n    return 0;\n}\n```\n不定义man的继承类son，正常输出man的age = 18\n![](http://p3ax8ersb.bkt.clouddn.com/201801291732_992.png-960.jpg)\n\n定义man的继承类son失败\n![](http://p3ax8ersb.bkt.clouddn.com/201801291733_414.png-<960 class=\"jpg\"></960>)","slug":"创建一个不能被继承的类","published":1,"updated":"2018-02-24T08:04:44.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nqyy000804d8a7nvkwa0","content":"<h2 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h2><p><strong>题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。</strong></p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><ul>\n<li>题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。<a id=\"more\"></a>那么我们只要将构造函数或析构函数定义为私有成员函数就好了。</li>\n<li>第二个要求，能够正常使用，这样显然之前的方式是行不通的。构造函数为私有了，就无法创建对象了。那我再给他加一个友元函数，这样对象也可以创建了。</li>\n<li>可是题目的要求是正常使用这个类，显然通过一个友元函数是不符合我们正常使用类的方式。</li>\n<li>这个时候，正真正确的思路就出来了。我们借用一个中间类。例如：我们不能被继承的类是man，我们创建一个 <strong>私有构造函数的父类person</strong>，同时将 <strong>man定义为person的友元类</strong>。这样man就可以正常访问person的私有构造函数了。接着我们让 <strong>man虚继承person</strong>，到这里我们就完成了这个题目。</li>\n<li><strong>让man虚继承person是为了让继承man的类，都需要在man的父类，即person中调用构造函数，但只有man是person的友元类，其他的类都不能访问person的构造函数。因此man就成为了不能被继承的类，而man本身可以正常使用。</strong></li>\n</ul>\n<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"comment\">//设计一个不能被继承的类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">man</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"comment\">//构造函数为private</span></span><br><span class=\"line\">        person()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//man虚拟继承person</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">man</span>:</span><span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> person &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        man()&#123;</span><br><span class=\"line\">            age = <span class=\"number\">18</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class son:public man&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//  public:</span></span><br><span class=\"line\"><span class=\"comment\">//      son()&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    man bob;</span><br><span class=\"line\">    system( <span class=\"string\">\"clear\"</span> );</span><br><span class=\"line\">    bob.show();</span><br><span class=\"line\">    <span class=\"comment\">//son tom;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不定义man的继承类son，正常输出man的age = 18<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801291732_992.png-960.jpg\" alt=\"\"></p>\n<p>定义man的继承类son失败<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801291733_414.png-&lt;960 class=&quot;jpg&quot;&gt;&lt;/960\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h2><p><strong>题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。</strong></p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><ul>\n<li>题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。","more":"那么我们只要将构造函数或析构函数定义为私有成员函数就好了。</li>\n<li>第二个要求，能够正常使用，这样显然之前的方式是行不通的。构造函数为私有了，就无法创建对象了。那我再给他加一个友元函数，这样对象也可以创建了。</li>\n<li>可是题目的要求是正常使用这个类，显然通过一个友元函数是不符合我们正常使用类的方式。</li>\n<li>这个时候，正真正确的思路就出来了。我们借用一个中间类。例如：我们不能被继承的类是man，我们创建一个 <strong>私有构造函数的父类person</strong>，同时将 <strong>man定义为person的友元类</strong>。这样man就可以正常访问person的私有构造函数了。接着我们让 <strong>man虚继承person</strong>，到这里我们就完成了这个题目。</li>\n<li><strong>让man虚继承person是为了让继承man的类，都需要在man的父类，即person中调用构造函数，但只有man是person的友元类，其他的类都不能访问person的构造函数。因此man就成为了不能被继承的类，而man本身可以正常使用。</strong></li>\n</ul>\n<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"comment\">//设计一个不能被继承的类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">person</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">man</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"comment\">//构造函数为private</span></span><br><span class=\"line\">        person()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//man虚拟继承person</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">man</span>:</span><span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> person &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        man()&#123;</span><br><span class=\"line\">            age = <span class=\"number\">18</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; age &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class son:public man&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//  public:</span></span><br><span class=\"line\"><span class=\"comment\">//      son()&#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    man bob;</span><br><span class=\"line\">    system( <span class=\"string\">\"clear\"</span> );</span><br><span class=\"line\">    bob.show();</span><br><span class=\"line\">    <span class=\"comment\">//son tom;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不定义man的继承类son，正常输出man的age = 18<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801291732_992.png-960.jpg\" alt=\"\"></p>\n<p>定义man的继承类son失败<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801291733_414.png-&lt;960 class=&quot;jpg&quot;&gt;&lt;/960\" alt=\"\"></p>"},{"title":"判断元素的入栈和出栈顺序是否合法","date":"2018-03-07T06:46:00.000Z","keywords":["stack","C++"],"password":null,"_content":"### 题目\n提供两个元素的集合，一个是元素入栈的顺序，另一个是元素出栈的顺序。设计一个函数，判断两个元素集合是否满足入栈出栈的规则。如：入栈顺序：“12345”，出栈顺序是：“54321”，这样就是符合要求的。如果出栈顺序是：“51234”，这样不符合要求。\n<!--more-->\n### 思路\n根据题目的要求，就是判断两数组是否满足出栈入栈的顺序。可以这样做：**1、先按照入栈顺序的集合进行入栈。2、在入栈的同时，跟出栈顺序的元素进行比较。如果相同就将入栈的元素pop出来。3、结束的时候，如果栈为空，说明两者的入栈顺序和出栈顺序可以匹配，那么就是符合要求的；如果栈不为空，那就是不符合要求。**\n还有一点：**如果两元素的个数不一样或者同时为空，直接判定不符合要求。**\n\n### 代码实现\n```c++\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nbool stack_io_right(char* src, char* dst){\n    int src_len = sizeof(src);\n    int dst_len = sizeof(dst);\n    int i = 0;\n    int j = 0;\n\n    if(src_len == 0 || src_len != dst_len)\n        return false;\n    for(; i < src_len; ++i){\n        s.push(*(src+i));\n        while(s.size() && s.top() == *(dst+j)){\n            ++j;\n            s.pop();\n        }\n    }\n    if(s.empty())\n        return true;\n    else\n        return false;\n}\n\nint main(){\n    system(\"clear\");\n    char src[] = \"12345\";\n    char dst[] = \"32145\";\n    char dst1[] = \"51243\";\n\n    cout << stack_io_right(src, dst) << endl;\n    cout << stack_io_right(src, dst1) << endl;\n    return 0;\n}\n```\n\n### 运行结果\n![运行结果](http://p3ax8ersb.bkt.clouddn.com/201803071537_435.png-480.jpg)","source":"_posts/判断元素的入栈和出栈顺序是否一致.md","raw":"---\ntitle: 判断元素的入栈和出栈顺序是否合法\ndate: 2018-03-07 14:46:00\ntags:\ncategories:\n    - \"practice\"\n    - \"C/C++\"\nkeywords:\n    - \"stack\"\n    - \"C++\"\npassword:\n---\n### 题目\n提供两个元素的集合，一个是元素入栈的顺序，另一个是元素出栈的顺序。设计一个函数，判断两个元素集合是否满足入栈出栈的规则。如：入栈顺序：“12345”，出栈顺序是：“54321”，这样就是符合要求的。如果出栈顺序是：“51234”，这样不符合要求。\n<!--more-->\n### 思路\n根据题目的要求，就是判断两数组是否满足出栈入栈的顺序。可以这样做：**1、先按照入栈顺序的集合进行入栈。2、在入栈的同时，跟出栈顺序的元素进行比较。如果相同就将入栈的元素pop出来。3、结束的时候，如果栈为空，说明两者的入栈顺序和出栈顺序可以匹配，那么就是符合要求的；如果栈不为空，那就是不符合要求。**\n还有一点：**如果两元素的个数不一样或者同时为空，直接判定不符合要求。**\n\n### 代码实现\n```c++\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nbool stack_io_right(char* src, char* dst){\n    int src_len = sizeof(src);\n    int dst_len = sizeof(dst);\n    int i = 0;\n    int j = 0;\n\n    if(src_len == 0 || src_len != dst_len)\n        return false;\n    for(; i < src_len; ++i){\n        s.push(*(src+i));\n        while(s.size() && s.top() == *(dst+j)){\n            ++j;\n            s.pop();\n        }\n    }\n    if(s.empty())\n        return true;\n    else\n        return false;\n}\n\nint main(){\n    system(\"clear\");\n    char src[] = \"12345\";\n    char dst[] = \"32145\";\n    char dst1[] = \"51243\";\n\n    cout << stack_io_right(src, dst) << endl;\n    cout << stack_io_right(src, dst1) << endl;\n    return 0;\n}\n```\n\n### 运行结果\n![运行结果](http://p3ax8ersb.bkt.clouddn.com/201803071537_435.png-480.jpg)","slug":"判断元素的入栈和出栈顺序是否一致","published":1,"updated":"2018-03-07T07:48:17.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nqz0000904d8mvj1zljp","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>提供两个元素的集合，一个是元素入栈的顺序，另一个是元素出栈的顺序。设计一个函数，判断两个元素集合是否满足入栈出栈的规则。如：入栈顺序：“12345”，出栈顺序是：“54321”，这样就是符合要求的。如果出栈顺序是：“51234”，这样不符合要求。<br><a id=\"more\"></a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>根据题目的要求，就是判断两数组是否满足出栈入栈的顺序。可以这样做：<strong>1、先按照入栈顺序的集合进行入栈。2、在入栈的同时，跟出栈顺序的元素进行比较。如果相同就将入栈的元素pop出来。3、结束的时候，如果栈为空，说明两者的入栈顺序和出栈顺序可以匹配，那么就是符合要求的；如果栈不为空，那就是不符合要求。</strong><br>还有一点：<strong>如果两元素的个数不一样或者同时为空，直接判定不符合要求。</strong></p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">stack_io_right</span><span class=\"params\">(<span class=\"keyword\">char</span>* src, <span class=\"keyword\">char</span>* dst)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> src_len = <span class=\"keyword\">sizeof</span>(src);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> dst_len = <span class=\"keyword\">sizeof</span>(dst);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(src_len == <span class=\"number\">0</span> || src_len != dst_len)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; i &lt; src_len; ++i)&#123;</span><br><span class=\"line\">        s.push(*(src+i));</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(s.size() &amp;&amp; s.top() == *(dst+j))&#123;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.empty())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    system(<span class=\"string\">\"clear\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> src[] = <span class=\"string\">\"12345\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> dst[] = <span class=\"string\">\"32145\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> dst1[] = <span class=\"string\">\"51243\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; stack_io_right(src, dst) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; stack_io_right(src, dst1) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h3><p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803071537_435.png-480.jpg\" alt=\"运行结果\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>提供两个元素的集合，一个是元素入栈的顺序，另一个是元素出栈的顺序。设计一个函数，判断两个元素集合是否满足入栈出栈的规则。如：入栈顺序：“12345”，出栈顺序是：“54321”，这样就是符合要求的。如果出栈顺序是：“51234”，这样不符合要求。<br>","more":"</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>根据题目的要求，就是判断两数组是否满足出栈入栈的顺序。可以这样做：<strong>1、先按照入栈顺序的集合进行入栈。2、在入栈的同时，跟出栈顺序的元素进行比较。如果相同就将入栈的元素pop出来。3、结束的时候，如果栈为空，说明两者的入栈顺序和出栈顺序可以匹配，那么就是符合要求的；如果栈不为空，那就是不符合要求。</strong><br>还有一点：<strong>如果两元素的个数不一样或者同时为空，直接判定不符合要求。</strong></p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">stack_io_right</span><span class=\"params\">(<span class=\"keyword\">char</span>* src, <span class=\"keyword\">char</span>* dst)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> src_len = <span class=\"keyword\">sizeof</span>(src);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> dst_len = <span class=\"keyword\">sizeof</span>(dst);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(src_len == <span class=\"number\">0</span> || src_len != dst_len)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; i &lt; src_len; ++i)&#123;</span><br><span class=\"line\">        s.push(*(src+i));</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(s.size() &amp;&amp; s.top() == *(dst+j))&#123;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.empty())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    system(<span class=\"string\">\"clear\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> src[] = <span class=\"string\">\"12345\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> dst[] = <span class=\"string\">\"32145\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> dst1[] = <span class=\"string\">\"51243\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; stack_io_right(src, dst) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; stack_io_right(src, dst1) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h3><p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803071537_435.png-480.jpg\" alt=\"运行结果\"></p>"},{"title":"位运算实现Add","date":"2018-01-28T05:30:43.000Z","_content":"## 题目：\n**实现一个Add函数，让两个整数相加，不能够使用`+-*/、++、--`**\n### 思路：\n- 正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，`15+5=20`先将位进行相加，不进行进位，得到`10`，再将进位加上，个位没有进位，十位进1，得到`20`。\n<!--more-->\n- 题目要求不能使用`+-*/`，所以想到了位运算。15的二进制是`1111`，5的二进制是`0101`。根据上面的思路，我们先进行不进位相加，得到`1010`。(这个运算方式正好对应`^`)然后将进位加上(只求进位的运算正好对应`&`再左移一位)，例子中只有第四位、第二位数值有进位值。得到`10100`，这个值就是`20`。\n\n\n### 代码如下\n```c++\n    //1、递归实现，每次将不进位相加的值赋给a，将计算出来的进位值赋给b，递归进行两者的分步相加，直到进位值`b=0`，返回a。\n    long long Add( int a, int b ){\n        if( b == 0 )\n            return a;\n        int sum = a^b;\n        b = (a&b)<<1;\n        a = sum;\n        return Add( a, b );\n    }\n    int main(){\n        system( \"clear\" );\n        cout << Add(3, 7) << endl;\n\n        //2、同时可以用迭代实现(非函数)，思路一样，进位值b最后肯定会等于0，因为总有进位结束的时候。\n        int a = 49;\n        int b = 4;\n        while( b != 0 ){\n            int sum = a^b;\n            b = (a&b)<<1;\n            a = sum;\n        }\n        cout << a << endl;\n        return 0;\n    }\n```","source":"_posts/位运算实现Add.md","raw":"---\ntitle: 位运算实现Add\ndate: 2018-01-28 13:30:43\ntags:\ncategories:\n    - \"practice\"\n    - \"C/C++\"\n---\n## 题目：\n**实现一个Add函数，让两个整数相加，不能够使用`+-*/、++、--`**\n### 思路：\n- 正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，`15+5=20`先将位进行相加，不进行进位，得到`10`，再将进位加上，个位没有进位，十位进1，得到`20`。\n<!--more-->\n- 题目要求不能使用`+-*/`，所以想到了位运算。15的二进制是`1111`，5的二进制是`0101`。根据上面的思路，我们先进行不进位相加，得到`1010`。(这个运算方式正好对应`^`)然后将进位加上(只求进位的运算正好对应`&`再左移一位)，例子中只有第四位、第二位数值有进位值。得到`10100`，这个值就是`20`。\n\n\n### 代码如下\n```c++\n    //1、递归实现，每次将不进位相加的值赋给a，将计算出来的进位值赋给b，递归进行两者的分步相加，直到进位值`b=0`，返回a。\n    long long Add( int a, int b ){\n        if( b == 0 )\n            return a;\n        int sum = a^b;\n        b = (a&b)<<1;\n        a = sum;\n        return Add( a, b );\n    }\n    int main(){\n        system( \"clear\" );\n        cout << Add(3, 7) << endl;\n\n        //2、同时可以用迭代实现(非函数)，思路一样，进位值b最后肯定会等于0，因为总有进位结束的时候。\n        int a = 49;\n        int b = 4;\n        while( b != 0 ){\n            int sum = a^b;\n            b = (a&b)<<1;\n            a = sum;\n        }\n        cout << a << endl;\n        return 0;\n    }\n```","slug":"位运算实现Add","published":1,"updated":"2018-02-08T06:20:27.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nqz3000c04d8grpfybv5","content":"<h2 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h2><p><strong>实现一个Add函数，让两个整数相加，不能够使用<code>+-*/、++、--</code></strong></p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><ul>\n<li>正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，<code>15+5=20</code>先将位进行相加，不进行进位，得到<code>10</code>，再将进位加上，个位没有进位，十位进1，得到<code>20</code>。<a id=\"more\"></a></li>\n<li>题目要求不能使用<code>+-*/</code>，所以想到了位运算。15的二进制是<code>1111</code>，5的二进制是<code>0101</code>。根据上面的思路，我们先进行不进位相加，得到<code>1010</code>。(这个运算方式正好对应<code>^</code>)然后将进位加上(只求进位的运算正好对应<code>&amp;</code>再左移一位)，例子中只有第四位、第二位数值有进位值。得到<code>10100</code>，这个值就是<code>20</code>。</li>\n</ul>\n<h3 id=\"代码如下\"><a href=\"#代码如下\" class=\"headerlink\" title=\"代码如下\"></a>代码如下</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、递归实现，每次将不进位相加的值赋给a，将计算出来的进位值赋给b，递归进行两者的分步相加，直到进位值`b=0`，返回a。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">Add</span><span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( b == <span class=\"number\">0</span> )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = a^b;</span><br><span class=\"line\">    b = (a&amp;b)&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    a = sum;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Add( a, b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    system( <span class=\"string\">\"clear\"</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; Add(<span class=\"number\">3</span>, <span class=\"number\">7</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2、同时可以用迭代实现(非函数)，思路一样，进位值b最后肯定会等于0，因为总有进位结束的时候。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">49</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( b != <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = a^b;</span><br><span class=\"line\">        b = (a&amp;b)&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        a = sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h2><p><strong>实现一个Add函数，让两个整数相加，不能够使用<code>+-*/、++、--</code></strong></p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><ul>\n<li>正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，<code>15+5=20</code>先将位进行相加，不进行进位，得到<code>10</code>，再将进位加上，个位没有进位，十位进1，得到<code>20</code>。","more":"</li>\n<li>题目要求不能使用<code>+-*/</code>，所以想到了位运算。15的二进制是<code>1111</code>，5的二进制是<code>0101</code>。根据上面的思路，我们先进行不进位相加，得到<code>1010</code>。(这个运算方式正好对应<code>^</code>)然后将进位加上(只求进位的运算正好对应<code>&amp;</code>再左移一位)，例子中只有第四位、第二位数值有进位值。得到<code>10100</code>，这个值就是<code>20</code>。</li>\n</ul>\n<h3 id=\"代码如下\"><a href=\"#代码如下\" class=\"headerlink\" title=\"代码如下\"></a>代码如下</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、递归实现，每次将不进位相加的值赋给a，将计算出来的进位值赋给b，递归进行两者的分步相加，直到进位值`b=0`，返回a。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">Add</span><span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( b == <span class=\"number\">0</span> )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = a^b;</span><br><span class=\"line\">    b = (a&amp;b)&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">    a = sum;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Add( a, b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    system( <span class=\"string\">\"clear\"</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; Add(<span class=\"number\">3</span>, <span class=\"number\">7</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2、同时可以用迭代实现(非函数)，思路一样，进位值b最后肯定会等于0，因为总有进位结束的时候。</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">49</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( b != <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = a^b;</span><br><span class=\"line\">        b = (a&amp;b)&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        a = sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"二叉树的基本实现","date":"2018-03-06T07:47:19.000Z","keywords":["C++","binarytree","非递归遍历"],"password":null,"_content":"## 二叉树\n本文将使用c++实现模板类的二叉树，内容包括创建、递归遍历、非递归遍历、结点个数、深度、叶子结点的个数、第K层结点个数等函数。\n### 结点、二叉树结构\n二叉树的结点是一个结构体，包括值`_data`，指向左子树的指针和指向右子树的指针`_left`和`_right`。还有构造函数，用于创建结点。<!--more-->\n将`BinaryTreeNode<T>`typedef为`Node`,很多时候我会遗漏模板的类型名需要加上`<T>`，这样就会出错。为了减少这种错误，索性用typedef换名。<\n```c++\ntemplate <class T>\nstruct BinaryTreeNode\n{\n    BinaryTreeNode* _left;\n    BinaryTreeNode* _right;\n    T _data;\n\n    BinaryTreeNode(const T& data = T()){\n        _data = data;\n        _left = NULL;\n        _right = NULL;\n    }\n};\n\ntemplate <class T>\nclass BinaryTree{\ntypedef BinaryTreeNode<T> Node;\npublic:\n    //...\nprotected:\n    Node* _root;\n};\n```\n## 默认成员函数\n### 构造函数\n设置了两个构造函数，一个为空，用于创建一个空的二叉树；另一个参数为两个。\n`const T* a` 数组名\n`const T& invalid` 非法值\n解释一下，这里我用一个数组创建二叉树，同时用'#'表示这个空。如这个例子：\n\n    int a1[] = {1,2,3,'#','#',4,'#','#',5,6,'#','#','#'};\n如果`a1[i] != '#'`那么就创建，反之，表示这个位置没有结点。\n```c++\n//constructor\nBinaryTree(){\n    _root = NULL;\n}\nBinaryTree(const T* a, const T& invalid){\n    size_t index = 0;\n    _root = _CreateTree(a, invalid, index);\n}\nNode* _CreateTree(const T* a, const T& invalid, size_t& index){\n    Node* root = NULL;\n    if(a[index] != invalid){\n        root = new Node(a[index]);\n        root->_left = _CreateTree(a, invalid, ++index);\n        root->_right = _CreateTree(a, invalid, ++index);\n    }\n    return root;\n}\n```\n构造函数利用递归的思想，先跟的次序创建二叉树。**由于要利用到递归，就没有办法直接用构造函数来实现，因为在class之外是没有办法访问到_root的。所以通过一个函数，利用这个函数来实现递归的过程。**\n构造出来的二叉树关系图：\n![二叉树](http://p3ax8ersb.bkt.clouddn.com/201803061638_7.png-480.jpg)\n### 拷贝构造\n拷贝构造利用了一个`_CopyTree`函数。\n```c++\nBinaryTree(const BinaryTree& tree){\n    _root = _CopyTree(tree._root);\n}\nNode* _CopyTree(Node* root){\n    Node* node = root;\n    if(node){\n        node = new Node(root->_data);\n        node->_left = _CopyTree(root->_left);\n        node->_right = _CopyTree(root->_right);\n    }\n    return node;\n}\n```\n### 析构函数\n析构函数利用了一个`Destroy`函数\n```c++\n//destructor\n~BinaryTree(){\n    Destroy(_root);\n}\nvoid Destroy(Node* root){\n    if(root == NULL)\n        return;\n    Destroy(root->_left);\n    Destroy(root->_right);\n    delete root;\n}\n```\n### operator=(赋值运算符的重载)\n先调用析构函数的`Destroy`销毁当前二叉树，然后调用`_CopyTree`重新构造当前二叉树。\n```c++\n//operator=\nBinaryTree<T>& operator=(const BinaryTree<T>& tree){\n    if(this != &tree){\n        Destroy(_root);\n        _root = _CopyTree(tree._root);\n        return *this;\n    }\n}\n\n//BinaryTree<T>& operator=(BinaryTree<T> tree){\n    //if(this != &tree){\n        //swap(_root, tree._root);\n        //return *this;\n    //}\n//}\n```\n赋值运算符的重载有两种实现方式，第一种是传统写法，第二种是现代写法。传统写法就是销毁原来的空间，然后重新开辟新的空间。对内存的操作比较多。现代写法是利用拷贝构造的方式，**在传值进来的时候，生成一份临时拷贝**，然后交换当前二叉树和临时拷贝的根节点，返回根节点，同时利用临时拷贝的作用域，交换后的二叉树在出了当前函数之后被销毁。**相当于借用了系统的拷贝机制和自动析构机制来实现赋值的过程。**\n## 递归遍历\n### 先序遍历\n先序遍历：`root left right`\n```c++\n//PrevOrder\nvoid PrevOrder(){\n    _PrevOrder(_root);\n    cout << endl;\n}\nvoid _PrevOrder(Node* root){\n    if(root){\n        cout << root->_data << \" \";\n        _PrevOrder(root->_left);\n        _PrevOrder(root->_right);\n    }\n    return;\n}\n```\n### 中序遍历\n中序遍历：`left root right`\n```c++\n//InOrder\nvoid InOrder(){\n    _InOreder(_root);\n    cout << endl;\n}\nvoid _InOreder(Node* root){\n    if(root){\n        _InOreder(root->_left);\n        cout << root->_data << \" \";\n        _InOreder(root->_right);\n    }\n    return;\n}\n```\n### 后序遍历\n后序遍历：`left root right`\n```c++\n//PostOrder\nvoid PostOrder(){\n    _PostOrder(_root);\n    cout << endl;\n}\nvoid _PostOrder(Node* root){\n    if(root){\n        _PostOrder(root->_left);\n        _PostOrder(root->_right);\n        cout << root->_data << \" \";\n    }\n    return;\n}\n```\n## 非递归遍历\n之所以要出现非递归遍历，是因为递归遍历有一定的缺陷。比如：当二叉树是一颗父节点只有一个子节点的树，那么对堆栈的使用就很大，**有可能出现堆栈使用太深而栈溢出的情况**。为了避免这种情况的出现，有必要使用非递归遍历。\n**非递归遍历利用栈来实现对之前的结点的存储**，因为每一颗二叉树都有可能有左右子树，所以需要在访问单边的子树的时候，将结点保存下来，这样是为了之后可以返回去访问结点的另一边的子树。\n### 层次遍历\n层次遍历是一层一层的遍历结点的。它与之前三个的遍历方式都不一样。**他利用的是队列，通过队列让父节点带动子节点。**\n```c++\n//LevelOrder\nvoid LevelOrder(){\n    //不能是T，要用到root->_left; root->_right;\n    //不好是Node，结构体太大;\n    queue<Node*> q;\n    if(_root){\n        q.push(_root);\n        while(!q.empty()){\n            Node* top = q.front();\n            //获取到队头之后，将当前结点pop\n            q.pop();\n            cout << top->_data << \" \";\n            //如果左右子树存在，就入队列\n            if(top->_left)\n                q.push(top->_left);\n            if(top->_right)\n                q.push(top->_right);\n        }\n    }\n    cout << endl;\n}\n```\n### 先序遍历非递归\n根据先序遍历的特点，先输出当前结点，然后一路向左，访问完左边再返回访问上一个结点的右子树，这个就是子问题，利用上面一样的方法。\n```c++\n//PrevOrderNonR\nvoid PrevOrderNonR(){\n    //利用栈得以记录访问过的根，用来以后访问右子树\n    stack<Node*> s;\n    Node* cur = _root;\n    while(cur || !s.empty()){\n        //根据先根的次序，访问当前节点，并一路向左访问\n        while(cur){\n            cout << cur->_data << \" \";\n            s.push(cur);\n            cur = cur->_left;\n        }\n        Node* top = s.top();\n        //pop表示左子树已经访问完，接下来访问右子树\n        s.pop();\n        //右子树的访问是子问题\n        cur = top->_right;\n    }\n    cout << endl;\n}\n```\n### 中序遍历非递归\n中序遍历和先序遍历唯一的不同就是先序遍历是访问当前结点就打印当前结点，中序遍历就是先走完左边，再回来获取结点，这个时候再输出。\n```c++\n//InOrderNonR\nvoid InOrderNonR(){\n    stack<Node*> s;\n    Node* cur = _root;\n    while(cur || !s.empty()){\n        while(cur){\n            s.push(cur);\n            cur = cur->_left;\n        }\n        Node* top = s.top();\n        s.pop();\n        cout << top->_data << \" \";\n        cur = top->_right;\n    }\n    cout << endl;\n}\n```\n### 后序遍历非递归\n后序遍历相比于之前的有一个转弯，看下图：\n![后序遍历非递归](http://p3ax8ersb.bkt.clouddn.com/201803061639_158.png-960.jpg)\n所以为了区分这个点，先设立一个prev，prev指向当前结点cur的上一个结点。如果`prev == cur->_right`表示当前结点的右子树已经访问完成，那么就可以输出cur了。\n```c++\n//PostOrderNonR\nvoid PostOrderNonR(){\n    stack<Node*> s;\n    Node* cur = _root;\n    Node* prev = NULL;\n    while(cur || !s.empty()){\n        //一路向左走到底\n        while(cur){\n            s.push(cur);\n            cur = cur->_left;\n        }\n        Node* top = s.top();\n        //访问当前结点的两个条件\n        //1、没有右子树\n        //2、右子树已经访问完成\n        if(top->_right == NULL || prev == top->_right){\n            s.pop();\n            //此时的top成为过去式，将top设置为prev\n            prev = top;\n            cout << top->_data << \" \";\n        }\n        //此时表示右子树还没有访问\n        else{\n            cur = top->_right;\n        }\n    }\n    cout << endl;\n}\n```\n## 结点个数函数\n以下函数都利用了递归的思想。\n### 统计结点个数函数Size\n```c++\n//Size\nsize_t Size(){\n    return _Size(_root);\n}\nsize_t _Size(Node* root){\n    if(root == NULL)\n        return 0;\n    return _Size(root->_left) + _Size(root->_right) + 1;\n}\n```\n### 统计深度函数Depth\n统计深度的时候，因为二叉树有左右子树，所以需要区分是左子树结点多还是右子树结点多。通过两个变量来记录，分别统计大小，然后再比较大小，大的是深度。\n这里默认根节点是第一层\n```c++\n//Depth\nsize_t Depth(){\n    return _Depth(_root);\n}\nsize_t _Depth(Node* root){\n    size_t leftnum = 0;\n    size_t rightnum = 0;\n    if(root == NULL)\n        return 0;\n    //如果存在就接着往下递归\n    if(root->_left)\n        leftnum += _Depth(root->_left);\n    if(root->_right)\n        rightnum += _Depth(root->_right);\n    return (leftnum > rightnum ? leftnum : rightnum) + 1;\n}\n```\n### 统计叶子结点个数的函数LeafSize\n叶子结点的统计是在当前结点都没有左右子树的时候返回个数1。\n```c++\n//LeafSize\nsize_t LeafSize(){\n    return _LeafSize(_root);\n}\nsize_t _LeafSize(Node* root){\n    if(root == NULL)\n        return 0;\n    if(root->_left == NULL && root->_right == NULL)\n        return 1;\n    return _LeafSize(root->_left) + _LeafSize(root->_right);\n}\n```\n### 计算第K层的结点个数函数GetKLevel\n这个函数可以**通过子问题的思想**来解决。比如：我要计算第三层，当指针在第一层的时候，是计算K=3；当指针在第二层的时候，是计算K=2；当指针在第三层的时候，是计算K=1的结点个数。所以只要当K=1的时候返回计算值1就好了。\n```c++\n//GetKLevel\nsize_t GetKLevel(size_t K){\n    return _GetKLevel(_root, K);\n}\nsize_t _GetKLevel(Node* root, size_t K){\n    if(K == 0 || root == NULL)\n        return 0;\n    if(K == 1)\n        return 1;\n    //不能使用--K，应该用K-1。\n    //不能返回除了K=1的其他情况。\n    return _GetKLevel(root->_left, K - 1) + _GetKLevel(root->_right, K - 1);\n}\n```\n## 测试代码\n```c++\nint a1[] = {1,2,3,'#','#',4,'#','#',5,6,'#','#','#'};\nint a2[] = {1,2,'#',3,'#','#',4,5,'#',6,'#',7,'#','#',8,'#','#'};\nBinaryTree<int> tree(a1,'#');\nBinaryTree<int> tree1(a2, '#');\nBinaryTree<int> tree2(tree);\ntree2 = tree1;\n\ncout << \"tree.PrevOrder\" << endl;\ntree.PrevOrder();\ncout << \"tree1.InOrder\" << endl;\ntree1.InOrder();\ncout << \"tree2.PostOrder\" << endl;\ntree2.PostOrder();\n\ncout << \"tree.LevelOrder\" << endl;\ntree.LevelOrder();\ncout << \"tree.PrevOrderNonR\" << endl;\ntree.PrevOrderNonR();\ncout << \"tree1.InOrderNonR\" << endl;\ntree1.InOrderNonR();\ncout << \"tree2.PostOrderNonR\" << endl;\ntree2.PostOrderNonR();\n\ncout << \"tree.Size:\" << tree.Size() << endl;\ncout << \"tree.Depth:\" << tree.Depth() << endl;\ncout << \"tree.LeafSize:\" << tree.LeafSize() << endl;\ncout << \"tree.GetKLevel(K=2):\" << tree.GetKLevel(2) << endl;\n\ncout << \"tree1.Size:\" << tree1.Size() << endl;\ncout << \"tree1.Depth:\" << tree1.Depth() << endl;\ncout << \"tree1.LeafSize:\" << tree1.LeafSize() << endl;\ncout << \"tree1.GetKLevel(K=3):\" << tree1.GetKLevel(3) << endl;\n```\n截图如下：\n![测试](http://p3ax8ersb.bkt.clouddn.com/201803061640_12.png-960.jpg)\n二叉树的实现，最重要的是要掌握子问题的思想，通过子问题的思想来解决左右子树，只需要一个递归就好了。\n","source":"_posts/二叉树的基本实现.md","raw":"---\ntitle: 二叉树的基本实现\ndate: 2018-03-06 15:47:19\ntags:\ncategories:\n    - \"knowledge\"\n    - \"C/C++\"\nkeywords:\n    - \"C++\"\n    - \"binarytree\"\n    - \"非递归遍历\"\npassword:\n---\n## 二叉树\n本文将使用c++实现模板类的二叉树，内容包括创建、递归遍历、非递归遍历、结点个数、深度、叶子结点的个数、第K层结点个数等函数。\n### 结点、二叉树结构\n二叉树的结点是一个结构体，包括值`_data`，指向左子树的指针和指向右子树的指针`_left`和`_right`。还有构造函数，用于创建结点。<!--more-->\n将`BinaryTreeNode<T>`typedef为`Node`,很多时候我会遗漏模板的类型名需要加上`<T>`，这样就会出错。为了减少这种错误，索性用typedef换名。<\n```c++\ntemplate <class T>\nstruct BinaryTreeNode\n{\n    BinaryTreeNode* _left;\n    BinaryTreeNode* _right;\n    T _data;\n\n    BinaryTreeNode(const T& data = T()){\n        _data = data;\n        _left = NULL;\n        _right = NULL;\n    }\n};\n\ntemplate <class T>\nclass BinaryTree{\ntypedef BinaryTreeNode<T> Node;\npublic:\n    //...\nprotected:\n    Node* _root;\n};\n```\n## 默认成员函数\n### 构造函数\n设置了两个构造函数，一个为空，用于创建一个空的二叉树；另一个参数为两个。\n`const T* a` 数组名\n`const T& invalid` 非法值\n解释一下，这里我用一个数组创建二叉树，同时用'#'表示这个空。如这个例子：\n\n    int a1[] = {1,2,3,'#','#',4,'#','#',5,6,'#','#','#'};\n如果`a1[i] != '#'`那么就创建，反之，表示这个位置没有结点。\n```c++\n//constructor\nBinaryTree(){\n    _root = NULL;\n}\nBinaryTree(const T* a, const T& invalid){\n    size_t index = 0;\n    _root = _CreateTree(a, invalid, index);\n}\nNode* _CreateTree(const T* a, const T& invalid, size_t& index){\n    Node* root = NULL;\n    if(a[index] != invalid){\n        root = new Node(a[index]);\n        root->_left = _CreateTree(a, invalid, ++index);\n        root->_right = _CreateTree(a, invalid, ++index);\n    }\n    return root;\n}\n```\n构造函数利用递归的思想，先跟的次序创建二叉树。**由于要利用到递归，就没有办法直接用构造函数来实现，因为在class之外是没有办法访问到_root的。所以通过一个函数，利用这个函数来实现递归的过程。**\n构造出来的二叉树关系图：\n![二叉树](http://p3ax8ersb.bkt.clouddn.com/201803061638_7.png-480.jpg)\n### 拷贝构造\n拷贝构造利用了一个`_CopyTree`函数。\n```c++\nBinaryTree(const BinaryTree& tree){\n    _root = _CopyTree(tree._root);\n}\nNode* _CopyTree(Node* root){\n    Node* node = root;\n    if(node){\n        node = new Node(root->_data);\n        node->_left = _CopyTree(root->_left);\n        node->_right = _CopyTree(root->_right);\n    }\n    return node;\n}\n```\n### 析构函数\n析构函数利用了一个`Destroy`函数\n```c++\n//destructor\n~BinaryTree(){\n    Destroy(_root);\n}\nvoid Destroy(Node* root){\n    if(root == NULL)\n        return;\n    Destroy(root->_left);\n    Destroy(root->_right);\n    delete root;\n}\n```\n### operator=(赋值运算符的重载)\n先调用析构函数的`Destroy`销毁当前二叉树，然后调用`_CopyTree`重新构造当前二叉树。\n```c++\n//operator=\nBinaryTree<T>& operator=(const BinaryTree<T>& tree){\n    if(this != &tree){\n        Destroy(_root);\n        _root = _CopyTree(tree._root);\n        return *this;\n    }\n}\n\n//BinaryTree<T>& operator=(BinaryTree<T> tree){\n    //if(this != &tree){\n        //swap(_root, tree._root);\n        //return *this;\n    //}\n//}\n```\n赋值运算符的重载有两种实现方式，第一种是传统写法，第二种是现代写法。传统写法就是销毁原来的空间，然后重新开辟新的空间。对内存的操作比较多。现代写法是利用拷贝构造的方式，**在传值进来的时候，生成一份临时拷贝**，然后交换当前二叉树和临时拷贝的根节点，返回根节点，同时利用临时拷贝的作用域，交换后的二叉树在出了当前函数之后被销毁。**相当于借用了系统的拷贝机制和自动析构机制来实现赋值的过程。**\n## 递归遍历\n### 先序遍历\n先序遍历：`root left right`\n```c++\n//PrevOrder\nvoid PrevOrder(){\n    _PrevOrder(_root);\n    cout << endl;\n}\nvoid _PrevOrder(Node* root){\n    if(root){\n        cout << root->_data << \" \";\n        _PrevOrder(root->_left);\n        _PrevOrder(root->_right);\n    }\n    return;\n}\n```\n### 中序遍历\n中序遍历：`left root right`\n```c++\n//InOrder\nvoid InOrder(){\n    _InOreder(_root);\n    cout << endl;\n}\nvoid _InOreder(Node* root){\n    if(root){\n        _InOreder(root->_left);\n        cout << root->_data << \" \";\n        _InOreder(root->_right);\n    }\n    return;\n}\n```\n### 后序遍历\n后序遍历：`left root right`\n```c++\n//PostOrder\nvoid PostOrder(){\n    _PostOrder(_root);\n    cout << endl;\n}\nvoid _PostOrder(Node* root){\n    if(root){\n        _PostOrder(root->_left);\n        _PostOrder(root->_right);\n        cout << root->_data << \" \";\n    }\n    return;\n}\n```\n## 非递归遍历\n之所以要出现非递归遍历，是因为递归遍历有一定的缺陷。比如：当二叉树是一颗父节点只有一个子节点的树，那么对堆栈的使用就很大，**有可能出现堆栈使用太深而栈溢出的情况**。为了避免这种情况的出现，有必要使用非递归遍历。\n**非递归遍历利用栈来实现对之前的结点的存储**，因为每一颗二叉树都有可能有左右子树，所以需要在访问单边的子树的时候，将结点保存下来，这样是为了之后可以返回去访问结点的另一边的子树。\n### 层次遍历\n层次遍历是一层一层的遍历结点的。它与之前三个的遍历方式都不一样。**他利用的是队列，通过队列让父节点带动子节点。**\n```c++\n//LevelOrder\nvoid LevelOrder(){\n    //不能是T，要用到root->_left; root->_right;\n    //不好是Node，结构体太大;\n    queue<Node*> q;\n    if(_root){\n        q.push(_root);\n        while(!q.empty()){\n            Node* top = q.front();\n            //获取到队头之后，将当前结点pop\n            q.pop();\n            cout << top->_data << \" \";\n            //如果左右子树存在，就入队列\n            if(top->_left)\n                q.push(top->_left);\n            if(top->_right)\n                q.push(top->_right);\n        }\n    }\n    cout << endl;\n}\n```\n### 先序遍历非递归\n根据先序遍历的特点，先输出当前结点，然后一路向左，访问完左边再返回访问上一个结点的右子树，这个就是子问题，利用上面一样的方法。\n```c++\n//PrevOrderNonR\nvoid PrevOrderNonR(){\n    //利用栈得以记录访问过的根，用来以后访问右子树\n    stack<Node*> s;\n    Node* cur = _root;\n    while(cur || !s.empty()){\n        //根据先根的次序，访问当前节点，并一路向左访问\n        while(cur){\n            cout << cur->_data << \" \";\n            s.push(cur);\n            cur = cur->_left;\n        }\n        Node* top = s.top();\n        //pop表示左子树已经访问完，接下来访问右子树\n        s.pop();\n        //右子树的访问是子问题\n        cur = top->_right;\n    }\n    cout << endl;\n}\n```\n### 中序遍历非递归\n中序遍历和先序遍历唯一的不同就是先序遍历是访问当前结点就打印当前结点，中序遍历就是先走完左边，再回来获取结点，这个时候再输出。\n```c++\n//InOrderNonR\nvoid InOrderNonR(){\n    stack<Node*> s;\n    Node* cur = _root;\n    while(cur || !s.empty()){\n        while(cur){\n            s.push(cur);\n            cur = cur->_left;\n        }\n        Node* top = s.top();\n        s.pop();\n        cout << top->_data << \" \";\n        cur = top->_right;\n    }\n    cout << endl;\n}\n```\n### 后序遍历非递归\n后序遍历相比于之前的有一个转弯，看下图：\n![后序遍历非递归](http://p3ax8ersb.bkt.clouddn.com/201803061639_158.png-960.jpg)\n所以为了区分这个点，先设立一个prev，prev指向当前结点cur的上一个结点。如果`prev == cur->_right`表示当前结点的右子树已经访问完成，那么就可以输出cur了。\n```c++\n//PostOrderNonR\nvoid PostOrderNonR(){\n    stack<Node*> s;\n    Node* cur = _root;\n    Node* prev = NULL;\n    while(cur || !s.empty()){\n        //一路向左走到底\n        while(cur){\n            s.push(cur);\n            cur = cur->_left;\n        }\n        Node* top = s.top();\n        //访问当前结点的两个条件\n        //1、没有右子树\n        //2、右子树已经访问完成\n        if(top->_right == NULL || prev == top->_right){\n            s.pop();\n            //此时的top成为过去式，将top设置为prev\n            prev = top;\n            cout << top->_data << \" \";\n        }\n        //此时表示右子树还没有访问\n        else{\n            cur = top->_right;\n        }\n    }\n    cout << endl;\n}\n```\n## 结点个数函数\n以下函数都利用了递归的思想。\n### 统计结点个数函数Size\n```c++\n//Size\nsize_t Size(){\n    return _Size(_root);\n}\nsize_t _Size(Node* root){\n    if(root == NULL)\n        return 0;\n    return _Size(root->_left) + _Size(root->_right) + 1;\n}\n```\n### 统计深度函数Depth\n统计深度的时候，因为二叉树有左右子树，所以需要区分是左子树结点多还是右子树结点多。通过两个变量来记录，分别统计大小，然后再比较大小，大的是深度。\n这里默认根节点是第一层\n```c++\n//Depth\nsize_t Depth(){\n    return _Depth(_root);\n}\nsize_t _Depth(Node* root){\n    size_t leftnum = 0;\n    size_t rightnum = 0;\n    if(root == NULL)\n        return 0;\n    //如果存在就接着往下递归\n    if(root->_left)\n        leftnum += _Depth(root->_left);\n    if(root->_right)\n        rightnum += _Depth(root->_right);\n    return (leftnum > rightnum ? leftnum : rightnum) + 1;\n}\n```\n### 统计叶子结点个数的函数LeafSize\n叶子结点的统计是在当前结点都没有左右子树的时候返回个数1。\n```c++\n//LeafSize\nsize_t LeafSize(){\n    return _LeafSize(_root);\n}\nsize_t _LeafSize(Node* root){\n    if(root == NULL)\n        return 0;\n    if(root->_left == NULL && root->_right == NULL)\n        return 1;\n    return _LeafSize(root->_left) + _LeafSize(root->_right);\n}\n```\n### 计算第K层的结点个数函数GetKLevel\n这个函数可以**通过子问题的思想**来解决。比如：我要计算第三层，当指针在第一层的时候，是计算K=3；当指针在第二层的时候，是计算K=2；当指针在第三层的时候，是计算K=1的结点个数。所以只要当K=1的时候返回计算值1就好了。\n```c++\n//GetKLevel\nsize_t GetKLevel(size_t K){\n    return _GetKLevel(_root, K);\n}\nsize_t _GetKLevel(Node* root, size_t K){\n    if(K == 0 || root == NULL)\n        return 0;\n    if(K == 1)\n        return 1;\n    //不能使用--K，应该用K-1。\n    //不能返回除了K=1的其他情况。\n    return _GetKLevel(root->_left, K - 1) + _GetKLevel(root->_right, K - 1);\n}\n```\n## 测试代码\n```c++\nint a1[] = {1,2,3,'#','#',4,'#','#',5,6,'#','#','#'};\nint a2[] = {1,2,'#',3,'#','#',4,5,'#',6,'#',7,'#','#',8,'#','#'};\nBinaryTree<int> tree(a1,'#');\nBinaryTree<int> tree1(a2, '#');\nBinaryTree<int> tree2(tree);\ntree2 = tree1;\n\ncout << \"tree.PrevOrder\" << endl;\ntree.PrevOrder();\ncout << \"tree1.InOrder\" << endl;\ntree1.InOrder();\ncout << \"tree2.PostOrder\" << endl;\ntree2.PostOrder();\n\ncout << \"tree.LevelOrder\" << endl;\ntree.LevelOrder();\ncout << \"tree.PrevOrderNonR\" << endl;\ntree.PrevOrderNonR();\ncout << \"tree1.InOrderNonR\" << endl;\ntree1.InOrderNonR();\ncout << \"tree2.PostOrderNonR\" << endl;\ntree2.PostOrderNonR();\n\ncout << \"tree.Size:\" << tree.Size() << endl;\ncout << \"tree.Depth:\" << tree.Depth() << endl;\ncout << \"tree.LeafSize:\" << tree.LeafSize() << endl;\ncout << \"tree.GetKLevel(K=2):\" << tree.GetKLevel(2) << endl;\n\ncout << \"tree1.Size:\" << tree1.Size() << endl;\ncout << \"tree1.Depth:\" << tree1.Depth() << endl;\ncout << \"tree1.LeafSize:\" << tree1.LeafSize() << endl;\ncout << \"tree1.GetKLevel(K=3):\" << tree1.GetKLevel(3) << endl;\n```\n截图如下：\n![测试](http://p3ax8ersb.bkt.clouddn.com/201803061640_12.png-960.jpg)\n二叉树的实现，最重要的是要掌握子问题的思想，通过子问题的思想来解决左右子树，只需要一个递归就好了。\n","slug":"二叉树的基本实现","published":1,"updated":"2018-03-06T09:16:54.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nqz5000d04d88qoqxezl","content":"<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><p>本文将使用c++实现模板类的二叉树，内容包括创建、递归遍历、非递归遍历、结点个数、深度、叶子结点的个数、第K层结点个数等函数。</p>\n<h3 id=\"结点、二叉树结构\"><a href=\"#结点、二叉树结构\" class=\"headerlink\" title=\"结点、二叉树结构\"></a>结点、二叉树结构</h3><p>二叉树的结点是一个结构体，包括值<code>_data</code>，指向左子树的指针和指向右子树的指针<code>_left</code>和<code>_right</code>。还有构造函数，用于创建结点。<a id=\"more\"></a><br>将<code>BinaryTreeNode&lt;T&gt;</code>typedef为<code>Node</code>,很多时候我会遗漏模板的类型名需要加上<code>&lt;T&gt;</code>，这样就会出错。为了减少这种错误，索性用typedef换名。&lt;<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">BinaryTreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    BinaryTreeNode* _left;</span><br><span class=\"line\">    BinaryTreeNode* _right;</span><br><span class=\"line\">    T _data;</span><br><span class=\"line\"></span><br><span class=\"line\">    BinaryTreeNode(<span class=\"keyword\">const</span> T&amp; data = T())&#123;</span><br><span class=\"line\">        _data = data;</span><br><span class=\"line\">        _left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        _right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">BinaryTree</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> BinaryTreeNode&lt;T&gt; Node;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    Node* _root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"默认成员函数\"><a href=\"#默认成员函数\" class=\"headerlink\" title=\"默认成员函数\"></a>默认成员函数</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>设置了两个构造函数，一个为空，用于创建一个空的二叉树；另一个参数为两个。<br><code>const T* a</code> 数组名<br><code>const T&amp; invalid</code> 非法值<br>解释一下，这里我用一个数组创建二叉树，同时用’#’表示这个空。如这个例子：</p>\n<pre><code>int a1[] = {1,2,3,&apos;#&apos;,&apos;#&apos;,4,&apos;#&apos;,&apos;#&apos;,5,6,&apos;#&apos;,&apos;#&apos;,&apos;#&apos;};\n</code></pre><p>如果<code>a1[i] != &#39;#&#39;</code>那么就创建，反之，表示这个位置没有结点。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//constructor</span></span><br><span class=\"line\">BinaryTree()&#123;</span><br><span class=\"line\">    _root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BinaryTree(<span class=\"keyword\">const</span> T* a, <span class=\"keyword\">const</span> T&amp; invalid)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    _root = _CreateTree(a, invalid, index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Node* _CreateTree(<span class=\"keyword\">const</span> T* a, <span class=\"keyword\">const</span> T&amp; invalid, <span class=\"keyword\">size_t</span>&amp; index)&#123;</span><br><span class=\"line\">    Node* root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a[index] != invalid)&#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> Node(a[index]);</span><br><span class=\"line\">        root-&gt;_left = _CreateTree(a, invalid, ++index);</span><br><span class=\"line\">        root-&gt;_right = _CreateTree(a, invalid, ++index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造函数利用递归的思想，先跟的次序创建二叉树。<strong>由于要利用到递归，就没有办法直接用构造函数来实现，因为在class之外是没有办法访问到_root的。所以通过一个函数，利用这个函数来实现递归的过程。</strong><br>构造出来的二叉树关系图：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803061638_7.png-480.jpg\" alt=\"二叉树\"></p>\n<h3 id=\"拷贝构造\"><a href=\"#拷贝构造\" class=\"headerlink\" title=\"拷贝构造\"></a>拷贝构造</h3><p>拷贝构造利用了一个<code>_CopyTree</code>函数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinaryTree(<span class=\"keyword\">const</span> BinaryTree&amp; tree)&#123;</span><br><span class=\"line\">    _root = _CopyTree(tree._root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Node* _CopyTree(Node* root)&#123;</span><br><span class=\"line\">    Node* node = root;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node)&#123;</span><br><span class=\"line\">        node = <span class=\"keyword\">new</span> Node(root-&gt;_data);</span><br><span class=\"line\">        node-&gt;_left = _CopyTree(root-&gt;_left);</span><br><span class=\"line\">        node-&gt;_right = _CopyTree(root-&gt;_right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>析构函数利用了一个<code>Destroy</code>函数<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//destructor</span></span><br><span class=\"line\">~BinaryTree()&#123;</span><br><span class=\"line\">    Destroy(_root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy</span><span class=\"params\">(Node* root)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Destroy(root-&gt;_left);</span><br><span class=\"line\">    Destroy(root-&gt;_right);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"operator-赋值运算符的重载\"><a href=\"#operator-赋值运算符的重载\" class=\"headerlink\" title=\"operator=(赋值运算符的重载)\"></a>operator=(赋值运算符的重载)</h3><p>先调用析构函数的<code>Destroy</code>销毁当前二叉树，然后调用<code>_CopyTree</code>重新构造当前二叉树。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//operator=</span></span><br><span class=\"line\">BinaryTree&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> BinaryTree&lt;T&gt;&amp; tree)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> != &amp;tree)&#123;</span><br><span class=\"line\">        Destroy(_root);</span><br><span class=\"line\">        _root = _CopyTree(tree._root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//BinaryTree&lt;T&gt;&amp; operator=(BinaryTree&lt;T&gt; tree)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//if(this != &amp;tree)&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//swap(_root, tree._root);</span></span><br><span class=\"line\">        <span class=\"comment\">//return *this;</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>赋值运算符的重载有两种实现方式，第一种是传统写法，第二种是现代写法。传统写法就是销毁原来的空间，然后重新开辟新的空间。对内存的操作比较多。现代写法是利用拷贝构造的方式，<strong>在传值进来的时候，生成一份临时拷贝</strong>，然后交换当前二叉树和临时拷贝的根节点，返回根节点，同时利用临时拷贝的作用域，交换后的二叉树在出了当前函数之后被销毁。<strong>相当于借用了系统的拷贝机制和自动析构机制来实现赋值的过程。</strong></p>\n<h2 id=\"递归遍历\"><a href=\"#递归遍历\" class=\"headerlink\" title=\"递归遍历\"></a>递归遍历</h2><h3 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h3><p>先序遍历：<code>root left right</code><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PrevOrder</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrevOrder</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    _PrevOrder(_root);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> _PrevOrder(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        _PrevOrder(root-&gt;_left);</span><br><span class=\"line\">        _PrevOrder(root-&gt;_right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h3><p>中序遍历：<code>left root right</code><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//InOrder</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrder</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    _InOreder(_root);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> _InOreder(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root)&#123;</span><br><span class=\"line\">        _InOreder(root-&gt;_left);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        _InOreder(root-&gt;_right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h3><p>后序遍历：<code>left root right</code><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PostOrder</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PostOrder</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    _PostOrder(_root);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> _PostOrder(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root)&#123;</span><br><span class=\"line\">        _PostOrder(root-&gt;_left);</span><br><span class=\"line\">        _PostOrder(root-&gt;_right);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"非递归遍历\"><a href=\"#非递归遍历\" class=\"headerlink\" title=\"非递归遍历\"></a>非递归遍历</h2><p>之所以要出现非递归遍历，是因为递归遍历有一定的缺陷。比如：当二叉树是一颗父节点只有一个子节点的树，那么对堆栈的使用就很大，<strong>有可能出现堆栈使用太深而栈溢出的情况</strong>。为了避免这种情况的出现，有必要使用非递归遍历。<br><strong>非递归遍历利用栈来实现对之前的结点的存储</strong>，因为每一颗二叉树都有可能有左右子树，所以需要在访问单边的子树的时候，将结点保存下来，这样是为了之后可以返回去访问结点的另一边的子树。</p>\n<h3 id=\"层次遍历\"><a href=\"#层次遍历\" class=\"headerlink\" title=\"层次遍历\"></a>层次遍历</h3><p>层次遍历是一层一层的遍历结点的。它与之前三个的遍历方式都不一样。<strong>他利用的是队列，通过队列让父节点带动子节点。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//LevelOrder</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LevelOrder</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不能是T，要用到root-&gt;_left; root-&gt;_right;</span></span><br><span class=\"line\">    <span class=\"comment\">//不好是Node，结构体太大;</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;Node*&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_root)&#123;</span><br><span class=\"line\">        q.push(_root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">            Node* top = q.front();</span><br><span class=\"line\">            <span class=\"comment\">//获取到队头之后，将当前结点pop</span></span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; top-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">            <span class=\"comment\">//如果左右子树存在，就入队列</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(top-&gt;_left)</span><br><span class=\"line\">                q.push(top-&gt;_left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(top-&gt;_right)</span><br><span class=\"line\">                q.push(top-&gt;_right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"先序遍历非递归\"><a href=\"#先序遍历非递归\" class=\"headerlink\" title=\"先序遍历非递归\"></a>先序遍历非递归</h3><p>根据先序遍历的特点，先输出当前结点，然后一路向左，访问完左边再返回访问上一个结点的右子树，这个就是子问题，利用上面一样的方法。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PrevOrderNonR</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrevOrderNonR</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//利用栈得以记录访问过的根，用来以后访问右子树</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;Node*&gt; s;</span><br><span class=\"line\">    Node* cur = _root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur || !s.empty())&#123;</span><br><span class=\"line\">        <span class=\"comment\">//根据先根的次序，访问当前节点，并一路向左访问</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; cur-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">            s.push(cur);</span><br><span class=\"line\">            cur = cur-&gt;_left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node* top = s.top();</span><br><span class=\"line\">        <span class=\"comment\">//pop表示左子树已经访问完，接下来访问右子树</span></span><br><span class=\"line\">        s.pop();</span><br><span class=\"line\">        <span class=\"comment\">//右子树的访问是子问题</span></span><br><span class=\"line\">        cur = top-&gt;_right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"中序遍历非递归\"><a href=\"#中序遍历非递归\" class=\"headerlink\" title=\"中序遍历非递归\"></a>中序遍历非递归</h3><p>中序遍历和先序遍历唯一的不同就是先序遍历是访问当前结点就打印当前结点，中序遍历就是先走完左边，再回来获取结点，这个时候再输出。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//InOrderNonR</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrderNonR</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;Node*&gt; s;</span><br><span class=\"line\">    Node* cur = _root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur || !s.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur)&#123;</span><br><span class=\"line\">            s.push(cur);</span><br><span class=\"line\">            cur = cur-&gt;_left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node* top = s.top();</span><br><span class=\"line\">        s.pop();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; top-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        cur = top-&gt;_right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"后序遍历非递归\"><a href=\"#后序遍历非递归\" class=\"headerlink\" title=\"后序遍历非递归\"></a>后序遍历非递归</h3><p>后序遍历相比于之前的有一个转弯，看下图：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803061639_158.png-960.jpg\" alt=\"后序遍历非递归\"><br>所以为了区分这个点，先设立一个prev，prev指向当前结点cur的上一个结点。如果<code>prev == cur-&gt;_right</code>表示当前结点的右子树已经访问完成，那么就可以输出cur了。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PostOrderNonR</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PostOrderNonR</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;Node*&gt; s;</span><br><span class=\"line\">    Node* cur = _root;</span><br><span class=\"line\">    Node* prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur || !s.empty())&#123;</span><br><span class=\"line\">        <span class=\"comment\">//一路向左走到底</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur)&#123;</span><br><span class=\"line\">            s.push(cur);</span><br><span class=\"line\">            cur = cur-&gt;_left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node* top = s.top();</span><br><span class=\"line\">        <span class=\"comment\">//访问当前结点的两个条件</span></span><br><span class=\"line\">        <span class=\"comment\">//1、没有右子树</span></span><br><span class=\"line\">        <span class=\"comment\">//2、右子树已经访问完成</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(top-&gt;_right == <span class=\"literal\">NULL</span> || prev == top-&gt;_right)&#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">            <span class=\"comment\">//此时的top成为过去式，将top设置为prev</span></span><br><span class=\"line\">            prev = top;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; top-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//此时表示右子树还没有访问</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            cur = top-&gt;_right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结点个数函数\"><a href=\"#结点个数函数\" class=\"headerlink\" title=\"结点个数函数\"></a>结点个数函数</h2><p>以下函数都利用了递归的思想。</p>\n<h3 id=\"统计结点个数函数Size\"><a href=\"#统计结点个数函数Size\" class=\"headerlink\" title=\"统计结点个数函数Size\"></a>统计结点个数函数Size</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Size</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> Size()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _Size(_root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">size_t</span> _Size(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _Size(root-&gt;_left) + _Size(root-&gt;_right) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"统计深度函数Depth\"><a href=\"#统计深度函数Depth\" class=\"headerlink\" title=\"统计深度函数Depth\"></a>统计深度函数Depth</h3><p>统计深度的时候，因为二叉树有左右子树，所以需要区分是左子树结点多还是右子树结点多。通过两个变量来记录，分别统计大小，然后再比较大小，大的是深度。<br>这里默认根节点是第一层<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Depth</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> Depth()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _Depth(_root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">size_t</span> _Depth(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> leftnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> rightnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//如果存在就接着往下递归</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root-&gt;_left)</span><br><span class=\"line\">        leftnum += _Depth(root-&gt;_left);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root-&gt;_right)</span><br><span class=\"line\">        rightnum += _Depth(root-&gt;_right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (leftnum &gt; rightnum ? leftnum : rightnum) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"统计叶子结点个数的函数LeafSize\"><a href=\"#统计叶子结点个数的函数LeafSize\" class=\"headerlink\" title=\"统计叶子结点个数的函数LeafSize\"></a>统计叶子结点个数的函数LeafSize</h3><p>叶子结点的统计是在当前结点都没有左右子树的时候返回个数1。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//LeafSize</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> LeafSize()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _LeafSize(_root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">size_t</span> _LeafSize(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root-&gt;_left == <span class=\"literal\">NULL</span> &amp;&amp; root-&gt;_right == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _LeafSize(root-&gt;_left) + _LeafSize(root-&gt;_right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"计算第K层的结点个数函数GetKLevel\"><a href=\"#计算第K层的结点个数函数GetKLevel\" class=\"headerlink\" title=\"计算第K层的结点个数函数GetKLevel\"></a>计算第K层的结点个数函数GetKLevel</h3><p>这个函数可以<strong>通过子问题的思想</strong>来解决。比如：我要计算第三层，当指针在第一层的时候，是计算K=3；当指针在第二层的时候，是计算K=2；当指针在第三层的时候，是计算K=1的结点个数。所以只要当K=1的时候返回计算值1就好了。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GetKLevel</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> GetKLevel(<span class=\"keyword\">size_t</span> K)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _GetKLevel(_root, K);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">size_t</span> _GetKLevel(Node* root, <span class=\"keyword\">size_t</span> K)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(K == <span class=\"number\">0</span> || root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(K == <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//不能使用--K，应该用K-1。</span></span><br><span class=\"line\">    <span class=\"comment\">//不能返回除了K=1的其他情况。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _GetKLevel(root-&gt;_left, K - <span class=\"number\">1</span>) + _GetKLevel(root-&gt;_right, K - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a1[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>,<span class=\"number\">4</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a2[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">'#'</span>,<span class=\"number\">3</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"string\">'#'</span>,<span class=\"number\">6</span>,<span class=\"string\">'#'</span>,<span class=\"number\">7</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>,<span class=\"number\">8</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>&#125;;</span><br><span class=\"line\">BinaryTree&lt;<span class=\"keyword\">int</span>&gt; tree(a1,<span class=\"string\">'#'</span>);</span><br><span class=\"line\">BinaryTree&lt;<span class=\"keyword\">int</span>&gt; tree1(a2, <span class=\"string\">'#'</span>);</span><br><span class=\"line\">BinaryTree&lt;<span class=\"keyword\">int</span>&gt; tree2(tree);</span><br><span class=\"line\">tree2 = tree1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.PrevOrder\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree.PrevOrder();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.InOrder\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree1.InOrder();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree2.PostOrder\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree2.PostOrder();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.LevelOrder\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree.LevelOrder();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.PrevOrderNonR\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree.PrevOrderNonR();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.InOrderNonR\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree1.InOrderNonR();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree2.PostOrderNonR\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree2.PostOrderNonR();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.Size:\"</span> &lt;&lt; tree.Size() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.Depth:\"</span> &lt;&lt; tree.Depth() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.LeafSize:\"</span> &lt;&lt; tree.LeafSize() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.GetKLevel(K=2):\"</span> &lt;&lt; tree.GetKLevel(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.Size:\"</span> &lt;&lt; tree1.Size() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.Depth:\"</span> &lt;&lt; tree1.Depth() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.LeafSize:\"</span> &lt;&lt; tree1.LeafSize() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.GetKLevel(K=3):\"</span> &lt;&lt; tree1.GetKLevel(<span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>截图如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803061640_12.png-960.jpg\" alt=\"测试\"><br>二叉树的实现，最重要的是要掌握子问题的思想，通过子问题的思想来解决左右子树，只需要一个递归就好了。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><p>本文将使用c++实现模板类的二叉树，内容包括创建、递归遍历、非递归遍历、结点个数、深度、叶子结点的个数、第K层结点个数等函数。</p>\n<h3 id=\"结点、二叉树结构\"><a href=\"#结点、二叉树结构\" class=\"headerlink\" title=\"结点、二叉树结构\"></a>结点、二叉树结构</h3><p>二叉树的结点是一个结构体，包括值<code>_data</code>，指向左子树的指针和指向右子树的指针<code>_left</code>和<code>_right</code>。还有构造函数，用于创建结点。","more":"<br>将<code>BinaryTreeNode&lt;T&gt;</code>typedef为<code>Node</code>,很多时候我会遗漏模板的类型名需要加上<code>&lt;T&gt;</code>，这样就会出错。为了减少这种错误，索性用typedef换名。&lt;<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">BinaryTreeNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    BinaryTreeNode* _left;</span><br><span class=\"line\">    BinaryTreeNode* _right;</span><br><span class=\"line\">    T _data;</span><br><span class=\"line\"></span><br><span class=\"line\">    BinaryTreeNode(<span class=\"keyword\">const</span> T&amp; data = T())&#123;</span><br><span class=\"line\">        _data = data;</span><br><span class=\"line\">        _left = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        _right = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">BinaryTree</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> BinaryTreeNode&lt;T&gt; Node;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    Node* _root;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"默认成员函数\"><a href=\"#默认成员函数\" class=\"headerlink\" title=\"默认成员函数\"></a>默认成员函数</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>设置了两个构造函数，一个为空，用于创建一个空的二叉树；另一个参数为两个。<br><code>const T* a</code> 数组名<br><code>const T&amp; invalid</code> 非法值<br>解释一下，这里我用一个数组创建二叉树，同时用’#’表示这个空。如这个例子：</p>\n<pre><code>int a1[] = {1,2,3,&apos;#&apos;,&apos;#&apos;,4,&apos;#&apos;,&apos;#&apos;,5,6,&apos;#&apos;,&apos;#&apos;,&apos;#&apos;};\n</code></pre><p>如果<code>a1[i] != &#39;#&#39;</code>那么就创建，反之，表示这个位置没有结点。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//constructor</span></span><br><span class=\"line\">BinaryTree()&#123;</span><br><span class=\"line\">    _root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BinaryTree(<span class=\"keyword\">const</span> T* a, <span class=\"keyword\">const</span> T&amp; invalid)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    _root = _CreateTree(a, invalid, index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Node* _CreateTree(<span class=\"keyword\">const</span> T* a, <span class=\"keyword\">const</span> T&amp; invalid, <span class=\"keyword\">size_t</span>&amp; index)&#123;</span><br><span class=\"line\">    Node* root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a[index] != invalid)&#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> Node(a[index]);</span><br><span class=\"line\">        root-&gt;_left = _CreateTree(a, invalid, ++index);</span><br><span class=\"line\">        root-&gt;_right = _CreateTree(a, invalid, ++index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造函数利用递归的思想，先跟的次序创建二叉树。<strong>由于要利用到递归，就没有办法直接用构造函数来实现，因为在class之外是没有办法访问到_root的。所以通过一个函数，利用这个函数来实现递归的过程。</strong><br>构造出来的二叉树关系图：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803061638_7.png-480.jpg\" alt=\"二叉树\"></p>\n<h3 id=\"拷贝构造\"><a href=\"#拷贝构造\" class=\"headerlink\" title=\"拷贝构造\"></a>拷贝构造</h3><p>拷贝构造利用了一个<code>_CopyTree</code>函数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinaryTree(<span class=\"keyword\">const</span> BinaryTree&amp; tree)&#123;</span><br><span class=\"line\">    _root = _CopyTree(tree._root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Node* _CopyTree(Node* root)&#123;</span><br><span class=\"line\">    Node* node = root;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node)&#123;</span><br><span class=\"line\">        node = <span class=\"keyword\">new</span> Node(root-&gt;_data);</span><br><span class=\"line\">        node-&gt;_left = _CopyTree(root-&gt;_left);</span><br><span class=\"line\">        node-&gt;_right = _CopyTree(root-&gt;_right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>析构函数利用了一个<code>Destroy</code>函数<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//destructor</span></span><br><span class=\"line\">~BinaryTree()&#123;</span><br><span class=\"line\">    Destroy(_root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Destroy</span><span class=\"params\">(Node* root)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Destroy(root-&gt;_left);</span><br><span class=\"line\">    Destroy(root-&gt;_right);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"operator-赋值运算符的重载\"><a href=\"#operator-赋值运算符的重载\" class=\"headerlink\" title=\"operator=(赋值运算符的重载)\"></a>operator=(赋值运算符的重载)</h3><p>先调用析构函数的<code>Destroy</code>销毁当前二叉树，然后调用<code>_CopyTree</code>重新构造当前二叉树。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//operator=</span></span><br><span class=\"line\">BinaryTree&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> BinaryTree&lt;T&gt;&amp; tree)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> != &amp;tree)&#123;</span><br><span class=\"line\">        Destroy(_root);</span><br><span class=\"line\">        _root = _CopyTree(tree._root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//BinaryTree&lt;T&gt;&amp; operator=(BinaryTree&lt;T&gt; tree)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//if(this != &amp;tree)&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//swap(_root, tree._root);</span></span><br><span class=\"line\">        <span class=\"comment\">//return *this;</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>赋值运算符的重载有两种实现方式，第一种是传统写法，第二种是现代写法。传统写法就是销毁原来的空间，然后重新开辟新的空间。对内存的操作比较多。现代写法是利用拷贝构造的方式，<strong>在传值进来的时候，生成一份临时拷贝</strong>，然后交换当前二叉树和临时拷贝的根节点，返回根节点，同时利用临时拷贝的作用域，交换后的二叉树在出了当前函数之后被销毁。<strong>相当于借用了系统的拷贝机制和自动析构机制来实现赋值的过程。</strong></p>\n<h2 id=\"递归遍历\"><a href=\"#递归遍历\" class=\"headerlink\" title=\"递归遍历\"></a>递归遍历</h2><h3 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h3><p>先序遍历：<code>root left right</code><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PrevOrder</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrevOrder</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    _PrevOrder(_root);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> _PrevOrder(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        _PrevOrder(root-&gt;_left);</span><br><span class=\"line\">        _PrevOrder(root-&gt;_right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h3><p>中序遍历：<code>left root right</code><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//InOrder</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrder</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    _InOreder(_root);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> _InOreder(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root)&#123;</span><br><span class=\"line\">        _InOreder(root-&gt;_left);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        _InOreder(root-&gt;_right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h3><p>后序遍历：<code>left root right</code><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PostOrder</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PostOrder</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    _PostOrder(_root);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> _PostOrder(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root)&#123;</span><br><span class=\"line\">        _PostOrder(root-&gt;_left);</span><br><span class=\"line\">        _PostOrder(root-&gt;_right);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; root-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"非递归遍历\"><a href=\"#非递归遍历\" class=\"headerlink\" title=\"非递归遍历\"></a>非递归遍历</h2><p>之所以要出现非递归遍历，是因为递归遍历有一定的缺陷。比如：当二叉树是一颗父节点只有一个子节点的树，那么对堆栈的使用就很大，<strong>有可能出现堆栈使用太深而栈溢出的情况</strong>。为了避免这种情况的出现，有必要使用非递归遍历。<br><strong>非递归遍历利用栈来实现对之前的结点的存储</strong>，因为每一颗二叉树都有可能有左右子树，所以需要在访问单边的子树的时候，将结点保存下来，这样是为了之后可以返回去访问结点的另一边的子树。</p>\n<h3 id=\"层次遍历\"><a href=\"#层次遍历\" class=\"headerlink\" title=\"层次遍历\"></a>层次遍历</h3><p>层次遍历是一层一层的遍历结点的。它与之前三个的遍历方式都不一样。<strong>他利用的是队列，通过队列让父节点带动子节点。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//LevelOrder</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LevelOrder</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不能是T，要用到root-&gt;_left; root-&gt;_right;</span></span><br><span class=\"line\">    <span class=\"comment\">//不好是Node，结构体太大;</span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;Node*&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_root)&#123;</span><br><span class=\"line\">        q.push(_root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">            Node* top = q.front();</span><br><span class=\"line\">            <span class=\"comment\">//获取到队头之后，将当前结点pop</span></span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; top-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">            <span class=\"comment\">//如果左右子树存在，就入队列</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(top-&gt;_left)</span><br><span class=\"line\">                q.push(top-&gt;_left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(top-&gt;_right)</span><br><span class=\"line\">                q.push(top-&gt;_right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"先序遍历非递归\"><a href=\"#先序遍历非递归\" class=\"headerlink\" title=\"先序遍历非递归\"></a>先序遍历非递归</h3><p>根据先序遍历的特点，先输出当前结点，然后一路向左，访问完左边再返回访问上一个结点的右子树，这个就是子问题，利用上面一样的方法。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PrevOrderNonR</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrevOrderNonR</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//利用栈得以记录访问过的根，用来以后访问右子树</span></span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;Node*&gt; s;</span><br><span class=\"line\">    Node* cur = _root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur || !s.empty())&#123;</span><br><span class=\"line\">        <span class=\"comment\">//根据先根的次序，访问当前节点，并一路向左访问</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; cur-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">            s.push(cur);</span><br><span class=\"line\">            cur = cur-&gt;_left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node* top = s.top();</span><br><span class=\"line\">        <span class=\"comment\">//pop表示左子树已经访问完，接下来访问右子树</span></span><br><span class=\"line\">        s.pop();</span><br><span class=\"line\">        <span class=\"comment\">//右子树的访问是子问题</span></span><br><span class=\"line\">        cur = top-&gt;_right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"中序遍历非递归\"><a href=\"#中序遍历非递归\" class=\"headerlink\" title=\"中序遍历非递归\"></a>中序遍历非递归</h3><p>中序遍历和先序遍历唯一的不同就是先序遍历是访问当前结点就打印当前结点，中序遍历就是先走完左边，再回来获取结点，这个时候再输出。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//InOrderNonR</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrderNonR</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;Node*&gt; s;</span><br><span class=\"line\">    Node* cur = _root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur || !s.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur)&#123;</span><br><span class=\"line\">            s.push(cur);</span><br><span class=\"line\">            cur = cur-&gt;_left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node* top = s.top();</span><br><span class=\"line\">        s.pop();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; top-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        cur = top-&gt;_right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"后序遍历非递归\"><a href=\"#后序遍历非递归\" class=\"headerlink\" title=\"后序遍历非递归\"></a>后序遍历非递归</h3><p>后序遍历相比于之前的有一个转弯，看下图：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803061639_158.png-960.jpg\" alt=\"后序遍历非递归\"><br>所以为了区分这个点，先设立一个prev，prev指向当前结点cur的上一个结点。如果<code>prev == cur-&gt;_right</code>表示当前结点的右子树已经访问完成，那么就可以输出cur了。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PostOrderNonR</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PostOrderNonR</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;Node*&gt; s;</span><br><span class=\"line\">    Node* cur = _root;</span><br><span class=\"line\">    Node* prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur || !s.empty())&#123;</span><br><span class=\"line\">        <span class=\"comment\">//一路向左走到底</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur)&#123;</span><br><span class=\"line\">            s.push(cur);</span><br><span class=\"line\">            cur = cur-&gt;_left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node* top = s.top();</span><br><span class=\"line\">        <span class=\"comment\">//访问当前结点的两个条件</span></span><br><span class=\"line\">        <span class=\"comment\">//1、没有右子树</span></span><br><span class=\"line\">        <span class=\"comment\">//2、右子树已经访问完成</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(top-&gt;_right == <span class=\"literal\">NULL</span> || prev == top-&gt;_right)&#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">            <span class=\"comment\">//此时的top成为过去式，将top设置为prev</span></span><br><span class=\"line\">            prev = top;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; top-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//此时表示右子树还没有访问</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            cur = top-&gt;_right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"结点个数函数\"><a href=\"#结点个数函数\" class=\"headerlink\" title=\"结点个数函数\"></a>结点个数函数</h2><p>以下函数都利用了递归的思想。</p>\n<h3 id=\"统计结点个数函数Size\"><a href=\"#统计结点个数函数Size\" class=\"headerlink\" title=\"统计结点个数函数Size\"></a>统计结点个数函数Size</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Size</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> Size()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _Size(_root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">size_t</span> _Size(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _Size(root-&gt;_left) + _Size(root-&gt;_right) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"统计深度函数Depth\"><a href=\"#统计深度函数Depth\" class=\"headerlink\" title=\"统计深度函数Depth\"></a>统计深度函数Depth</h3><p>统计深度的时候，因为二叉树有左右子树，所以需要区分是左子树结点多还是右子树结点多。通过两个变量来记录，分别统计大小，然后再比较大小，大的是深度。<br>这里默认根节点是第一层<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Depth</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> Depth()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _Depth(_root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">size_t</span> _Depth(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> leftnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> rightnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//如果存在就接着往下递归</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root-&gt;_left)</span><br><span class=\"line\">        leftnum += _Depth(root-&gt;_left);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root-&gt;_right)</span><br><span class=\"line\">        rightnum += _Depth(root-&gt;_right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (leftnum &gt; rightnum ? leftnum : rightnum) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"统计叶子结点个数的函数LeafSize\"><a href=\"#统计叶子结点个数的函数LeafSize\" class=\"headerlink\" title=\"统计叶子结点个数的函数LeafSize\"></a>统计叶子结点个数的函数LeafSize</h3><p>叶子结点的统计是在当前结点都没有左右子树的时候返回个数1。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//LeafSize</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> LeafSize()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _LeafSize(_root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">size_t</span> _LeafSize(Node* root)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root-&gt;_left == <span class=\"literal\">NULL</span> &amp;&amp; root-&gt;_right == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _LeafSize(root-&gt;_left) + _LeafSize(root-&gt;_right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"计算第K层的结点个数函数GetKLevel\"><a href=\"#计算第K层的结点个数函数GetKLevel\" class=\"headerlink\" title=\"计算第K层的结点个数函数GetKLevel\"></a>计算第K层的结点个数函数GetKLevel</h3><p>这个函数可以<strong>通过子问题的思想</strong>来解决。比如：我要计算第三层，当指针在第一层的时候，是计算K=3；当指针在第二层的时候，是计算K=2；当指针在第三层的时候，是计算K=1的结点个数。所以只要当K=1的时候返回计算值1就好了。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GetKLevel</span></span><br><span class=\"line\"><span class=\"keyword\">size_t</span> GetKLevel(<span class=\"keyword\">size_t</span> K)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _GetKLevel(_root, K);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">size_t</span> _GetKLevel(Node* root, <span class=\"keyword\">size_t</span> K)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(K == <span class=\"number\">0</span> || root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(K == <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//不能使用--K，应该用K-1。</span></span><br><span class=\"line\">    <span class=\"comment\">//不能返回除了K=1的其他情况。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _GetKLevel(root-&gt;_left, K - <span class=\"number\">1</span>) + _GetKLevel(root-&gt;_right, K - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a1[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>,<span class=\"number\">4</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a2[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">'#'</span>,<span class=\"number\">3</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"string\">'#'</span>,<span class=\"number\">6</span>,<span class=\"string\">'#'</span>,<span class=\"number\">7</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>,<span class=\"number\">8</span>,<span class=\"string\">'#'</span>,<span class=\"string\">'#'</span>&#125;;</span><br><span class=\"line\">BinaryTree&lt;<span class=\"keyword\">int</span>&gt; tree(a1,<span class=\"string\">'#'</span>);</span><br><span class=\"line\">BinaryTree&lt;<span class=\"keyword\">int</span>&gt; tree1(a2, <span class=\"string\">'#'</span>);</span><br><span class=\"line\">BinaryTree&lt;<span class=\"keyword\">int</span>&gt; tree2(tree);</span><br><span class=\"line\">tree2 = tree1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.PrevOrder\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree.PrevOrder();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.InOrder\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree1.InOrder();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree2.PostOrder\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree2.PostOrder();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.LevelOrder\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree.LevelOrder();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.PrevOrderNonR\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree.PrevOrderNonR();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.InOrderNonR\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree1.InOrderNonR();</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree2.PostOrderNonR\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">tree2.PostOrderNonR();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.Size:\"</span> &lt;&lt; tree.Size() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.Depth:\"</span> &lt;&lt; tree.Depth() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.LeafSize:\"</span> &lt;&lt; tree.LeafSize() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree.GetKLevel(K=2):\"</span> &lt;&lt; tree.GetKLevel(<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.Size:\"</span> &lt;&lt; tree1.Size() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.Depth:\"</span> &lt;&lt; tree1.Depth() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.LeafSize:\"</span> &lt;&lt; tree1.LeafSize() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"tree1.GetKLevel(K=3):\"</span> &lt;&lt; tree1.GetKLevel(<span class=\"number\">3</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>截图如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803061640_12.png-960.jpg\" alt=\"测试\"><br>二叉树的实现，最重要的是要掌握子问题的思想，通过子问题的思想来解决左右子树，只需要一个递归就好了。</p>"},{"title":"复杂单链表的复制","date":"2018-01-31T06:54:57.000Z","_content":"## 题目:\n有一个单链表，该链表节点有两个指针，一个`_next`指向下一个节点，另一个`_random`指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。\n\n### 思路：\n1. 单链表的复制比较简单，但是`_random`不好处理，如果`_random`指向前面的节点，我们该如何处理。`_random`还有可能是指向NULL，这种情况也需要单独处理。\n<!--more-->\n2. 为了解决这个问题，我们可以用一个比较巧妙的方法，对每一个节点都复制，同时插入到当前节点的后面。这样我们就得到了一个重复的链表，此时有一个优势，新`_random`就是原来`_random`的后一个。我们就不需要在考虑往前寻找的问题了。只需要找到当前节点的`_random`的`_next`就行。\n3. 这样处理之后，我们就得到了一个新的链表，接着只需要进行拆分就好了。\n\n### 看图如下：\n创建了一个复杂链表\n![复杂链表](http://p3ax8ersb.bkt.clouddn.com/201801311509_357.png)\n\n进行对每一个节点的复制同时插入到原链表中\n![复制并插入](http://p3ax8ersb.bkt.clouddn.com/201801311511_432.png)\n\n### 给出节点的结构如下：\n```c++\n#define datatype int\n\ntypedef struct complexnode{\n    complexnode(datatype val){\n        _data = val;\n        _next = NULL;\n        _random = NULL;\n    }\n    datatype _data;\n    complexnode* _next;\n    complexnode* _random;\n}comnode;\n```\n\n### 实现代码如下：\n```c++\n//主函数\ncomnode* copy_complex_list( comnode* head ){\n    comnode* cur = head;\n    comnode* next = cur->_next;\n    if( cur == NULL )\n        return NULL;\n\n    //将每一个节点复制到当前节点的后面，并链入链表\n    while( cur ){\n        comnode* tmp = new comnode(cur->_data);\n        cur->_next = tmp;\n        tmp->_next = next;\n        cur = next;\n        //防止对NULL访问\n        if( cur )\n            next = cur->_next;\n    }\n    //将指针重置指向头结点\n    cur = head;\n    next = cur->_next;\n    //给新链入的节点置random\n    while( cur ){\n        //分类处理_random为NULL的情况\n        if( cur->_random )\n            next->_random = cur->_random->_next;\n        else\n            next->_random = NULL;\n        cur = next->_next;\n        if( cur )\n            next = cur->_next;\n    }\n\n    cur = head;\n    next = cur->_next;\n    comnode* result = next;\n    //拆分两个链表\n    while( cur ){\n        cur->_next = next->_next;\n        cur = cur->_next;\n        if( cur ){\n            next->_next = cur->_next;\n            next = next->_next;\n        }\n    }\n    return result;\n}\n//打印函数\nvoid print_random( comnode* head ){\n    comnode* cur = head;\n    cout << \"list:\";\n    while( cur ){\n        cout << cur->_data << \"->\";\n        cur = cur->_next;\n    }\n    cout << \"NULL\" << endl << \"random:\";\n    cur = head;\n    while( cur ){\n        if( cur->_random )\n            cout << cur->_random->_data << \" \";\n        else\n            cout << \"NULL\" << \" \";\n        cur = cur->_next;\n    }\n    cout << endl;\n}\n\nint main(){\n    comnode* head = new comnode(1);\n    comnode* n1 = new comnode(2);\n    comnode* n2 = new comnode(4);\n    comnode* n3 = new comnode(5);\n    comnode* n4 = new comnode(9);\n\n    head->_next = n1;\n    n1->_next = n2;\n    n2->_next = n3;\n    n3->_next = n4;\n    n4->_next = NULL;\n\n    head->_random = n2;\n    n1->_random = head;\n    n2->_random = n3;\n    n3->_random = NULL;\n    n4->_random = n4;\n\n    system( \"clear\" );\n    comnode* copy_list = copy_complex_list( head );\n    print_random(head);\n    cout << \"copy_list:\" << endl;\n    print_random(copy_list);\n\n    return 0;\n}\n```\n\n### 运行结果如下：\n同时打印了原来的链表和复制的链表\n![打印结果](http://p3ax8ersb.bkt.clouddn.com/201801311519_393.png)\n\n[CSDN上用C写的，同时也将各个部分功能进行了函数封装](http://blog.csdn.net/mac_timmy/article/details/78482792)\n","source":"_posts/复杂单链表的复制.md","raw":"---\ntitle: 复杂单链表的复制\ndate: 2018-01-31 14:54:57\ntags:\ncategories:\n    - \"practice\"\n    - \"C/C++\"\n---\n## 题目:\n有一个单链表，该链表节点有两个指针，一个`_next`指向下一个节点，另一个`_random`指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。\n\n### 思路：\n1. 单链表的复制比较简单，但是`_random`不好处理，如果`_random`指向前面的节点，我们该如何处理。`_random`还有可能是指向NULL，这种情况也需要单独处理。\n<!--more-->\n2. 为了解决这个问题，我们可以用一个比较巧妙的方法，对每一个节点都复制，同时插入到当前节点的后面。这样我们就得到了一个重复的链表，此时有一个优势，新`_random`就是原来`_random`的后一个。我们就不需要在考虑往前寻找的问题了。只需要找到当前节点的`_random`的`_next`就行。\n3. 这样处理之后，我们就得到了一个新的链表，接着只需要进行拆分就好了。\n\n### 看图如下：\n创建了一个复杂链表\n![复杂链表](http://p3ax8ersb.bkt.clouddn.com/201801311509_357.png)\n\n进行对每一个节点的复制同时插入到原链表中\n![复制并插入](http://p3ax8ersb.bkt.clouddn.com/201801311511_432.png)\n\n### 给出节点的结构如下：\n```c++\n#define datatype int\n\ntypedef struct complexnode{\n    complexnode(datatype val){\n        _data = val;\n        _next = NULL;\n        _random = NULL;\n    }\n    datatype _data;\n    complexnode* _next;\n    complexnode* _random;\n}comnode;\n```\n\n### 实现代码如下：\n```c++\n//主函数\ncomnode* copy_complex_list( comnode* head ){\n    comnode* cur = head;\n    comnode* next = cur->_next;\n    if( cur == NULL )\n        return NULL;\n\n    //将每一个节点复制到当前节点的后面，并链入链表\n    while( cur ){\n        comnode* tmp = new comnode(cur->_data);\n        cur->_next = tmp;\n        tmp->_next = next;\n        cur = next;\n        //防止对NULL访问\n        if( cur )\n            next = cur->_next;\n    }\n    //将指针重置指向头结点\n    cur = head;\n    next = cur->_next;\n    //给新链入的节点置random\n    while( cur ){\n        //分类处理_random为NULL的情况\n        if( cur->_random )\n            next->_random = cur->_random->_next;\n        else\n            next->_random = NULL;\n        cur = next->_next;\n        if( cur )\n            next = cur->_next;\n    }\n\n    cur = head;\n    next = cur->_next;\n    comnode* result = next;\n    //拆分两个链表\n    while( cur ){\n        cur->_next = next->_next;\n        cur = cur->_next;\n        if( cur ){\n            next->_next = cur->_next;\n            next = next->_next;\n        }\n    }\n    return result;\n}\n//打印函数\nvoid print_random( comnode* head ){\n    comnode* cur = head;\n    cout << \"list:\";\n    while( cur ){\n        cout << cur->_data << \"->\";\n        cur = cur->_next;\n    }\n    cout << \"NULL\" << endl << \"random:\";\n    cur = head;\n    while( cur ){\n        if( cur->_random )\n            cout << cur->_random->_data << \" \";\n        else\n            cout << \"NULL\" << \" \";\n        cur = cur->_next;\n    }\n    cout << endl;\n}\n\nint main(){\n    comnode* head = new comnode(1);\n    comnode* n1 = new comnode(2);\n    comnode* n2 = new comnode(4);\n    comnode* n3 = new comnode(5);\n    comnode* n4 = new comnode(9);\n\n    head->_next = n1;\n    n1->_next = n2;\n    n2->_next = n3;\n    n3->_next = n4;\n    n4->_next = NULL;\n\n    head->_random = n2;\n    n1->_random = head;\n    n2->_random = n3;\n    n3->_random = NULL;\n    n4->_random = n4;\n\n    system( \"clear\" );\n    comnode* copy_list = copy_complex_list( head );\n    print_random(head);\n    cout << \"copy_list:\" << endl;\n    print_random(copy_list);\n\n    return 0;\n}\n```\n\n### 运行结果如下：\n同时打印了原来的链表和复制的链表\n![打印结果](http://p3ax8ersb.bkt.clouddn.com/201801311519_393.png)\n\n[CSDN上用C写的，同时也将各个部分功能进行了函数封装](http://blog.csdn.net/mac_timmy/article/details/78482792)\n","slug":"复杂单链表的复制","published":1,"updated":"2018-02-08T06:19:39.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nr62001504d81ahbscve","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h2><p>有一个单链表，该链表节点有两个指针，一个<code>_next</code>指向下一个节点，另一个<code>_random</code>指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><ol>\n<li>单链表的复制比较简单，但是<code>_random</code>不好处理，如果<code>_random</code>指向前面的节点，我们该如何处理。<code>_random</code>还有可能是指向NULL，这种情况也需要单独处理。<a id=\"more\"></a></li>\n<li>为了解决这个问题，我们可以用一个比较巧妙的方法，对每一个节点都复制，同时插入到当前节点的后面。这样我们就得到了一个重复的链表，此时有一个优势，新<code>_random</code>就是原来<code>_random</code>的后一个。我们就不需要在考虑往前寻找的问题了。只需要找到当前节点的<code>_random</code>的<code>_next</code>就行。</li>\n<li>这样处理之后，我们就得到了一个新的链表，接着只需要进行拆分就好了。</li>\n</ol>\n<h3 id=\"看图如下：\"><a href=\"#看图如下：\" class=\"headerlink\" title=\"看图如下：\"></a>看图如下：</h3><p>创建了一个复杂链表<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801311509_357.png\" alt=\"复杂链表\"></p>\n<p>进行对每一个节点的复制同时插入到原链表中<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801311511_432.png\" alt=\"复制并插入\"></p>\n<h3 id=\"给出节点的结构如下：\"><a href=\"#给出节点的结构如下：\" class=\"headerlink\" title=\"给出节点的结构如下：\"></a>给出节点的结构如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> datatype int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">complexnode</span>&#123;</span></span><br><span class=\"line\">    complexnode(datatype val)&#123;</span><br><span class=\"line\">        _data = val;</span><br><span class=\"line\">        _next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        _random = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    datatype _data;</span><br><span class=\"line\">    complexnode* _next;</span><br><span class=\"line\">    complexnode* _random;</span><br><span class=\"line\">&#125;comnode;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现代码如下：\"><a href=\"#实现代码如下：\" class=\"headerlink\" title=\"实现代码如下：\"></a>实现代码如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//主函数</span></span><br><span class=\"line\"><span class=\"function\">comnode* <span class=\"title\">copy_complex_list</span><span class=\"params\">( comnode* head )</span></span>&#123;</span><br><span class=\"line\">    comnode* cur = head;</span><br><span class=\"line\">    comnode* next = cur-&gt;_next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( cur == <span class=\"literal\">NULL</span> )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将每一个节点复制到当前节点的后面，并链入链表</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur )&#123;</span><br><span class=\"line\">        comnode* tmp = <span class=\"keyword\">new</span> comnode(cur-&gt;_data);</span><br><span class=\"line\">        cur-&gt;_next = tmp;</span><br><span class=\"line\">        tmp-&gt;_next = next;</span><br><span class=\"line\">        cur = next;</span><br><span class=\"line\">        <span class=\"comment\">//防止对NULL访问</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( cur )</span><br><span class=\"line\">            next = cur-&gt;_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将指针重置指向头结点</span></span><br><span class=\"line\">    cur = head;</span><br><span class=\"line\">    next = cur-&gt;_next;</span><br><span class=\"line\">    <span class=\"comment\">//给新链入的节点置random</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur )&#123;</span><br><span class=\"line\">        <span class=\"comment\">//分类处理_random为NULL的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( cur-&gt;_random )</span><br><span class=\"line\">            next-&gt;_random = cur-&gt;_random-&gt;_next;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            next-&gt;_random = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        cur = next-&gt;_next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( cur )</span><br><span class=\"line\">            next = cur-&gt;_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cur = head;</span><br><span class=\"line\">    next = cur-&gt;_next;</span><br><span class=\"line\">    comnode* result = next;</span><br><span class=\"line\">    <span class=\"comment\">//拆分两个链表</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur )&#123;</span><br><span class=\"line\">        cur-&gt;_next = next-&gt;_next;</span><br><span class=\"line\">        cur = cur-&gt;_next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( cur )&#123;</span><br><span class=\"line\">            next-&gt;_next = cur-&gt;_next;</span><br><span class=\"line\">            next = next-&gt;_next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//打印函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_random</span><span class=\"params\">( comnode* head )</span></span>&#123;</span><br><span class=\"line\">    comnode* cur = head;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"list:\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; cur-&gt;_data &lt;&lt; <span class=\"string\">\"-&gt;\"</span>;</span><br><span class=\"line\">        cur = cur-&gt;_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"NULL\"</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"random:\"</span>;</span><br><span class=\"line\">    cur = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( cur-&gt;_random )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; cur-&gt;_random-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"NULL\"</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        cur = cur-&gt;_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    comnode* head = <span class=\"keyword\">new</span> comnode(<span class=\"number\">1</span>);</span><br><span class=\"line\">    comnode* n1 = <span class=\"keyword\">new</span> comnode(<span class=\"number\">2</span>);</span><br><span class=\"line\">    comnode* n2 = <span class=\"keyword\">new</span> comnode(<span class=\"number\">4</span>);</span><br><span class=\"line\">    comnode* n3 = <span class=\"keyword\">new</span> comnode(<span class=\"number\">5</span>);</span><br><span class=\"line\">    comnode* n4 = <span class=\"keyword\">new</span> comnode(<span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    head-&gt;_next = n1;</span><br><span class=\"line\">    n1-&gt;_next = n2;</span><br><span class=\"line\">    n2-&gt;_next = n3;</span><br><span class=\"line\">    n3-&gt;_next = n4;</span><br><span class=\"line\">    n4-&gt;_next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    head-&gt;_random = n2;</span><br><span class=\"line\">    n1-&gt;_random = head;</span><br><span class=\"line\">    n2-&gt;_random = n3;</span><br><span class=\"line\">    n3-&gt;_random = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    n4-&gt;_random = n4;</span><br><span class=\"line\"></span><br><span class=\"line\">    system( <span class=\"string\">\"clear\"</span> );</span><br><span class=\"line\">    comnode* copy_list = copy_complex_list( head );</span><br><span class=\"line\">    print_random(head);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copy_list:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    print_random(copy_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行结果如下：\"><a href=\"#运行结果如下：\" class=\"headerlink\" title=\"运行结果如下：\"></a>运行结果如下：</h3><p>同时打印了原来的链表和复制的链表<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801311519_393.png\" alt=\"打印结果\"></p>\n<p><a href=\"http://blog.csdn.net/mac_timmy/article/details/78482792\" target=\"_blank\" rel=\"noopener\">CSDN上用C写的，同时也将各个部分功能进行了函数封装</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目:\"></a>题目:</h2><p>有一个单链表，该链表节点有两个指针，一个<code>_next</code>指向下一个节点，另一个<code>_random</code>指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><ol>\n<li>单链表的复制比较简单，但是<code>_random</code>不好处理，如果<code>_random</code>指向前面的节点，我们该如何处理。<code>_random</code>还有可能是指向NULL，这种情况也需要单独处理。","more":"</li>\n<li>为了解决这个问题，我们可以用一个比较巧妙的方法，对每一个节点都复制，同时插入到当前节点的后面。这样我们就得到了一个重复的链表，此时有一个优势，新<code>_random</code>就是原来<code>_random</code>的后一个。我们就不需要在考虑往前寻找的问题了。只需要找到当前节点的<code>_random</code>的<code>_next</code>就行。</li>\n<li>这样处理之后，我们就得到了一个新的链表，接着只需要进行拆分就好了。</li>\n</ol>\n<h3 id=\"看图如下：\"><a href=\"#看图如下：\" class=\"headerlink\" title=\"看图如下：\"></a>看图如下：</h3><p>创建了一个复杂链表<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801311509_357.png\" alt=\"复杂链表\"></p>\n<p>进行对每一个节点的复制同时插入到原链表中<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801311511_432.png\" alt=\"复制并插入\"></p>\n<h3 id=\"给出节点的结构如下：\"><a href=\"#给出节点的结构如下：\" class=\"headerlink\" title=\"给出节点的结构如下：\"></a>给出节点的结构如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> datatype int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">complexnode</span>&#123;</span></span><br><span class=\"line\">    complexnode(datatype val)&#123;</span><br><span class=\"line\">        _data = val;</span><br><span class=\"line\">        _next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        _random = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    datatype _data;</span><br><span class=\"line\">    complexnode* _next;</span><br><span class=\"line\">    complexnode* _random;</span><br><span class=\"line\">&#125;comnode;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现代码如下：\"><a href=\"#实现代码如下：\" class=\"headerlink\" title=\"实现代码如下：\"></a>实现代码如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//主函数</span></span><br><span class=\"line\"><span class=\"function\">comnode* <span class=\"title\">copy_complex_list</span><span class=\"params\">( comnode* head )</span></span>&#123;</span><br><span class=\"line\">    comnode* cur = head;</span><br><span class=\"line\">    comnode* next = cur-&gt;_next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( cur == <span class=\"literal\">NULL</span> )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将每一个节点复制到当前节点的后面，并链入链表</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur )&#123;</span><br><span class=\"line\">        comnode* tmp = <span class=\"keyword\">new</span> comnode(cur-&gt;_data);</span><br><span class=\"line\">        cur-&gt;_next = tmp;</span><br><span class=\"line\">        tmp-&gt;_next = next;</span><br><span class=\"line\">        cur = next;</span><br><span class=\"line\">        <span class=\"comment\">//防止对NULL访问</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( cur )</span><br><span class=\"line\">            next = cur-&gt;_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将指针重置指向头结点</span></span><br><span class=\"line\">    cur = head;</span><br><span class=\"line\">    next = cur-&gt;_next;</span><br><span class=\"line\">    <span class=\"comment\">//给新链入的节点置random</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur )&#123;</span><br><span class=\"line\">        <span class=\"comment\">//分类处理_random为NULL的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( cur-&gt;_random )</span><br><span class=\"line\">            next-&gt;_random = cur-&gt;_random-&gt;_next;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            next-&gt;_random = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        cur = next-&gt;_next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( cur )</span><br><span class=\"line\">            next = cur-&gt;_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cur = head;</span><br><span class=\"line\">    next = cur-&gt;_next;</span><br><span class=\"line\">    comnode* result = next;</span><br><span class=\"line\">    <span class=\"comment\">//拆分两个链表</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur )&#123;</span><br><span class=\"line\">        cur-&gt;_next = next-&gt;_next;</span><br><span class=\"line\">        cur = cur-&gt;_next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( cur )&#123;</span><br><span class=\"line\">            next-&gt;_next = cur-&gt;_next;</span><br><span class=\"line\">            next = next-&gt;_next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//打印函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_random</span><span class=\"params\">( comnode* head )</span></span>&#123;</span><br><span class=\"line\">    comnode* cur = head;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"list:\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; cur-&gt;_data &lt;&lt; <span class=\"string\">\"-&gt;\"</span>;</span><br><span class=\"line\">        cur = cur-&gt;_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"NULL\"</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"random:\"</span>;</span><br><span class=\"line\">    cur = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( cur-&gt;_random )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; cur-&gt;_random-&gt;_data &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"NULL\"</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        cur = cur-&gt;_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    comnode* head = <span class=\"keyword\">new</span> comnode(<span class=\"number\">1</span>);</span><br><span class=\"line\">    comnode* n1 = <span class=\"keyword\">new</span> comnode(<span class=\"number\">2</span>);</span><br><span class=\"line\">    comnode* n2 = <span class=\"keyword\">new</span> comnode(<span class=\"number\">4</span>);</span><br><span class=\"line\">    comnode* n3 = <span class=\"keyword\">new</span> comnode(<span class=\"number\">5</span>);</span><br><span class=\"line\">    comnode* n4 = <span class=\"keyword\">new</span> comnode(<span class=\"number\">9</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    head-&gt;_next = n1;</span><br><span class=\"line\">    n1-&gt;_next = n2;</span><br><span class=\"line\">    n2-&gt;_next = n3;</span><br><span class=\"line\">    n3-&gt;_next = n4;</span><br><span class=\"line\">    n4-&gt;_next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    head-&gt;_random = n2;</span><br><span class=\"line\">    n1-&gt;_random = head;</span><br><span class=\"line\">    n2-&gt;_random = n3;</span><br><span class=\"line\">    n3-&gt;_random = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    n4-&gt;_random = n4;</span><br><span class=\"line\"></span><br><span class=\"line\">    system( <span class=\"string\">\"clear\"</span> );</span><br><span class=\"line\">    comnode* copy_list = copy_complex_list( head );</span><br><span class=\"line\">    print_random(head);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"copy_list:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    print_random(copy_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行结果如下：\"><a href=\"#运行结果如下：\" class=\"headerlink\" title=\"运行结果如下：\"></a>运行结果如下：</h3><p>同时打印了原来的链表和复制的链表<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801311519_393.png\" alt=\"打印结果\"></p>\n<p><a href=\"http://blog.csdn.net/mac_timmy/article/details/78482792\" target=\"_blank\" rel=\"noopener\">CSDN上用C写的，同时也将各个部分功能进行了函数封装</a></p>"},{"title":"模板的类型萃取","date":"2018-02-24T06:56:38.000Z","keywords":["C++","模板","类型萃取","TypeTraits"],"password":null,"_content":"**类型萃取，是C++中的一种编程技术。当我们希望对模板传递的不同类型进行不同的操作的时候，同时我们又不希望改变该模板的封装方式。我们可以通过这种技术，对传入的不同类型进行不同的原理操作。**\n### 特化\n要明白类型萃取，首先要知道模板中的特化。一般来说，我们的模板是通用类型的，但是如果有一些类型，我们希望有不同的操作方式，我们就可以通过特化的方式。例子如下：\n<!--more-->\n```c++\n#include <iostream>\n\nusing namespace std;\n\n//模板的一般版本\ntemplate <class T>\nclass number{\npublic:\n    void show(){\n        cout << \"number\" << endl;\n    }\n};\n//模板的int类型特化版本\ntemplate <>\nclass number<int>{\npublic:\n    void show(){\n        cout << \"int\" << endl;\n    }\n};\n\nint main(){\n    system(\"clear\");\n    number<int> numint;\n    numint.show();\n\n    number<float> numfloat;\n    numfloat.show();\n\n    number<char> numchar;\n    numchar.show();\n    return 0;\n}\n```\n只有int类型才会输出int，其它的就像是float和char类型输出的都是number\n![特化的输出](http://p3ax8ersb.bkt.clouddn.com/201802241550_647.png-480.jpg)\n特化的方式，其实是十分冗余的。如果我的number类有很多的封装，那么实现它的特化，就需要将这些封装重新实现一遍。这样的复用性就十分低。\n### 类型萃取TypeTraits\n关于类型萃取的知识，可以看看我的这篇读书笔记中的3.3和3.4\n[我的个人博客文章地址](http://jingxxn.cn/%E6%B5%85%E8%AF%BB%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0-3%E7%AB%A0.html)\n[我的CSDN博客文章地址](http://blog.csdn.net/mac_timmy/article/details/79291828)\n这里我进行一个对于自创类SeqList类(对STL中vector的模拟)的类型萃取举例，情景说明：这里我想要对模板类SeqList进行拷贝，涉及到一个问题。如果我的元素类型是string的话，我必须进行深拷贝，否则就会出现奔溃的情况，这是对内存的使用出现问题。当我的元素类型是int、float、char等平凡类型(即POD:plain old data，基本类型，这些类型的拷贝不会涉及到内存的使用异常)，我就可以使用浅拷贝，这样比起深拷贝提高了效率。\n这个时候，我通过在SeqList类中进行类型萃取，就可以实现两种不同的拷贝方式：\n```c++\n//定义两个空类\nstruct __TrueType{};\nstruct __FalseType{};\n\n//一般类型及特化(内嵌重定义IsPODType)\ntemplate<class T>\nstruct __TypeTraits{ typedef __FalseType IsPODType; };\n\ntemplate<>\nstruct __TypeTraits<int>{ typedef __TrueType IsPODType; };\n\n//实现功能函数(用__TrueType/__FalseType实现重载)\ntemplate <class T>\nT* __TypeCopy(T* dst, const T* src, size_t n, __TrueType){\n    //浅拷贝，调用memcpy\n    return (T*)memcpy(dst, src, n*sizeof(T));\n}\ntemplate <class T>\nT* __TypeCopy(T* dst, const T* src, size_t n, __FalseType){\n    //深拷贝，进行了 operator= 调用\n    for(size_t i = 0; i<n; ++i){\n        dst[i] = src[i];\n    }\n    return dst;\n}\n//对外接口(实现IsPODType的__TrueType和__FalseType的转换)\ntemplate <class T>\nT* TypeCopy(T* dst, const T* src, size_t n){\n    return __TypeCopy(dst, src, n, __TypeTraits<T>::IsPODType);\n}\n//调用\nint main(){\n    int a1[3] = {1, 2, 3};\n    int a2[2] = {0, 0, 0};\n\n    string s1[3] = {\"1\", \"2\", \"3\"};\n    string s2[3] = {\"0\", \"0\", \"0\"};\n\n    TypeCopy(a1, a2, 3);\n    TypeCopy(s1, s2, 3);\n\n    return 0;\n}\n```\n这样，当传入的参数是s1,s2的时候，`__TypeTraits`调用的是一般版本，`IsPODType`为`__FalseType`,这样`__TypeCopy`调用的是`__FalseType`的重载版本，进行深拷贝。当传入的参数是a1，a2的时候，调用的是`__TrueType`的重载版本，进行浅拷贝。这里只对int进行了特化，所以只有int可以调用`__TrueType`的版本。但是我们可以对float、double等PODType进行特化，这样就大大提高了代码的复用性。\n","source":"_posts/模板的类型萃取.md","raw":"---\ntitle: 模板的类型萃取\ndate: 2018-02-24 14:56:38\ntags:\ncategories:\n    - \"knowledge\"\n    - \"C/C++\"\nkeywords:\n    - \"C++\"\n    - \"模板\"\n    - \"类型萃取\"\n    - \"TypeTraits\"\npassword:\n---\n**类型萃取，是C++中的一种编程技术。当我们希望对模板传递的不同类型进行不同的操作的时候，同时我们又不希望改变该模板的封装方式。我们可以通过这种技术，对传入的不同类型进行不同的原理操作。**\n### 特化\n要明白类型萃取，首先要知道模板中的特化。一般来说，我们的模板是通用类型的，但是如果有一些类型，我们希望有不同的操作方式，我们就可以通过特化的方式。例子如下：\n<!--more-->\n```c++\n#include <iostream>\n\nusing namespace std;\n\n//模板的一般版本\ntemplate <class T>\nclass number{\npublic:\n    void show(){\n        cout << \"number\" << endl;\n    }\n};\n//模板的int类型特化版本\ntemplate <>\nclass number<int>{\npublic:\n    void show(){\n        cout << \"int\" << endl;\n    }\n};\n\nint main(){\n    system(\"clear\");\n    number<int> numint;\n    numint.show();\n\n    number<float> numfloat;\n    numfloat.show();\n\n    number<char> numchar;\n    numchar.show();\n    return 0;\n}\n```\n只有int类型才会输出int，其它的就像是float和char类型输出的都是number\n![特化的输出](http://p3ax8ersb.bkt.clouddn.com/201802241550_647.png-480.jpg)\n特化的方式，其实是十分冗余的。如果我的number类有很多的封装，那么实现它的特化，就需要将这些封装重新实现一遍。这样的复用性就十分低。\n### 类型萃取TypeTraits\n关于类型萃取的知识，可以看看我的这篇读书笔记中的3.3和3.4\n[我的个人博客文章地址](http://jingxxn.cn/%E6%B5%85%E8%AF%BB%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0-3%E7%AB%A0.html)\n[我的CSDN博客文章地址](http://blog.csdn.net/mac_timmy/article/details/79291828)\n这里我进行一个对于自创类SeqList类(对STL中vector的模拟)的类型萃取举例，情景说明：这里我想要对模板类SeqList进行拷贝，涉及到一个问题。如果我的元素类型是string的话，我必须进行深拷贝，否则就会出现奔溃的情况，这是对内存的使用出现问题。当我的元素类型是int、float、char等平凡类型(即POD:plain old data，基本类型，这些类型的拷贝不会涉及到内存的使用异常)，我就可以使用浅拷贝，这样比起深拷贝提高了效率。\n这个时候，我通过在SeqList类中进行类型萃取，就可以实现两种不同的拷贝方式：\n```c++\n//定义两个空类\nstruct __TrueType{};\nstruct __FalseType{};\n\n//一般类型及特化(内嵌重定义IsPODType)\ntemplate<class T>\nstruct __TypeTraits{ typedef __FalseType IsPODType; };\n\ntemplate<>\nstruct __TypeTraits<int>{ typedef __TrueType IsPODType; };\n\n//实现功能函数(用__TrueType/__FalseType实现重载)\ntemplate <class T>\nT* __TypeCopy(T* dst, const T* src, size_t n, __TrueType){\n    //浅拷贝，调用memcpy\n    return (T*)memcpy(dst, src, n*sizeof(T));\n}\ntemplate <class T>\nT* __TypeCopy(T* dst, const T* src, size_t n, __FalseType){\n    //深拷贝，进行了 operator= 调用\n    for(size_t i = 0; i<n; ++i){\n        dst[i] = src[i];\n    }\n    return dst;\n}\n//对外接口(实现IsPODType的__TrueType和__FalseType的转换)\ntemplate <class T>\nT* TypeCopy(T* dst, const T* src, size_t n){\n    return __TypeCopy(dst, src, n, __TypeTraits<T>::IsPODType);\n}\n//调用\nint main(){\n    int a1[3] = {1, 2, 3};\n    int a2[2] = {0, 0, 0};\n\n    string s1[3] = {\"1\", \"2\", \"3\"};\n    string s2[3] = {\"0\", \"0\", \"0\"};\n\n    TypeCopy(a1, a2, 3);\n    TypeCopy(s1, s2, 3);\n\n    return 0;\n}\n```\n这样，当传入的参数是s1,s2的时候，`__TypeTraits`调用的是一般版本，`IsPODType`为`__FalseType`,这样`__TypeCopy`调用的是`__FalseType`的重载版本，进行深拷贝。当传入的参数是a1，a2的时候，调用的是`__TrueType`的重载版本，进行浅拷贝。这里只对int进行了特化，所以只有int可以调用`__TrueType`的版本。但是我们可以对float、double等PODType进行特化，这样就大大提高了代码的复用性。\n","slug":"模板的类型萃取","published":1,"updated":"2018-02-24T09:30:16.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nr65001704d8nf66ss4n","content":"<p><strong>类型萃取，是C++中的一种编程技术。当我们希望对模板传递的不同类型进行不同的操作的时候，同时我们又不希望改变该模板的封装方式。我们可以通过这种技术，对传入的不同类型进行不同的原理操作。</strong></p>\n<h3 id=\"特化\"><a href=\"#特化\" class=\"headerlink\" title=\"特化\"></a>特化</h3><p>要明白类型萃取，首先要知道模板中的特化。一般来说，我们的模板是通用类型的，但是如果有一些类型，我们希望有不同的操作方式，我们就可以通过特化的方式。例子如下：<br><a id=\"more\"></a><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//模板的一般版本</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">number</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"number\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//模板的int类型特化版本</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">number</span>&lt;int&gt;&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"int\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    system(<span class=\"string\">\"clear\"</span>);</span><br><span class=\"line\">    number&lt;<span class=\"keyword\">int</span>&gt; numint;</span><br><span class=\"line\">    numint.show();</span><br><span class=\"line\"></span><br><span class=\"line\">    number&lt;<span class=\"keyword\">float</span>&gt; numfloat;</span><br><span class=\"line\">    numfloat.show();</span><br><span class=\"line\"></span><br><span class=\"line\">    number&lt;<span class=\"keyword\">char</span>&gt; numchar;</span><br><span class=\"line\">    numchar.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只有int类型才会输出int，其它的就像是float和char类型输出的都是number<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802241550_647.png-480.jpg\" alt=\"特化的输出\"><br>特化的方式，其实是十分冗余的。如果我的number类有很多的封装，那么实现它的特化，就需要将这些封装重新实现一遍。这样的复用性就十分低。</p>\n<h3 id=\"类型萃取TypeTraits\"><a href=\"#类型萃取TypeTraits\" class=\"headerlink\" title=\"类型萃取TypeTraits\"></a>类型萃取TypeTraits</h3><p>关于类型萃取的知识，可以看看我的这篇读书笔记中的3.3和3.4<br><a href=\"http://jingxxn.cn/%E6%B5%85%E8%AF%BB%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0-3%E7%AB%A0.html\" target=\"_blank\" rel=\"noopener\">我的个人博客文章地址</a><br><a href=\"http://blog.csdn.net/mac_timmy/article/details/79291828\" target=\"_blank\" rel=\"noopener\">我的CSDN博客文章地址</a><br>这里我进行一个对于自创类SeqList类(对STL中vector的模拟)的类型萃取举例，情景说明：这里我想要对模板类SeqList进行拷贝，涉及到一个问题。如果我的元素类型是string的话，我必须进行深拷贝，否则就会出现奔溃的情况，这是对内存的使用出现问题。当我的元素类型是int、float、char等平凡类型(即POD:plain old data，基本类型，这些类型的拷贝不会涉及到内存的使用异常)，我就可以使用浅拷贝，这样比起深拷贝提高了效率。<br>这个时候，我通过在SeqList类中进行类型萃取，就可以实现两种不同的拷贝方式：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义两个空类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">TrueType</span>&#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">FalseType</span>&#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一般类型及特化(内嵌重定义IsPODType)</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> __<span class=\"title\">TypeTraits</span>&#123;</span> <span class=\"keyword\">typedef</span> __FalseType IsPODType; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">TypeTraits</span>&lt;int&gt;&#123;</span> <span class=\"keyword\">typedef</span> __TrueType IsPODType; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现功能函数(用__TrueType/__FalseType实现重载)</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span>* __<span class=\"title\">TypeCopy</span>(<span class=\"title\">T</span>* <span class=\"title\">dst</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>* <span class=\"title\">src</span>, <span class=\"title\">size_t</span> <span class=\"title\">n</span>, __<span class=\"title\">TrueType</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，调用memcpy</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T*)<span class=\"built_in\">memcpy</span>(dst, src, n*<span class=\"keyword\">sizeof</span>(T));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span>* __<span class=\"title\">TypeCopy</span>(<span class=\"title\">T</span>* <span class=\"title\">dst</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>* <span class=\"title\">src</span>, <span class=\"title\">size_t</span> <span class=\"title\">n</span>, __<span class=\"title\">FalseType</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//深拷贝，进行了 operator= 调用</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">        dst[i] = src[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dst;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外接口(实现IsPODType的__TrueType和__FalseType的转换)</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span>* <span class=\"title\">TypeCopy</span>(<span class=\"title\">T</span>* <span class=\"title\">dst</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>* <span class=\"title\">src</span>, <span class=\"title\">size_t</span> <span class=\"title\">n</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> __TypeCopy(dst, src, n, __TypeTraits&lt;T&gt;::IsPODType);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a1[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a2[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> s1[<span class=\"number\">3</span>] = &#123;<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s2[<span class=\"number\">3</span>] = &#123;<span class=\"string\">\"0\"</span>, <span class=\"string\">\"0\"</span>, <span class=\"string\">\"0\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    TypeCopy(a1, a2, <span class=\"number\">3</span>);</span><br><span class=\"line\">    TypeCopy(s1, s2, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，当传入的参数是s1,s2的时候，<code>__TypeTraits</code>调用的是一般版本，<code>IsPODType</code>为<code>__FalseType</code>,这样<code>__TypeCopy</code>调用的是<code>__FalseType</code>的重载版本，进行深拷贝。当传入的参数是a1，a2的时候，调用的是<code>__TrueType</code>的重载版本，进行浅拷贝。这里只对int进行了特化，所以只有int可以调用<code>__TrueType</code>的版本。但是我们可以对float、double等PODType进行特化，这样就大大提高了代码的复用性。</p>\n","site":{"data":{}},"excerpt":"<p><strong>类型萃取，是C++中的一种编程技术。当我们希望对模板传递的不同类型进行不同的操作的时候，同时我们又不希望改变该模板的封装方式。我们可以通过这种技术，对传入的不同类型进行不同的原理操作。</strong></p>\n<h3 id=\"特化\"><a href=\"#特化\" class=\"headerlink\" title=\"特化\"></a>特化</h3><p>要明白类型萃取，首先要知道模板中的特化。一般来说，我们的模板是通用类型的，但是如果有一些类型，我们希望有不同的操作方式，我们就可以通过特化的方式。例子如下：<br>","more":"<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//模板的一般版本</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">number</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"number\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//模板的int类型特化版本</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">number</span>&lt;int&gt;&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"int\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    system(<span class=\"string\">\"clear\"</span>);</span><br><span class=\"line\">    number&lt;<span class=\"keyword\">int</span>&gt; numint;</span><br><span class=\"line\">    numint.show();</span><br><span class=\"line\"></span><br><span class=\"line\">    number&lt;<span class=\"keyword\">float</span>&gt; numfloat;</span><br><span class=\"line\">    numfloat.show();</span><br><span class=\"line\"></span><br><span class=\"line\">    number&lt;<span class=\"keyword\">char</span>&gt; numchar;</span><br><span class=\"line\">    numchar.show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只有int类型才会输出int，其它的就像是float和char类型输出的都是number<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802241550_647.png-480.jpg\" alt=\"特化的输出\"><br>特化的方式，其实是十分冗余的。如果我的number类有很多的封装，那么实现它的特化，就需要将这些封装重新实现一遍。这样的复用性就十分低。</p>\n<h3 id=\"类型萃取TypeTraits\"><a href=\"#类型萃取TypeTraits\" class=\"headerlink\" title=\"类型萃取TypeTraits\"></a>类型萃取TypeTraits</h3><p>关于类型萃取的知识，可以看看我的这篇读书笔记中的3.3和3.4<br><a href=\"http://jingxxn.cn/%E6%B5%85%E8%AF%BB%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0-3%E7%AB%A0.html\" target=\"_blank\" rel=\"noopener\">我的个人博客文章地址</a><br><a href=\"http://blog.csdn.net/mac_timmy/article/details/79291828\" target=\"_blank\" rel=\"noopener\">我的CSDN博客文章地址</a><br>这里我进行一个对于自创类SeqList类(对STL中vector的模拟)的类型萃取举例，情景说明：这里我想要对模板类SeqList进行拷贝，涉及到一个问题。如果我的元素类型是string的话，我必须进行深拷贝，否则就会出现奔溃的情况，这是对内存的使用出现问题。当我的元素类型是int、float、char等平凡类型(即POD:plain old data，基本类型，这些类型的拷贝不会涉及到内存的使用异常)，我就可以使用浅拷贝，这样比起深拷贝提高了效率。<br>这个时候，我通过在SeqList类中进行类型萃取，就可以实现两种不同的拷贝方式：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义两个空类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">TrueType</span>&#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">FalseType</span>&#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一般类型及特化(内嵌重定义IsPODType)</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> __<span class=\"title\">TypeTraits</span>&#123;</span> <span class=\"keyword\">typedef</span> __FalseType IsPODType; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">TypeTraits</span>&lt;int&gt;&#123;</span> <span class=\"keyword\">typedef</span> __TrueType IsPODType; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现功能函数(用__TrueType/__FalseType实现重载)</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span>* __<span class=\"title\">TypeCopy</span>(<span class=\"title\">T</span>* <span class=\"title\">dst</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>* <span class=\"title\">src</span>, <span class=\"title\">size_t</span> <span class=\"title\">n</span>, __<span class=\"title\">TrueType</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//浅拷贝，调用memcpy</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T*)<span class=\"built_in\">memcpy</span>(dst, src, n*<span class=\"keyword\">sizeof</span>(T));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span>* __<span class=\"title\">TypeCopy</span>(<span class=\"title\">T</span>* <span class=\"title\">dst</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>* <span class=\"title\">src</span>, <span class=\"title\">size_t</span> <span class=\"title\">n</span>, __<span class=\"title\">FalseType</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//深拷贝，进行了 operator= 调用</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">        dst[i] = src[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dst;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外接口(实现IsPODType的__TrueType和__FalseType的转换)</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">T</span>* <span class=\"title\">TypeCopy</span>(<span class=\"title\">T</span>* <span class=\"title\">dst</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>* <span class=\"title\">src</span>, <span class=\"title\">size_t</span> <span class=\"title\">n</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> __TypeCopy(dst, src, n, __TypeTraits&lt;T&gt;::IsPODType);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a1[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a2[<span class=\"number\">2</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> s1[<span class=\"number\">3</span>] = &#123;<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s2[<span class=\"number\">3</span>] = &#123;<span class=\"string\">\"0\"</span>, <span class=\"string\">\"0\"</span>, <span class=\"string\">\"0\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    TypeCopy(a1, a2, <span class=\"number\">3</span>);</span><br><span class=\"line\">    TypeCopy(s1, s2, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，当传入的参数是s1,s2的时候，<code>__TypeTraits</code>调用的是一般版本，<code>IsPODType</code>为<code>__FalseType</code>,这样<code>__TypeCopy</code>调用的是<code>__FalseType</code>的重载版本，进行深拷贝。当传入的参数是a1，a2的时候，调用的是<code>__TrueType</code>的重载版本，进行浅拷贝。这里只对int进行了特化，所以只有int可以调用<code>__TrueType</code>的版本。但是我们可以对float、double等PODType进行特化，这样就大大提高了代码的复用性。</p>"},{"title":"查看Linux系统版本信息","date":"2018-03-08T03:44:55.000Z","keywords":["Linux","version"],"password":null,"_content":"#### 查看内核版本\n> **cat /proc/version**\n\n![cat /proc/version](http://p3ax8ersb.bkt.clouddn.com/201803081150_955.png-960.jpg)\n> **uname -a**\n\n<!--more-->\n![uname -a](http://p3ax8ersb.bkt.clouddn.com/201803081151_552.png-960.jpg)\n#### 查看系统版本\n> **cat /etc/redhat-release**\n\n![查看版本](http://p3ax8ersb.bkt.clouddn.com/201803081158_576.png-960.jpg)\n> **lsb_release -a**\n\n这个命令需要安装，安装命令：\n> yum install lsb -y\n\n![lsb_release](http://p3ax8ersb.bkt.clouddn.com/201803081233_128.png-960.jpg)\n> **cat /etc/issue**\n\n都说可以，这个我的查出来很奇怪\n![有错误](http://p3ax8ersb.bkt.clouddn.com/201803081223_694.png-960.jpg)\n> **rpm -q centos-release**\n\n![rpm](http://p3ax8ersb.bkt.clouddn.com/201803081235_126.png-960.jpg)\n\n#### 查看cpu相关信息，包括型号、主频、内核等信息\n> **cat /proc/cpuinfo**\n\n![cpuinfo](http://p3ax8ersb.bkt.clouddn.com/201803081226_578.png-960.jpg)\n\n[参考地址1](https://www.linuxidc.com/Linux/2016-05/131749.htm)\n[参考地址2](http://blog.csdn.net/Aoril/article/details/53518917)","source":"_posts/查看Linux系统版本信息.md","raw":"---\ntitle: 查看Linux系统版本信息\ndate: 2018-03-08 11:44:55\ntags:\ncategories:\n    - \"Linux\"\n    - \"method\"\nkeywords:\n    - \"Linux\"\n    - \"version\"\npassword:\n---\n#### 查看内核版本\n> **cat /proc/version**\n\n![cat /proc/version](http://p3ax8ersb.bkt.clouddn.com/201803081150_955.png-960.jpg)\n> **uname -a**\n\n<!--more-->\n![uname -a](http://p3ax8ersb.bkt.clouddn.com/201803081151_552.png-960.jpg)\n#### 查看系统版本\n> **cat /etc/redhat-release**\n\n![查看版本](http://p3ax8ersb.bkt.clouddn.com/201803081158_576.png-960.jpg)\n> **lsb_release -a**\n\n这个命令需要安装，安装命令：\n> yum install lsb -y\n\n![lsb_release](http://p3ax8ersb.bkt.clouddn.com/201803081233_128.png-960.jpg)\n> **cat /etc/issue**\n\n都说可以，这个我的查出来很奇怪\n![有错误](http://p3ax8ersb.bkt.clouddn.com/201803081223_694.png-960.jpg)\n> **rpm -q centos-release**\n\n![rpm](http://p3ax8ersb.bkt.clouddn.com/201803081235_126.png-960.jpg)\n\n#### 查看cpu相关信息，包括型号、主频、内核等信息\n> **cat /proc/cpuinfo**\n\n![cpuinfo](http://p3ax8ersb.bkt.clouddn.com/201803081226_578.png-960.jpg)\n\n[参考地址1](https://www.linuxidc.com/Linux/2016-05/131749.htm)\n[参考地址2](http://blog.csdn.net/Aoril/article/details/53518917)","slug":"查看Linux系统版本信息","published":1,"updated":"2018-03-08T08:32:20.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nr67001804d8dk701zbf","content":"<h4 id=\"查看内核版本\"><a href=\"#查看内核版本\" class=\"headerlink\" title=\"查看内核版本\"></a>查看内核版本</h4><blockquote>\n<p><strong>cat /proc/version</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081150_955.png-960.jpg\" alt=\"cat /proc/version\"></p>\n<blockquote>\n<p><strong>uname -a</strong></p>\n</blockquote>\n<a id=\"more\"></a>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081151_552.png-960.jpg\" alt=\"uname -a\"></p>\n<h4 id=\"查看系统版本\"><a href=\"#查看系统版本\" class=\"headerlink\" title=\"查看系统版本\"></a>查看系统版本</h4><blockquote>\n<p><strong>cat /etc/redhat-release</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081158_576.png-960.jpg\" alt=\"查看版本\"></p>\n<blockquote>\n<p><strong>lsb_release -a</strong></p>\n</blockquote>\n<p>这个命令需要安装，安装命令：</p>\n<blockquote>\n<p>yum install lsb -y</p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081233_128.png-960.jpg\" alt=\"lsb_release\"></p>\n<blockquote>\n<p><strong>cat /etc/issue</strong></p>\n</blockquote>\n<p>都说可以，这个我的查出来很奇怪<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081223_694.png-960.jpg\" alt=\"有错误\"></p>\n<blockquote>\n<p><strong>rpm -q centos-release</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081235_126.png-960.jpg\" alt=\"rpm\"></p>\n<h4 id=\"查看cpu相关信息，包括型号、主频、内核等信息\"><a href=\"#查看cpu相关信息，包括型号、主频、内核等信息\" class=\"headerlink\" title=\"查看cpu相关信息，包括型号、主频、内核等信息\"></a>查看cpu相关信息，包括型号、主频、内核等信息</h4><blockquote>\n<p><strong>cat /proc/cpuinfo</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081226_578.png-960.jpg\" alt=\"cpuinfo\"></p>\n<p><a href=\"https://www.linuxidc.com/Linux/2016-05/131749.htm\" target=\"_blank\" rel=\"noopener\">参考地址1</a><br><a href=\"http://blog.csdn.net/Aoril/article/details/53518917\" target=\"_blank\" rel=\"noopener\">参考地址2</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"查看内核版本\"><a href=\"#查看内核版本\" class=\"headerlink\" title=\"查看内核版本\"></a>查看内核版本</h4><blockquote>\n<p><strong>cat /proc/version</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081150_955.png-960.jpg\" alt=\"cat /proc/version\"></p>\n<blockquote>\n<p><strong>uname -a</strong></p>\n</blockquote>","more":"<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081151_552.png-960.jpg\" alt=\"uname -a\"></p>\n<h4 id=\"查看系统版本\"><a href=\"#查看系统版本\" class=\"headerlink\" title=\"查看系统版本\"></a>查看系统版本</h4><blockquote>\n<p><strong>cat /etc/redhat-release</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081158_576.png-960.jpg\" alt=\"查看版本\"></p>\n<blockquote>\n<p><strong>lsb_release -a</strong></p>\n</blockquote>\n<p>这个命令需要安装，安装命令：</p>\n<blockquote>\n<p>yum install lsb -y</p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081233_128.png-960.jpg\" alt=\"lsb_release\"></p>\n<blockquote>\n<p><strong>cat /etc/issue</strong></p>\n</blockquote>\n<p>都说可以，这个我的查出来很奇怪<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081223_694.png-960.jpg\" alt=\"有错误\"></p>\n<blockquote>\n<p><strong>rpm -q centos-release</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081235_126.png-960.jpg\" alt=\"rpm\"></p>\n<h4 id=\"查看cpu相关信息，包括型号、主频、内核等信息\"><a href=\"#查看cpu相关信息，包括型号、主频、内核等信息\" class=\"headerlink\" title=\"查看cpu相关信息，包括型号、主频、内核等信息\"></a>查看cpu相关信息，包括型号、主频、内核等信息</h4><blockquote>\n<p><strong>cat /proc/cpuinfo</strong></p>\n</blockquote>\n<p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201803081226_578.png-960.jpg\" alt=\"cpuinfo\"></p>\n<p><a href=\"https://www.linuxidc.com/Linux/2016-05/131749.htm\" target=\"_blank\" rel=\"noopener\">参考地址1</a><br><a href=\"http://blog.csdn.net/Aoril/article/details/53518917\" target=\"_blank\" rel=\"noopener\">参考地址2</a></p>"},{"title":"智能指针","date":"2018-02-25T01:28:08.000Z","keywords":["C++","smartpointer","智能指针"],"password":null,"_content":"智能指针是C++中一个编程技巧。它保证内存的正确释放，解决了内存泄漏的问题。有一个思想叫做RAII，**RAII指的是资源分配即初始化。我们通常会定义一个类来封装资源的分配和释放，在构造函数中完成资源的分配和初始化，在析构函数中完成资源的清理。**\n在C++中，我们一般是使用new和delete来实现内存的初始化和释放。正确的配对使用可以处理绝大部分问题，但是如果出现了执行流的跳转，比如：语句中间出现了return，break，continue，goto，等关键字，我们的delete可能没有执行，这样就导致了内存没有被释放。又或者我们的语句出现了错误，抛出异常导致程序结束，也有可能没有执行delete语句。这 **些问题都导致了内存泄漏。智能指针的出现就是为了解决这些问题的。智能指针其实是一个类，它可以自动的处理指针指向的动态资源的释放。**\n### 发展历程<!--more-->\n- 早期C++98：auto_ptr，最早出现的智能指针，拷贝机制是管理权转移，致命缺陷，不使用。\n- boost(非官方)：\n    1. scoped_ptr/scoped_array：守卫指针，拷贝机制是不拷贝，简单粗暴\n    2. **shared_ptr/shared_array：共享指针，拷贝机制是引用计数，比较复杂，会出现循环引用的问题。**\n    3. **weak_ptr：弱指针，不单独使用，辅助共享指针解决循环引用的问题**\n- C++11：unique_ptr对应boost的scoped_ptr；shared_ptr对应boost的shared_ptr；weak_ptr对应boost的weak_ptr。\n\n本文主要实现shared_ptr和weak_ptr的模拟，auto_ptr和scoped_ptr模拟拷贝相关的函数。\n### auto_ptr\n\n```c++\n//模拟主要函数：\ntemplate <class T>\nclass AutoPtr{\nprivate:\n    T* _ptr;\npublic:\n    AutoPtr(T* ptr){ _ptr = ptr; }\n    ~AutoPtr(){ delete _ptr; }\n    T& operator*(){ return *_ptr; }\n    T* operator->(){ return _ptr; }\n\n    AutoPtr(AutoPtr<T>& ap){\n        //管理权转移\n        _ptr = ap._ptr;\n        ap._ptr = NULL;\n    }\n    AutoPtr<T>& operator=(AutoPtr<T>& ap){\n        //自己给自己赋值不作处理\n        if(this != &ap){\n            if(_ptr)\n                delete _ptr;\n            //管理权转移\n            _ptr = ap._ptr;\n            ap_ptr = NULL;\n        }\n        return *this;\n    }\n};\n\nint main(){\n    AutoPtr<int> ap1(new int(10));\n    AutoPtr<int>ap2 = ap1;\n    //崩溃，因为ap1已经指向NULL\n    *ap1 = 20;\n    return 0;\n}\n```\n图解如下：\n![AutoPtr](http://p3ax8ersb.bkt.clouddn.com/201802251035_295.png-960.jpg)\n**任何时候我们都不使用auto_ptr，因为管理权的转移是不符合我们正常指针的使用的，而且会引起程序崩溃，这个是不允许的。**\n最后，解释一下，`operator->()`返回`T*`的原因：\n```c++\n//设定一个类\nstruct student{ int num; }\n//调用\nAutoPtr<student> sp = new student;\nsp->num = 20;\n```\n`sp->num`等价于`sp.operator->()`。`sp.operaotr->()`返回`T*`指针之后，编译器自动将原式优化为`_ptr->num`,从而实现对元素的访问。\n### scoped_ptr\n防拷贝的智能指针，boost版本相当于C++11的unique_ptr\n```c++\n//模拟拷贝的主要函数：\ntemplate <class T>\nclass ScopedPtr{\nprivate:\n    //与AutoPtr不同的就是这两个函数\n    ScopedPtr(const ScopedPtr<T>& sp);\n    ScopedPtr<T>& operator= (const ScopedPtr<T>& sp);\n};\n```\n**scoped_ptr通过将拷贝构造函数和赋值运算符重载定义为私有，同时只声明不定义，这样可以保证该类不能被拷贝。**这就简单的解决了auto_ptr因为拷贝导致的管理权转移问题。\n### shared_ptr\n**引用计数的智能指针，这个类除了有指针之外，再多开辟了一个内存空间，用于存放计数。**这种智能指针是实现的最好的，在boost库中，实现起来很复杂，因为要考虑多线程等情况。\n```c++\n//模拟主要函数\ntemplate <class T>\nclass SharedPtr{\nprivate:\n    T* _ptr;\n    int* _refcount;\npublic:\n    //构造\n    SharedPtr(const T& ptr){\n        _ptr = ptr;\n        _refcount = new int(1);\n    }\n    //析构\n    ~SharedPtr(){\n        if(--_refcount == 0){\n            delete _ptr;\n            delete _refcount;\n        }\n    }\n    //拷贝构造\n    SharedPtr(SharedPtr<T>& sp){\n        _ptr = sp._ptr;\n        _refcount = sp._refcount;\n        ++_refcount;\n    }\n    //赋值运算符重载\n    SharedPtr<T>& operator=(const SharedPtr<T>& sp){\n        if(*this != &sp){\n            if(--(*_refcount) == 0){\n                delete _ptr;\n                delete _refcount;\n            }\n            _ptr = sp._ptr;\n            _refcount = sp._refcount;\n            (*_refcount)++;\n        }\n        return *this;\n    }\n    //*重载\n    T& operator*(){ return *_ptr; }\n    //->重载\n    T* operator->(){ return _ptr; }\n};\n```\n这个实现，将是比较实用的。但是依然有一个场景下，会出现问题。这个问题叫做循环引用，问题的根源是引用计数被循环使用，不能减为0，导致死循环。下面以双向链表作为例子：\n```c++\n//定义一个链表节点如下\nstruct ListNode{\n\n    //构造函数...\n\n    //为了方便调用，设为public\n    int _data;\n    SharedPtr<ListNode> _next;\n    SharedPtr<ListNode> _prev;\n};\n//调用这个节点，设定这样一个场景\nint main(){\n    SharedPtr<ListNode> cur(new ListNode);\n    SharedPtr<ListNode> next(new ListNode);\n    cur->_next = next;\n    next->_prev = cur;\n}\n```\n创建模型如下：\n![循环引用](http://p3ax8ersb.bkt.clouddn.com/201802251655_141.png-480.jpg)\n根据上面例子，`_next`和`next`都指向后面节点这个空间，`next._refcount = 2`。`_prev`和`cur`指向前面那个节点的空间，`cur._refcount = 2`。当程序结束的时候，`next`先被析构。若需要析构`next`就需要析构`next._prev`;要析构`next._prev`就需要析构`cur`;要析构`cur`就需要析构`cur._next`;要析构`cur._next`就需要析构`next`……这样就造成了死循环。为了解决这个循环引用的问题，引入了弱指针weak_ptr。\n### weak_ptr\n**弱指针不单独使用，它的存在就是为了解决使用shared_ptr造成的循环引用问题。**\n```c++\ntemplate <class T>\nclass WeakPtr{\nprivate:\n    T* _ptr;\npublic:\n    WeakPtr(){\n        _ptr = NULL;\n    }\n    WeakPtr(const SharedPtr<T>& sp){\n        _ptr = sp._ptr;\n    }\n\n    T& operator*(){ return *_ptr; }\n    T* operator->(){ return _ptr; }\n\n    WeakPtr<T>& operator=(const SharedPtr<T>& sp){\n        _ptr = sp._ptr;\n        return *this;\n    }\n};\n//还需要修改一下两处：\n//1、修改ListNode的结构\nstruct ListNode{\n    int _data;\n    WeakPtr<ListNode> _next;\n    WeakPtr<ListNode> _prev;\n};\n\n//2、将WeakPtr定义为SharedPtr的友元，因为WeakPtr中需要访问SharedPtr的私有成员\ntemplate <class T>\nclass SharedPtr{\n    friend class WeakPtr;\n    //...\n};\n```\n这样，上面那个例子中，`next._refcount = 1`，`cur._refcount = 1`,就不会出现循环引用的问题了。","source":"_posts/智能指针.md","raw":"---\ntitle: 智能指针\ndate: 2018-02-25 09:28:08\ntags:\ncategories:\n    - \"knowledge\"\n    - \"C/C++\"\nkeywords:\n    - \"C++\"\n    - \"smartpointer\"\n    - \"智能指针\"\npassword:\n---\n智能指针是C++中一个编程技巧。它保证内存的正确释放，解决了内存泄漏的问题。有一个思想叫做RAII，**RAII指的是资源分配即初始化。我们通常会定义一个类来封装资源的分配和释放，在构造函数中完成资源的分配和初始化，在析构函数中完成资源的清理。**\n在C++中，我们一般是使用new和delete来实现内存的初始化和释放。正确的配对使用可以处理绝大部分问题，但是如果出现了执行流的跳转，比如：语句中间出现了return，break，continue，goto，等关键字，我们的delete可能没有执行，这样就导致了内存没有被释放。又或者我们的语句出现了错误，抛出异常导致程序结束，也有可能没有执行delete语句。这 **些问题都导致了内存泄漏。智能指针的出现就是为了解决这些问题的。智能指针其实是一个类，它可以自动的处理指针指向的动态资源的释放。**\n### 发展历程<!--more-->\n- 早期C++98：auto_ptr，最早出现的智能指针，拷贝机制是管理权转移，致命缺陷，不使用。\n- boost(非官方)：\n    1. scoped_ptr/scoped_array：守卫指针，拷贝机制是不拷贝，简单粗暴\n    2. **shared_ptr/shared_array：共享指针，拷贝机制是引用计数，比较复杂，会出现循环引用的问题。**\n    3. **weak_ptr：弱指针，不单独使用，辅助共享指针解决循环引用的问题**\n- C++11：unique_ptr对应boost的scoped_ptr；shared_ptr对应boost的shared_ptr；weak_ptr对应boost的weak_ptr。\n\n本文主要实现shared_ptr和weak_ptr的模拟，auto_ptr和scoped_ptr模拟拷贝相关的函数。\n### auto_ptr\n\n```c++\n//模拟主要函数：\ntemplate <class T>\nclass AutoPtr{\nprivate:\n    T* _ptr;\npublic:\n    AutoPtr(T* ptr){ _ptr = ptr; }\n    ~AutoPtr(){ delete _ptr; }\n    T& operator*(){ return *_ptr; }\n    T* operator->(){ return _ptr; }\n\n    AutoPtr(AutoPtr<T>& ap){\n        //管理权转移\n        _ptr = ap._ptr;\n        ap._ptr = NULL;\n    }\n    AutoPtr<T>& operator=(AutoPtr<T>& ap){\n        //自己给自己赋值不作处理\n        if(this != &ap){\n            if(_ptr)\n                delete _ptr;\n            //管理权转移\n            _ptr = ap._ptr;\n            ap_ptr = NULL;\n        }\n        return *this;\n    }\n};\n\nint main(){\n    AutoPtr<int> ap1(new int(10));\n    AutoPtr<int>ap2 = ap1;\n    //崩溃，因为ap1已经指向NULL\n    *ap1 = 20;\n    return 0;\n}\n```\n图解如下：\n![AutoPtr](http://p3ax8ersb.bkt.clouddn.com/201802251035_295.png-960.jpg)\n**任何时候我们都不使用auto_ptr，因为管理权的转移是不符合我们正常指针的使用的，而且会引起程序崩溃，这个是不允许的。**\n最后，解释一下，`operator->()`返回`T*`的原因：\n```c++\n//设定一个类\nstruct student{ int num; }\n//调用\nAutoPtr<student> sp = new student;\nsp->num = 20;\n```\n`sp->num`等价于`sp.operator->()`。`sp.operaotr->()`返回`T*`指针之后，编译器自动将原式优化为`_ptr->num`,从而实现对元素的访问。\n### scoped_ptr\n防拷贝的智能指针，boost版本相当于C++11的unique_ptr\n```c++\n//模拟拷贝的主要函数：\ntemplate <class T>\nclass ScopedPtr{\nprivate:\n    //与AutoPtr不同的就是这两个函数\n    ScopedPtr(const ScopedPtr<T>& sp);\n    ScopedPtr<T>& operator= (const ScopedPtr<T>& sp);\n};\n```\n**scoped_ptr通过将拷贝构造函数和赋值运算符重载定义为私有，同时只声明不定义，这样可以保证该类不能被拷贝。**这就简单的解决了auto_ptr因为拷贝导致的管理权转移问题。\n### shared_ptr\n**引用计数的智能指针，这个类除了有指针之外，再多开辟了一个内存空间，用于存放计数。**这种智能指针是实现的最好的，在boost库中，实现起来很复杂，因为要考虑多线程等情况。\n```c++\n//模拟主要函数\ntemplate <class T>\nclass SharedPtr{\nprivate:\n    T* _ptr;\n    int* _refcount;\npublic:\n    //构造\n    SharedPtr(const T& ptr){\n        _ptr = ptr;\n        _refcount = new int(1);\n    }\n    //析构\n    ~SharedPtr(){\n        if(--_refcount == 0){\n            delete _ptr;\n            delete _refcount;\n        }\n    }\n    //拷贝构造\n    SharedPtr(SharedPtr<T>& sp){\n        _ptr = sp._ptr;\n        _refcount = sp._refcount;\n        ++_refcount;\n    }\n    //赋值运算符重载\n    SharedPtr<T>& operator=(const SharedPtr<T>& sp){\n        if(*this != &sp){\n            if(--(*_refcount) == 0){\n                delete _ptr;\n                delete _refcount;\n            }\n            _ptr = sp._ptr;\n            _refcount = sp._refcount;\n            (*_refcount)++;\n        }\n        return *this;\n    }\n    //*重载\n    T& operator*(){ return *_ptr; }\n    //->重载\n    T* operator->(){ return _ptr; }\n};\n```\n这个实现，将是比较实用的。但是依然有一个场景下，会出现问题。这个问题叫做循环引用，问题的根源是引用计数被循环使用，不能减为0，导致死循环。下面以双向链表作为例子：\n```c++\n//定义一个链表节点如下\nstruct ListNode{\n\n    //构造函数...\n\n    //为了方便调用，设为public\n    int _data;\n    SharedPtr<ListNode> _next;\n    SharedPtr<ListNode> _prev;\n};\n//调用这个节点，设定这样一个场景\nint main(){\n    SharedPtr<ListNode> cur(new ListNode);\n    SharedPtr<ListNode> next(new ListNode);\n    cur->_next = next;\n    next->_prev = cur;\n}\n```\n创建模型如下：\n![循环引用](http://p3ax8ersb.bkt.clouddn.com/201802251655_141.png-480.jpg)\n根据上面例子，`_next`和`next`都指向后面节点这个空间，`next._refcount = 2`。`_prev`和`cur`指向前面那个节点的空间，`cur._refcount = 2`。当程序结束的时候，`next`先被析构。若需要析构`next`就需要析构`next._prev`;要析构`next._prev`就需要析构`cur`;要析构`cur`就需要析构`cur._next`;要析构`cur._next`就需要析构`next`……这样就造成了死循环。为了解决这个循环引用的问题，引入了弱指针weak_ptr。\n### weak_ptr\n**弱指针不单独使用，它的存在就是为了解决使用shared_ptr造成的循环引用问题。**\n```c++\ntemplate <class T>\nclass WeakPtr{\nprivate:\n    T* _ptr;\npublic:\n    WeakPtr(){\n        _ptr = NULL;\n    }\n    WeakPtr(const SharedPtr<T>& sp){\n        _ptr = sp._ptr;\n    }\n\n    T& operator*(){ return *_ptr; }\n    T* operator->(){ return _ptr; }\n\n    WeakPtr<T>& operator=(const SharedPtr<T>& sp){\n        _ptr = sp._ptr;\n        return *this;\n    }\n};\n//还需要修改一下两处：\n//1、修改ListNode的结构\nstruct ListNode{\n    int _data;\n    WeakPtr<ListNode> _next;\n    WeakPtr<ListNode> _prev;\n};\n\n//2、将WeakPtr定义为SharedPtr的友元，因为WeakPtr中需要访问SharedPtr的私有成员\ntemplate <class T>\nclass SharedPtr{\n    friend class WeakPtr;\n    //...\n};\n```\n这样，上面那个例子中，`next._refcount = 1`，`cur._refcount = 1`,就不会出现循环引用的问题了。","slug":"智能指针","published":1,"updated":"2018-02-26T07:50:16.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nr69001904d82bs90axi","content":"<p>智能指针是C++中一个编程技巧。它保证内存的正确释放，解决了内存泄漏的问题。有一个思想叫做RAII，<strong>RAII指的是资源分配即初始化。我们通常会定义一个类来封装资源的分配和释放，在构造函数中完成资源的分配和初始化，在析构函数中完成资源的清理。</strong><br>在C++中，我们一般是使用new和delete来实现内存的初始化和释放。正确的配对使用可以处理绝大部分问题，但是如果出现了执行流的跳转，比如：语句中间出现了return，break，continue，goto，等关键字，我们的delete可能没有执行，这样就导致了内存没有被释放。又或者我们的语句出现了错误，抛出异常导致程序结束，也有可能没有执行delete语句。这 <strong>些问题都导致了内存泄漏。智能指针的出现就是为了解决这些问题的。智能指针其实是一个类，它可以自动的处理指针指向的动态资源的释放。</strong></p>\n<h3 id=\"发展历程\"><a href=\"#发展历程\" class=\"headerlink\" title=\"发展历程\"></a>发展历程<a id=\"more\"></a></h3><ul>\n<li>早期C++98：auto_ptr，最早出现的智能指针，拷贝机制是管理权转移，致命缺陷，不使用。</li>\n<li>boost(非官方)：<ol>\n<li>scoped_ptr/scoped_array：守卫指针，拷贝机制是不拷贝，简单粗暴</li>\n<li><strong>shared_ptr/shared_array：共享指针，拷贝机制是引用计数，比较复杂，会出现循环引用的问题。</strong></li>\n<li><strong>weak_ptr：弱指针，不单独使用，辅助共享指针解决循环引用的问题</strong></li>\n</ol>\n</li>\n<li>C++11：unique_ptr对应boost的scoped_ptr；shared_ptr对应boost的shared_ptr；weak_ptr对应boost的weak_ptr。</li>\n</ul>\n<p>本文主要实现shared_ptr和weak_ptr的模拟，auto_ptr和scoped_ptr模拟拷贝相关的函数。</p>\n<h3 id=\"auto-ptr\"><a href=\"#auto-ptr\" class=\"headerlink\" title=\"auto_ptr\"></a>auto_ptr</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟主要函数：</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">AutoPtr</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* _ptr;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    AutoPtr(T* ptr)&#123; _ptr = ptr; &#125;</span><br><span class=\"line\">    ~AutoPtr()&#123; <span class=\"keyword\">delete</span> _ptr; &#125;</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*()&#123; <span class=\"keyword\">return</span> *_ptr; &#125;</span><br><span class=\"line\">    T* <span class=\"keyword\">operator</span>-&gt;()&#123; <span class=\"keyword\">return</span> _ptr; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AutoPtr(AutoPtr&lt;T&gt;&amp; ap)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//管理权转移</span></span><br><span class=\"line\">        _ptr = ap._ptr;</span><br><span class=\"line\">        ap._ptr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    AutoPtr&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(AutoPtr&lt;T&gt;&amp; ap)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//自己给自己赋值不作处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> != &amp;ap)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(_ptr)</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _ptr;</span><br><span class=\"line\">            <span class=\"comment\">//管理权转移</span></span><br><span class=\"line\">            _ptr = ap._ptr;</span><br><span class=\"line\">            ap_ptr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    AutoPtr&lt;<span class=\"keyword\">int</span>&gt; ap1(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">10</span>));</span><br><span class=\"line\">    AutoPtr&lt;<span class=\"keyword\">int</span>&gt;ap2 = ap1;</span><br><span class=\"line\">    <span class=\"comment\">//崩溃，因为ap1已经指向NULL</span></span><br><span class=\"line\">    *ap1 = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>图解如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802251035_295.png-960.jpg\" alt=\"AutoPtr\"><br><strong>任何时候我们都不使用auto_ptr，因为管理权的转移是不符合我们正常指针的使用的，而且会引起程序崩溃，这个是不允许的。</strong><br>最后，解释一下，<code>operator-&gt;()</code>返回<code>T*</code>的原因：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设定一个类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">student</span>&#123;</span> <span class=\"keyword\">int</span> num; &#125;</span><br><span class=\"line\"><span class=\"comment\">//调用</span></span><br><span class=\"line\">AutoPtr&lt;student&gt; sp = <span class=\"keyword\">new</span> student;</span><br><span class=\"line\">sp-&gt;num = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure></p>\n<p><code>sp-&gt;num</code>等价于<code>sp.operator-&gt;()</code>。<code>sp.operaotr-&gt;()</code>返回<code>T*</code>指针之后，编译器自动将原式优化为<code>_ptr-&gt;num</code>,从而实现对元素的访问。</p>\n<h3 id=\"scoped-ptr\"><a href=\"#scoped-ptr\" class=\"headerlink\" title=\"scoped_ptr\"></a>scoped_ptr</h3><p>防拷贝的智能指针，boost版本相当于C++11的unique_ptr<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟拷贝的主要函数：</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">ScopedPtr</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//与AutoPtr不同的就是这两个函数</span></span><br><span class=\"line\">    ScopedPtr(<span class=\"keyword\">const</span> ScopedPtr&lt;T&gt;&amp; sp);</span><br><span class=\"line\">    ScopedPtr&lt;T&gt;&amp; <span class=\"keyword\">operator</span>= (<span class=\"keyword\">const</span> ScopedPtr&lt;T&gt;&amp; sp);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>scoped_ptr通过将拷贝构造函数和赋值运算符重载定义为私有，同时只声明不定义，这样可以保证该类不能被拷贝。</strong>这就简单的解决了auto_ptr因为拷贝导致的管理权转移问题。</p>\n<h3 id=\"shared-ptr\"><a href=\"#shared-ptr\" class=\"headerlink\" title=\"shared_ptr\"></a>shared_ptr</h3><p><strong>引用计数的智能指针，这个类除了有指针之外，再多开辟了一个内存空间，用于存放计数。</strong>这种智能指针是实现的最好的，在boost库中，实现起来很复杂，因为要考虑多线程等情况。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟主要函数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">SharedPtr</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* _ptr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* _refcount;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//构造</span></span><br><span class=\"line\">    SharedPtr(<span class=\"keyword\">const</span> T&amp; ptr)&#123;</span><br><span class=\"line\">        _ptr = ptr;</span><br><span class=\"line\">        _refcount = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//析构</span></span><br><span class=\"line\">    ~SharedPtr()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(--_refcount == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> _ptr;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> _refcount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//拷贝构造</span></span><br><span class=\"line\">    SharedPtr(SharedPtr&lt;T&gt;&amp; sp)&#123;</span><br><span class=\"line\">        _ptr = sp._ptr;</span><br><span class=\"line\">        _refcount = sp._refcount;</span><br><span class=\"line\">        ++_refcount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//赋值运算符重载</span></span><br><span class=\"line\">    SharedPtr&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> SharedPtr&lt;T&gt;&amp; sp)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*<span class=\"keyword\">this</span> != &amp;sp)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(--(*_refcount) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _ptr;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _refcount;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            _ptr = sp._ptr;</span><br><span class=\"line\">            _refcount = sp._refcount;</span><br><span class=\"line\">            (*_refcount)++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//*重载</span></span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*()&#123; <span class=\"keyword\">return</span> *_ptr; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//-&gt;重载</span></span><br><span class=\"line\">    T* <span class=\"keyword\">operator</span>-&gt;()&#123; <span class=\"keyword\">return</span> _ptr; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这个实现，将是比较实用的。但是依然有一个场景下，会出现问题。这个问题叫做循环引用，问题的根源是引用计数被循环使用，不能减为0，导致死循环。下面以双向链表作为例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个链表节点如下</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//构造函数...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//为了方便调用，设为public</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> _data;</span><br><span class=\"line\">    SharedPtr&lt;ListNode&gt; _next;</span><br><span class=\"line\">    SharedPtr&lt;ListNode&gt; _prev;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//调用这个节点，设定这样一个场景</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    SharedPtr&lt;ListNode&gt; cur(<span class=\"keyword\">new</span> ListNode);</span><br><span class=\"line\">    SharedPtr&lt;ListNode&gt; next(<span class=\"keyword\">new</span> ListNode);</span><br><span class=\"line\">    cur-&gt;_next = next;</span><br><span class=\"line\">    next-&gt;_prev = cur;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建模型如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802251655_141.png-480.jpg\" alt=\"循环引用\"><br>根据上面例子，<code>_next</code>和<code>next</code>都指向后面节点这个空间，<code>next._refcount = 2</code>。<code>_prev</code>和<code>cur</code>指向前面那个节点的空间，<code>cur._refcount = 2</code>。当程序结束的时候，<code>next</code>先被析构。若需要析构<code>next</code>就需要析构<code>next._prev</code>;要析构<code>next._prev</code>就需要析构<code>cur</code>;要析构<code>cur</code>就需要析构<code>cur._next</code>;要析构<code>cur._next</code>就需要析构<code>next</code>……这样就造成了死循环。为了解决这个循环引用的问题，引入了弱指针weak_ptr。</p>\n<h3 id=\"weak-ptr\"><a href=\"#weak-ptr\" class=\"headerlink\" title=\"weak_ptr\"></a>weak_ptr</h3><p><strong>弱指针不单独使用，它的存在就是为了解决使用shared_ptr造成的循环引用问题。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">WeakPtr</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* _ptr;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    WeakPtr()&#123;</span><br><span class=\"line\">        _ptr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    WeakPtr(<span class=\"keyword\">const</span> SharedPtr&lt;T&gt;&amp; sp)&#123;</span><br><span class=\"line\">        _ptr = sp._ptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*()&#123; <span class=\"keyword\">return</span> *_ptr; &#125;</span><br><span class=\"line\">    T* <span class=\"keyword\">operator</span>-&gt;()&#123; <span class=\"keyword\">return</span> _ptr; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    WeakPtr&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> SharedPtr&lt;T&gt;&amp; sp)&#123;</span><br><span class=\"line\">        _ptr = sp._ptr;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//还需要修改一下两处：</span></span><br><span class=\"line\"><span class=\"comment\">//1、修改ListNode的结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> _data;</span><br><span class=\"line\">    WeakPtr&lt;ListNode&gt; _next;</span><br><span class=\"line\">    WeakPtr&lt;ListNode&gt; _prev;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、将WeakPtr定义为SharedPtr的友元，因为WeakPtr中需要访问SharedPtr的私有成员</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">SharedPtr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakPtr</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样，上面那个例子中，<code>next._refcount = 1</code>，<code>cur._refcount = 1</code>,就不会出现循环引用的问题了。</p>\n","site":{"data":{}},"excerpt":"<p>智能指针是C++中一个编程技巧。它保证内存的正确释放，解决了内存泄漏的问题。有一个思想叫做RAII，<strong>RAII指的是资源分配即初始化。我们通常会定义一个类来封装资源的分配和释放，在构造函数中完成资源的分配和初始化，在析构函数中完成资源的清理。</strong><br>在C++中，我们一般是使用new和delete来实现内存的初始化和释放。正确的配对使用可以处理绝大部分问题，但是如果出现了执行流的跳转，比如：语句中间出现了return，break，continue，goto，等关键字，我们的delete可能没有执行，这样就导致了内存没有被释放。又或者我们的语句出现了错误，抛出异常导致程序结束，也有可能没有执行delete语句。这 <strong>些问题都导致了内存泄漏。智能指针的出现就是为了解决这些问题的。智能指针其实是一个类，它可以自动的处理指针指向的动态资源的释放。</strong></p>\n<h3 id=\"发展历程\"><a href=\"#发展历程\" class=\"headerlink\" title=\"发展历程\"></a>发展历程","more":"</h3><ul>\n<li>早期C++98：auto_ptr，最早出现的智能指针，拷贝机制是管理权转移，致命缺陷，不使用。</li>\n<li>boost(非官方)：<ol>\n<li>scoped_ptr/scoped_array：守卫指针，拷贝机制是不拷贝，简单粗暴</li>\n<li><strong>shared_ptr/shared_array：共享指针，拷贝机制是引用计数，比较复杂，会出现循环引用的问题。</strong></li>\n<li><strong>weak_ptr：弱指针，不单独使用，辅助共享指针解决循环引用的问题</strong></li>\n</ol>\n</li>\n<li>C++11：unique_ptr对应boost的scoped_ptr；shared_ptr对应boost的shared_ptr；weak_ptr对应boost的weak_ptr。</li>\n</ul>\n<p>本文主要实现shared_ptr和weak_ptr的模拟，auto_ptr和scoped_ptr模拟拷贝相关的函数。</p>\n<h3 id=\"auto-ptr\"><a href=\"#auto-ptr\" class=\"headerlink\" title=\"auto_ptr\"></a>auto_ptr</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟主要函数：</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">AutoPtr</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* _ptr;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    AutoPtr(T* ptr)&#123; _ptr = ptr; &#125;</span><br><span class=\"line\">    ~AutoPtr()&#123; <span class=\"keyword\">delete</span> _ptr; &#125;</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*()&#123; <span class=\"keyword\">return</span> *_ptr; &#125;</span><br><span class=\"line\">    T* <span class=\"keyword\">operator</span>-&gt;()&#123; <span class=\"keyword\">return</span> _ptr; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AutoPtr(AutoPtr&lt;T&gt;&amp; ap)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//管理权转移</span></span><br><span class=\"line\">        _ptr = ap._ptr;</span><br><span class=\"line\">        ap._ptr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    AutoPtr&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(AutoPtr&lt;T&gt;&amp; ap)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//自己给自己赋值不作处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> != &amp;ap)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(_ptr)</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _ptr;</span><br><span class=\"line\">            <span class=\"comment\">//管理权转移</span></span><br><span class=\"line\">            _ptr = ap._ptr;</span><br><span class=\"line\">            ap_ptr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    AutoPtr&lt;<span class=\"keyword\">int</span>&gt; ap1(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">10</span>));</span><br><span class=\"line\">    AutoPtr&lt;<span class=\"keyword\">int</span>&gt;ap2 = ap1;</span><br><span class=\"line\">    <span class=\"comment\">//崩溃，因为ap1已经指向NULL</span></span><br><span class=\"line\">    *ap1 = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>图解如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802251035_295.png-960.jpg\" alt=\"AutoPtr\"><br><strong>任何时候我们都不使用auto_ptr，因为管理权的转移是不符合我们正常指针的使用的，而且会引起程序崩溃，这个是不允许的。</strong><br>最后，解释一下，<code>operator-&gt;()</code>返回<code>T*</code>的原因：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设定一个类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">student</span>&#123;</span> <span class=\"keyword\">int</span> num; &#125;</span><br><span class=\"line\"><span class=\"comment\">//调用</span></span><br><span class=\"line\">AutoPtr&lt;student&gt; sp = <span class=\"keyword\">new</span> student;</span><br><span class=\"line\">sp-&gt;num = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure></p>\n<p><code>sp-&gt;num</code>等价于<code>sp.operator-&gt;()</code>。<code>sp.operaotr-&gt;()</code>返回<code>T*</code>指针之后，编译器自动将原式优化为<code>_ptr-&gt;num</code>,从而实现对元素的访问。</p>\n<h3 id=\"scoped-ptr\"><a href=\"#scoped-ptr\" class=\"headerlink\" title=\"scoped_ptr\"></a>scoped_ptr</h3><p>防拷贝的智能指针，boost版本相当于C++11的unique_ptr<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟拷贝的主要函数：</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">ScopedPtr</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//与AutoPtr不同的就是这两个函数</span></span><br><span class=\"line\">    ScopedPtr(<span class=\"keyword\">const</span> ScopedPtr&lt;T&gt;&amp; sp);</span><br><span class=\"line\">    ScopedPtr&lt;T&gt;&amp; <span class=\"keyword\">operator</span>= (<span class=\"keyword\">const</span> ScopedPtr&lt;T&gt;&amp; sp);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>scoped_ptr通过将拷贝构造函数和赋值运算符重载定义为私有，同时只声明不定义，这样可以保证该类不能被拷贝。</strong>这就简单的解决了auto_ptr因为拷贝导致的管理权转移问题。</p>\n<h3 id=\"shared-ptr\"><a href=\"#shared-ptr\" class=\"headerlink\" title=\"shared_ptr\"></a>shared_ptr</h3><p><strong>引用计数的智能指针，这个类除了有指针之外，再多开辟了一个内存空间，用于存放计数。</strong>这种智能指针是实现的最好的，在boost库中，实现起来很复杂，因为要考虑多线程等情况。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟主要函数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">SharedPtr</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* _ptr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* _refcount;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//构造</span></span><br><span class=\"line\">    SharedPtr(<span class=\"keyword\">const</span> T&amp; ptr)&#123;</span><br><span class=\"line\">        _ptr = ptr;</span><br><span class=\"line\">        _refcount = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//析构</span></span><br><span class=\"line\">    ~SharedPtr()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(--_refcount == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> _ptr;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> _refcount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//拷贝构造</span></span><br><span class=\"line\">    SharedPtr(SharedPtr&lt;T&gt;&amp; sp)&#123;</span><br><span class=\"line\">        _ptr = sp._ptr;</span><br><span class=\"line\">        _refcount = sp._refcount;</span><br><span class=\"line\">        ++_refcount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//赋值运算符重载</span></span><br><span class=\"line\">    SharedPtr&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> SharedPtr&lt;T&gt;&amp; sp)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*<span class=\"keyword\">this</span> != &amp;sp)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(--(*_refcount) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _ptr;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> _refcount;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            _ptr = sp._ptr;</span><br><span class=\"line\">            _refcount = sp._refcount;</span><br><span class=\"line\">            (*_refcount)++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//*重载</span></span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*()&#123; <span class=\"keyword\">return</span> *_ptr; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//-&gt;重载</span></span><br><span class=\"line\">    T* <span class=\"keyword\">operator</span>-&gt;()&#123; <span class=\"keyword\">return</span> _ptr; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这个实现，将是比较实用的。但是依然有一个场景下，会出现问题。这个问题叫做循环引用，问题的根源是引用计数被循环使用，不能减为0，导致死循环。下面以双向链表作为例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个链表节点如下</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//构造函数...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//为了方便调用，设为public</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> _data;</span><br><span class=\"line\">    SharedPtr&lt;ListNode&gt; _next;</span><br><span class=\"line\">    SharedPtr&lt;ListNode&gt; _prev;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//调用这个节点，设定这样一个场景</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    SharedPtr&lt;ListNode&gt; cur(<span class=\"keyword\">new</span> ListNode);</span><br><span class=\"line\">    SharedPtr&lt;ListNode&gt; next(<span class=\"keyword\">new</span> ListNode);</span><br><span class=\"line\">    cur-&gt;_next = next;</span><br><span class=\"line\">    next-&gt;_prev = cur;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>创建模型如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802251655_141.png-480.jpg\" alt=\"循环引用\"><br>根据上面例子，<code>_next</code>和<code>next</code>都指向后面节点这个空间，<code>next._refcount = 2</code>。<code>_prev</code>和<code>cur</code>指向前面那个节点的空间，<code>cur._refcount = 2</code>。当程序结束的时候，<code>next</code>先被析构。若需要析构<code>next</code>就需要析构<code>next._prev</code>;要析构<code>next._prev</code>就需要析构<code>cur</code>;要析构<code>cur</code>就需要析构<code>cur._next</code>;要析构<code>cur._next</code>就需要析构<code>next</code>……这样就造成了死循环。为了解决这个循环引用的问题，引入了弱指针weak_ptr。</p>\n<h3 id=\"weak-ptr\"><a href=\"#weak-ptr\" class=\"headerlink\" title=\"weak_ptr\"></a>weak_ptr</h3><p><strong>弱指针不单独使用，它的存在就是为了解决使用shared_ptr造成的循环引用问题。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">WeakPtr</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* _ptr;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    WeakPtr()&#123;</span><br><span class=\"line\">        _ptr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    WeakPtr(<span class=\"keyword\">const</span> SharedPtr&lt;T&gt;&amp; sp)&#123;</span><br><span class=\"line\">        _ptr = sp._ptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*()&#123; <span class=\"keyword\">return</span> *_ptr; &#125;</span><br><span class=\"line\">    T* <span class=\"keyword\">operator</span>-&gt;()&#123; <span class=\"keyword\">return</span> _ptr; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    WeakPtr&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> SharedPtr&lt;T&gt;&amp; sp)&#123;</span><br><span class=\"line\">        _ptr = sp._ptr;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//还需要修改一下两处：</span></span><br><span class=\"line\"><span class=\"comment\">//1、修改ListNode的结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> _data;</span><br><span class=\"line\">    WeakPtr&lt;ListNode&gt; _next;</span><br><span class=\"line\">    WeakPtr&lt;ListNode&gt; _prev;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、将WeakPtr定义为SharedPtr的友元，因为WeakPtr中需要访问SharedPtr的私有成员</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">SharedPtr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakPtr</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样，上面那个例子中，<code>next._refcount = 1</code>，<code>cur._refcount = 1</code>,就不会出现循环引用的问题了。</p>"},{"title":"模板与分离编译","date":"2018-02-24T06:56:19.000Z","keywords":["C++","模板","分离编译"],"password":null,"_content":"### 分离编译模式\n一个项目如果有多个源文件组成，每个源文件单独编译，形成目标文件。最后通过链接器将所有的目标文件链接起来，形成一个可执行的文件。这个过程就叫做分离编译。\n### 模板不能分离编译\n有一个项目，其中函数声明放在\"test.h\"中，函数实现放在\"test.cpp\"中，函数调用放在\"main.cpp\"中。如果没用使用模板，将不会有任何问题。而且这样是被推荐使用的。<!--more-->但是如果有函数的实现是模板函数或有模板类，将会出现链接错误。代码如下:\n```c++\n//test.h\n#pragma once\n\ntemplate <class T>\nvoid print(T num);\n\n//test.cpp\ntemplate <class T>\nvoid print(T num){ cout << num << endl; }\n\n//main.cpp\n#include <iostream>\n#include \"test.h\"\nusing namespace std;\n\nint main(){\n    int number = 10;\n    print(number);\n    return 0;\n}\n```\n这样的代码看起来是没有问题的。执行的时候并不会出现编译错误，但是会出现链接错误。\n![链接错误](http://p3ax8ersb.bkt.clouddn.com/201802242117_802.png-1920.jpg)\n这是因为采取了分离编译之后，我们的.cpp文件是独立编译的。test.cpp中的模板函数，由于没有被调用，所以它的T并没有被实例化相应的类型，比如例子中的int类型。main.cpp中调用了函数print，他需要实例print(int num)。在链接的时候，找不到需要的实例化函数，这样就产生了错误。\n### 解决办法1-显示实例化\n在函数定义的时候，指定我们需要实例化的类型。在头文件定义中添加指定类型的定义：\n```c++\n#pragma once\n\ntemplate <class T>\nvoid print(T num);\n//添加int定义\ntemplate void print<int>(int num);\n```\n这种方式是最简单，但是这样却是最麻烦的。如果我有多个不同类型，就需要有相应个数的特化。\n### 解决办法2-不使用分离编译\n既然不能使用，那么我们不使用分离编译就是了。将我们的函数声明和函数定义放在test.h中。这样我们编译的时候，需要将头文件展开，这样就可以将模板函数在编译的时候实例化。\n```c++\n//test.h\n//不需要test.cpp\n#pragma once\n\ntemplate <class T>\nvoid print(T num){ cout << num << endl; }\n```\n这样解决了模板的分离编译的问题，但是这样也就暴露了我们的函数定义。","source":"_posts/模板与分离编译.md","raw":"---\ntitle: 模板与分离编译\ndate: 2018-02-24 14:56:19\ntags:\ncategories:\n    - \"knowledge\"\n    - \"C/C++\"\nkeywords:\n    - \"C++\"\n    - \"模板\"\n    - \"分离编译\"\npassword:\n---\n### 分离编译模式\n一个项目如果有多个源文件组成，每个源文件单独编译，形成目标文件。最后通过链接器将所有的目标文件链接起来，形成一个可执行的文件。这个过程就叫做分离编译。\n### 模板不能分离编译\n有一个项目，其中函数声明放在\"test.h\"中，函数实现放在\"test.cpp\"中，函数调用放在\"main.cpp\"中。如果没用使用模板，将不会有任何问题。而且这样是被推荐使用的。<!--more-->但是如果有函数的实现是模板函数或有模板类，将会出现链接错误。代码如下:\n```c++\n//test.h\n#pragma once\n\ntemplate <class T>\nvoid print(T num);\n\n//test.cpp\ntemplate <class T>\nvoid print(T num){ cout << num << endl; }\n\n//main.cpp\n#include <iostream>\n#include \"test.h\"\nusing namespace std;\n\nint main(){\n    int number = 10;\n    print(number);\n    return 0;\n}\n```\n这样的代码看起来是没有问题的。执行的时候并不会出现编译错误，但是会出现链接错误。\n![链接错误](http://p3ax8ersb.bkt.clouddn.com/201802242117_802.png-1920.jpg)\n这是因为采取了分离编译之后，我们的.cpp文件是独立编译的。test.cpp中的模板函数，由于没有被调用，所以它的T并没有被实例化相应的类型，比如例子中的int类型。main.cpp中调用了函数print，他需要实例print(int num)。在链接的时候，找不到需要的实例化函数，这样就产生了错误。\n### 解决办法1-显示实例化\n在函数定义的时候，指定我们需要实例化的类型。在头文件定义中添加指定类型的定义：\n```c++\n#pragma once\n\ntemplate <class T>\nvoid print(T num);\n//添加int定义\ntemplate void print<int>(int num);\n```\n这种方式是最简单，但是这样却是最麻烦的。如果我有多个不同类型，就需要有相应个数的特化。\n### 解决办法2-不使用分离编译\n既然不能使用，那么我们不使用分离编译就是了。将我们的函数声明和函数定义放在test.h中。这样我们编译的时候，需要将头文件展开，这样就可以将模板函数在编译的时候实例化。\n```c++\n//test.h\n//不需要test.cpp\n#pragma once\n\ntemplate <class T>\nvoid print(T num){ cout << num << endl; }\n```\n这样解决了模板的分离编译的问题，但是这样也就暴露了我们的函数定义。","slug":"模板与分离编译","published":1,"updated":"2018-02-24T14:58:30.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nr6c001b04d8kbfjkst5","content":"<h3 id=\"分离编译模式\"><a href=\"#分离编译模式\" class=\"headerlink\" title=\"分离编译模式\"></a>分离编译模式</h3><p>一个项目如果有多个源文件组成，每个源文件单独编译，形成目标文件。最后通过链接器将所有的目标文件链接起来，形成一个可执行的文件。这个过程就叫做分离编译。</p>\n<h3 id=\"模板不能分离编译\"><a href=\"#模板不能分离编译\" class=\"headerlink\" title=\"模板不能分离编译\"></a>模板不能分离编译</h3><p>有一个项目，其中函数声明放在”test.h”中，函数实现放在”test.cpp”中，函数调用放在”main.cpp”中。如果没用使用模板，将不会有任何问题。而且这样是被推荐使用的。<a id=\"more\"></a>但是如果有函数的实现是模板函数或有模板类，将会出现链接错误。代码如下:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//test.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">print</span>(<span class=\"title\">T</span> <span class=\"title\">num</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//test.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">print</span>(<span class=\"title\">T</span> <span class=\"title\">num</span>)&#123;</span> <span class=\"built_in\">cout</span> &lt;&lt; num &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"test.h\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> number = <span class=\"number\">10</span>;</span><br><span class=\"line\">    print(number);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样的代码看起来是没有问题的。执行的时候并不会出现编译错误，但是会出现链接错误。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802242117_802.png-1920.jpg\" alt=\"链接错误\"><br>这是因为采取了分离编译之后，我们的.cpp文件是独立编译的。test.cpp中的模板函数，由于没有被调用，所以它的T并没有被实例化相应的类型，比如例子中的int类型。main.cpp中调用了函数print，他需要实例print(int num)。在链接的时候，找不到需要的实例化函数，这样就产生了错误。</p>\n<h3 id=\"解决办法1-显示实例化\"><a href=\"#解决办法1-显示实例化\" class=\"headerlink\" title=\"解决办法1-显示实例化\"></a>解决办法1-显示实例化</h3><p>在函数定义的时候，指定我们需要实例化的类型。在头文件定义中添加指定类型的定义：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">print</span>(<span class=\"title\">T</span> <span class=\"title\">num</span>);</span></span><br><span class=\"line\"><span class=\"comment\">//添加int定义</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> <span class=\"keyword\">void</span> print&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"keyword\">int</span> num);</span><br></pre></td></tr></table></figure></p>\n<p>这种方式是最简单，但是这样却是最麻烦的。如果我有多个不同类型，就需要有相应个数的特化。</p>\n<h3 id=\"解决办法2-不使用分离编译\"><a href=\"#解决办法2-不使用分离编译\" class=\"headerlink\" title=\"解决办法2-不使用分离编译\"></a>解决办法2-不使用分离编译</h3><p>既然不能使用，那么我们不使用分离编译就是了。将我们的函数声明和函数定义放在test.h中。这样我们编译的时候，需要将头文件展开，这样就可以将模板函数在编译的时候实例化。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//test.h</span></span><br><span class=\"line\"><span class=\"comment\">//不需要test.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">print</span>(<span class=\"title\">T</span> <span class=\"title\">num</span>)&#123;</span> <span class=\"built_in\">cout</span> &lt;&lt; num &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样解决了模板的分离编译的问题，但是这样也就暴露了我们的函数定义。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"分离编译模式\"><a href=\"#分离编译模式\" class=\"headerlink\" title=\"分离编译模式\"></a>分离编译模式</h3><p>一个项目如果有多个源文件组成，每个源文件单独编译，形成目标文件。最后通过链接器将所有的目标文件链接起来，形成一个可执行的文件。这个过程就叫做分离编译。</p>\n<h3 id=\"模板不能分离编译\"><a href=\"#模板不能分离编译\" class=\"headerlink\" title=\"模板不能分离编译\"></a>模板不能分离编译</h3><p>有一个项目，其中函数声明放在”test.h”中，函数实现放在”test.cpp”中，函数调用放在”main.cpp”中。如果没用使用模板，将不会有任何问题。而且这样是被推荐使用的。","more":"但是如果有函数的实现是模板函数或有模板类，将会出现链接错误。代码如下:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//test.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">print</span>(<span class=\"title\">T</span> <span class=\"title\">num</span>);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//test.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">print</span>(<span class=\"title\">T</span> <span class=\"title\">num</span>)&#123;</span> <span class=\"built_in\">cout</span> &lt;&lt; num &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"test.h\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> number = <span class=\"number\">10</span>;</span><br><span class=\"line\">    print(number);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样的代码看起来是没有问题的。执行的时候并不会出现编译错误，但是会出现链接错误。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802242117_802.png-1920.jpg\" alt=\"链接错误\"><br>这是因为采取了分离编译之后，我们的.cpp文件是独立编译的。test.cpp中的模板函数，由于没有被调用，所以它的T并没有被实例化相应的类型，比如例子中的int类型。main.cpp中调用了函数print，他需要实例print(int num)。在链接的时候，找不到需要的实例化函数，这样就产生了错误。</p>\n<h3 id=\"解决办法1-显示实例化\"><a href=\"#解决办法1-显示实例化\" class=\"headerlink\" title=\"解决办法1-显示实例化\"></a>解决办法1-显示实例化</h3><p>在函数定义的时候，指定我们需要实例化的类型。在头文件定义中添加指定类型的定义：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">print</span>(<span class=\"title\">T</span> <span class=\"title\">num</span>);</span></span><br><span class=\"line\"><span class=\"comment\">//添加int定义</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> <span class=\"keyword\">void</span> print&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"keyword\">int</span> num);</span><br></pre></td></tr></table></figure></p>\n<p>这种方式是最简单，但是这样却是最麻烦的。如果我有多个不同类型，就需要有相应个数的特化。</p>\n<h3 id=\"解决办法2-不使用分离编译\"><a href=\"#解决办法2-不使用分离编译\" class=\"headerlink\" title=\"解决办法2-不使用分离编译\"></a>解决办法2-不使用分离编译</h3><p>既然不能使用，那么我们不使用分离编译就是了。将我们的函数声明和函数定义放在test.h中。这样我们编译的时候，需要将头文件展开，这样就可以将模板函数在编译的时候实例化。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//test.h</span></span><br><span class=\"line\"><span class=\"comment\">//不需要test.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">print</span>(<span class=\"title\">T</span> <span class=\"title\">num</span>)&#123;</span> <span class=\"built_in\">cout</span> &lt;&lt; num &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样解决了模板的分离编译的问题，但是这样也就暴露了我们的函数定义。</p>"},{"title":"浅读《STL源码剖析》笔记 1、2章","date":"2018-02-03T03:15:06.000Z","_content":"## 1 STL概论与版本简介\n### 1.2 STL六大组件\n1. 容器(containers):`vector,list,deque,set,map`,用来存放数据\n2. 算法(algorithms):`sort,search,copy,erase`\n3. 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，<!--more-->迭代器器将`operator*,operator++,operator--,operator->`等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。\n4. 仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。\n5. 配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。\n6. 配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。\n\n### 1.5~1.8 STL版本之二\n1. P.J.Plauger (Microsoft Visual C++)\n2. SGI STL (Linux GCC)\n    C++标准规范下的C头文件: `cstdio,cstdlib,cstring`\n    C++标准程序库中不属于STL范畴: `stream,string`\n    STL标准头文件: `vector,deque,list,map,algorithm,functional`\n    C++Standard定案前，HP所规范的STL头文件: `vector.h,deque.h,list.h,algo.h,function.h`\n    SGI STL内部文件(STL真正实现于此): `stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h`\n\n### 1.9 可能令你困惑的C++语法\n#### 1.9.2 临时对象的产生与运用\n临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。**STL中最常将此技巧用在仿函数(functor)中。**临时对象的生命周期只有这一行指令。\n#### 1.9.3 静态常量整数成员在class内部直接初始化\nclass内含有`const static integral data member`，我们可以直接给予初值。\n```c++\n//1.9.3测试代码如下\ntemplate <typename T>\nclass testclass{\npublic:\n    static const int datai = 5;\n    static const long datal = 3L;\n    static const char datac = 'c';\n};\n\nint main(){\n    cout << testclass<int>::datai << endl;\n    cout << testclass<int>::datal << endl;\n    cout << testclass<int>::datac << endl;\n    return 0;\n}\n```\n运行结果：\n![运行结果](http://p3ax8ersb.bkt.clouddn.com/201801291947_629.png-960.jpg)\n#### 1.9.5 前闭后开区间表示法[)\n**STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。**\n#### 1.9.6 function call操作符(operator())\nfunction call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。**如果你针对某个class进行operator()重载，它就成为一个仿函数。**\n```c++\n//1.9.6测试代码如下\ntemplate <class T>\nstruct Add{\n    //重载了operator()\n    T operator()(const T&x, const T&y) const{\n        return x+y;\n    }\n};\nint main(){\n    Add<int> addxy;\n    system( \"clear\" );\n    //调用重载函数\n    cout << addxy(3,5) << endl;\n    //调用匿名对象\n    cout << Add<int>()(5,5) << endl;\n    return 0;\n}\n```\n运行结果：\n![仿函数](http://p3ax8ersb.bkt.clouddn.com/201801292024_990.png-960.jpg)\n\n## 2 空间配置器(allocator)\n空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。\n### 2.2 具备此配置力的SGI空间配置器\n#### 2.2.1 SGI标准的空间配置器,std::allocator\nSGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：`vector<int,std::allocator<int>>`;SGI STL写法如下：`vector<int, std::aloc>`绝大多数情况下，我们都是使用缺省的空间配置器。\n#### 2.2.2 SGI特殊的空间配置器，std::alloc\nSGI同时也配备了标准空间配置器`std::allocator`，但是这只是对C++的`operator new和operator delete`做了一层封装，效率低下，**SGI并不使用，只是为了向前兼容语法。**\n\n**SGI自身使用的空间配置器是`std::alloc`**一般来说，我们习惯的C++内存操作和释放操作是这样的：\n```c++\nclass Foo{};\nFoo* pf = new Foo;\ndelete pf;\n```\n这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。**为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。**\nSTL的配置器(allocator)定于于`<memory>`，其中包含两个文件,一个是负责内存空间的配置与释放<stl_alloc.h>,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构<stl_construct.h>，定义了全局函数construct()和destroy()。\n\n#### 2.2.3 构造和析构基本工具:construct()和destroy()\nconstruct()的实现如下：\n```c++\n#include <new.h>    //使用placement new 需要这个头文件\ntemplate <class T1, class T2>\ninline void construct(T1* p, const T2& value){\n    new (p) T1(value);  //使用了placement new;调用T1:T1(value);\n}\n```\n代码解释：`construct()`接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，**通过`placement new`实现**。\ndestroy()有两个版本，实现如下:\n```c++\n//第一个版本，接受一个指针\ntemplate <class T>\ninline void destroy(T* pointer){\n    pointer->~T();\n}\n//第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits<>求取最适当的措施。\ntemplate <class ForwardIterator>\ninline void destroy(ForwardIterator first, ForwardIterator last){\n    __destroy(first, last, value_type(first));\n}\n//判断元素的数值型别(value type)是否有 trivial destructor\ntemplate <class ForwardIterator, class T>\ninline void __destroy(ForwardIterator first, ForwardIterator last, T*){\n    typedef typename __type_traits<T>::has_trivial_destructor trivial_destructor;\n    __destroy_aux(first, last, trivial_destructor());\n}\n//如果元素的数值型别(value type)有non-truvial destructor，循环释放\ntemplate <class ForwardIterator>\ninline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type){\n    for( ; first < last; ++first)\n        //调用第一个版本的destroy()\n        destroy(&* first);\n}\n//如果元素的数值型别(value type)有trivial destructor,函数什么也不做\ntemplate <class ForwardIterator, ForwardIterator, __true_type>{\n    inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type){}\n}\n//destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做\ninline void desroy(char*, char*){}\ninline void destroy(wchar_t*,wchar_t*){}\n```\n代码解释：`destroy()`有两个版本，**第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可**。第二个版本接收first和last两个迭代器，准备将`[firat, last)`范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓`trivial destructor`),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，**这里首先利用`value_type()`获得迭代器所指对象的型别，再利用`__type_traits<T>`判断该型别的析构函数是否无关痛痒。若是`(__true_type)`，则什么都不做结束；若不是`(__false_type)`,这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的`destroy()`。**\n\nconstruct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits<>在3.7节。\n![construct()和destroy()图解](http://p3ax8ersb.bkt.clouddn.com/201802011438_654.png-960.jpg)\n\n#### 2.2.4 空间的配置与释放，std::alloc\n对象构造前的空间配置和对象析构后的空间释放，由`<stl_alloc.h>`负责。\n1. 向 system heap 要求空间\n2. 考虑多线程(multi-threads)状态(这里不考虑多线程的情况)\n3. 考虑内存不足时的应变措施\n4. 考虑过多“小型区域”可能造成的内存碎片(fragment)问题\n\n**C++内存配置的基本操作是:`:operator new()`，内存释放的基本操作是`::operator delete()`。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。**\n\n为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，**第一级配置器`(__malloc_alloc_template)`用malloc()和free()，第二级配置器`(__default_alloc_template)`看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池`memory bool`整理方式。**其中具体是开放了第一级配置器还是两级配置器都开放了由__USE_MEALLOC是否定义决定，定义了__USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。\n\n无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口`simple_alloc`，使其能够符合STL的接口规格。\n```c++\ntemplate <class T,class Alloc>\nclass simple_alloc{\npublic:\n    static T* allocate(size_t n){\n        return 0 == n?0 : (T*) Alloc::allocate(n* sizeof (T));\n    }\n    static T* allocate(void){\n        return (T*) Alloc::allocatte(sizeof (T));\n    }\n    static void dallocate(T* p, size_t n){\n        if(0 != n)\n            Alloc::deallocate(p, n*sizeof (T));\n    }\n    static void deallocat(T* p){\n        Alloc::deallocate(p, sizeof (T));\n    }\n};\n```\n内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。\n\n图解如下：\n    第一级配置器和第二级配置器：![第一级配置器和第二级配置器](http://p3ax8ersb.bkt.clouddn.com/201802011620_34.png-960.jpg)\n    包装接口和运用：![包装接口和运用](http://p3ax8ersb.bkt.clouddn.com/201802011647_747.png-960.jpg)\n\n更新时间：2018.02.17\n#### 2.2.5 第一级配置器 __malloc_alloc_template 剖析\n```c++\ntemplate <int inst> //inst 没有用到\nclass __malloc_alloc_template{\nprivate:\n    //处理内存不够的情况\n    //oom: out of memory\n    static void *oom_malloc(size_t);\n    static void *oom_realloc(void*, size_t);\n    static void (* __malloc_alloc_oom_handler)();\n\npublic:\n    //直接调用malloc，free，realloc，只是多了一层封装，使之可以处理内存不够的情况\n    static void* allocate(size_t n){\n        void *result = malloc(n);\n        if(0 == result)\n            result = oom_malloc(n);\n    }\n    static void deallocate(void* p, size_t){\n        free(p);\n    }\n    static void* reallocate(void* p, size_t, size_t new_sz){\n        void* result = realloc(p, new_sz);\n        if(0 = result)\n            result = oom_realloc(p, new_sz);\n            return result;\n    }\n\n    //仿真c++的set_new_handdler()\n    static void(* set_malloc_handler(void(*f)()))(){\n        //被调用的函数__malloc_alloc_oom_handler\n        void(* old)() = __malloc_alloc_oom_handler;\n        __malloc_alloc_oom_handler = f;\n        return (old);\n    }\n    //__malloc_alloc_oom_handler函数初始值是0，该值由客端自己设定\n    template <int inst>\n    void (* __malloc_alloc_template<inst> :: __malloc_alloc_oom_handler)() = 0;\n\n    //oom_malloc\n    template <int inst>\n    void* __malloc_alloc_template<inst> :: oom_malloc(size_t n){\n        void (* my_malloc_handler)();\n        void* result;\n        for(; ;){   //不停的尝试，释放，配置，释放，配置……\n            my_malloc_handler = __malloc_alloc_oom_handler;\n            //如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常\n            if(0 == my_malloc_handler){\n                __THROW_BAD_ALLOC;\n            }\n            (*my_malloc_handler)(); //调用处理例程，企图释放内存\n            result = malloc(n);     //再次配置\n            if(result)\n                return (result);\n        }\n    }\n    //oom_realloc\n    template <int inst>\n    void* __malloc_alloc_template<inst> :: oom_realloc(void* p, size_t n){\n        void (* my_malloc_handler)();\n        void* result;\n        for(; ;){   //不停的尝试，释放，配置，释放，配置……\n            my_malloc_handler = __malloc_alloc_oom_handler;\n            //如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常\n            if(0 == my_malloc_handler){\n                __THROW_BAD_ALLOC;\n            }\n            (*my_malloc_handler)(); //调用处理例程，企图释放内存\n            result = malloc(n);     //再次配置\n            if(result)\n                return (result);\n        }\n    }\n}\n```\n第一级配置器以malloc()、free()、realloc()等C函数执行实际的内存的配置、释放、重配置操作，同时实现出类似C++ new-handler的机制。所谓new-handler就是在系统内存配置需求无法被满足的情况下，调用一个指定的函数。\n#### 2.2.6 第二级配置器__default_alloc_template 剖析\n第二级配置器__default_alloc_template多了些机制，避免太多小额区块造成内存的碎片。\n\n当区块超过128bytes，则用内存池管理，此做法又称为次层配置(sub-allocation)：每次配置一大块内存，并维护对应自由链表(free-lists)。下次如果再有相同大小的内存需求，就直接从free-lists中取出。如果客端释放返还小额区块，就有配置器会受到free-lists中。二级配置器会自动将内存调整为8的倍数，并维护16个free-lists，各自管理8的倍数的小额区块。\n```c++\n//free-list的节点\nunion obj{\n    union obj *free_list_link;\n    char client_data[1];\n}\n```\n其中，obj是一个obj指针，指向下一个相同大小的区块。同时obj是一个指针，指向实际中区块。结合2.2.7的图理解。\n如图：\n![free-lists](http://p3ax8ersb.bkt.clouddn.com/201802171615_46.png-480.jpg)\n#### 2.2.7 空间配置函数allocate()\nallocate()是二级配置器__default_alloc_template的一个标准接口函数。这个函数首先判断区块大小，大于128bytes调用的第一级配置器，小于128bytes的查询对应free-list有可以用的区块，就直接拿来用，如果没有，就将区块大小调至8倍数边界，然后调用refill()，为free list重新填充空间。\n```c++\n//n > 0\nstatic void* allocate(size_t n){\n    //二级指针，但是volatile的用法不详\n    obj* volatile *my_free_list;\n    obj* result;\n\n    if(n>(size_t) __MAX_BYTES){\n        return (malloc_alloc::allocate(n));\n    }\n    //寻找16个free list中适合的一个\n    my_free_list = free_list + FREELIST_INDEX(n);\n    result  = *my_free_list;\n    if(result == 0){\n        //准备填充free list\n        void* r = refill(ROUND_UP(n));\n        return r;\n    }\n    //调整free list\n    *my_free_list = result -> free_list_link;\n    return (result);\n}\n```\n图解如下：\n![freel list 拔出](http://p3ax8ersb.bkt.clouddn.com/201802171658_88.png-480.jpg)\n#### 2.2.8 空间释放函数 deallocate()\ndeallocate()是配置器__default_alloc_template的一个标准接口函数。大于128bytes调用第一级配置器，小于128bytes找到对应的free list将区块回收。\n```c++\n// p不可以是 0\nstatic void deallocate(void *p, size_t n){\n    obj* q = (obj* )p;\n    //二级指针，但是volatile的用法不详\n    obj* volatile *my_free_list;\n\n    if(n>(size_t) __MAX_BYTES){\n        malloc_alloc::deallocate(p, n);\n        return;\n    }\n    //寻找对应的free list\n    my_free_list = free_list + FREELIST_INDEX(n);\n    //调整free list，回收区域\n    q->free_list_link = *my_free_list();\n    *my_free_list = q;\n}\n```\n图解如下：\n![deallocate](http://p3ax8ersb.bkt.clouddn.com/201802171745_127.png-480.jpg)\n#### 2.2.9 重新填充 free lists\nallocate()中，当它发现free list中没有可用区块的时候，调用refill()，为free list重新填充空间。新的空间将取自内存池(chunk_alloc()完成)。缺省获得20个新节点。\n```c++\n//返回一个大小为n的对象，并且有时候会为适当的free list增加节点\n//假设n已经适当上调至8的倍数\ntemplate <bool threads, int inst>\nvoid* __default_alloc_template<threads, inst> :: refill(size_t n){\n    int nobjs = 20; //缺省值\n    //调用chunk_alloc()，尝试获得nobjs个区块作为free list的新节点\n    char* chunk = chunk_alloc(n, nobjs);\n    obj* volatile* my_free_list;\n    obj* result;\n    obj* current_obj, *next_obj;\n    int i;\n    //如果只获得一个区块，这个区块就分配给调用者使用，free list无新节点\n    if(1 == nobjs)\n        return (chunk);\n    //否则调整free list纳入新的节点\n    my_free_list = free_list + FREELIST_INDEX(n)；\n    //以下在chunk空间创建free list\n    result = (obj *)chumk;\n    //以下导引free list 指向新配置的空间(取自内存池)\n    *my_free_list = next_obj = (obj*)(chunk + n);\n    //以下将free list 的各个节点串联起来\n    for(i = 1; ; i++){  //从n == 1开始，因为0号要返回给客端\n        current_obj = next_obj;\n        next_obj = (obj*)((char *)next_obj + n);\n        if(nobjs - 1 == i){\n            current_obj -> free_list_link = 0;\n            break;\n        }\n        else{\n            current_obj->free_list_link = next_obj;\n        }\n    }\n    return (result);\n}\n```\n内存池暂时先按下……\n#### 2.2.10 内存池(memory pool)\n\n### 2.3 内存基本处理工具\nSTL定义了五个全局函数，作用于未初始化化空间上：用于构造的`construct()`和析构的`destroy()`,另外三个是：`uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()`(定于于`<memory>`),分别对应于高层次函数`copy(),fill(),fill_n()`,这些都是STL的算法。\n#### 2.3.1 uninitialized_copy\n#### 2.3.2 uninitialized_fill\n#### 2.3.3 uninitialized_fill_n\n","source":"_posts/浅读《STL源码剖析》笔记-1、2章.md","raw":"---\ntitle: 浅读《STL源码剖析》笔记 1、2章\ndate: 2018-02-03 11:15:06\ntags:\ncategories:\n    - \"learning\"\n---\n## 1 STL概论与版本简介\n### 1.2 STL六大组件\n1. 容器(containers):`vector,list,deque,set,map`,用来存放数据\n2. 算法(algorithms):`sort,search,copy,erase`\n3. 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，<!--more-->迭代器器将`operator*,operator++,operator--,operator->`等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。\n4. 仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。\n5. 配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。\n6. 配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。\n\n### 1.5~1.8 STL版本之二\n1. P.J.Plauger (Microsoft Visual C++)\n2. SGI STL (Linux GCC)\n    C++标准规范下的C头文件: `cstdio,cstdlib,cstring`\n    C++标准程序库中不属于STL范畴: `stream,string`\n    STL标准头文件: `vector,deque,list,map,algorithm,functional`\n    C++Standard定案前，HP所规范的STL头文件: `vector.h,deque.h,list.h,algo.h,function.h`\n    SGI STL内部文件(STL真正实现于此): `stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h`\n\n### 1.9 可能令你困惑的C++语法\n#### 1.9.2 临时对象的产生与运用\n临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。**STL中最常将此技巧用在仿函数(functor)中。**临时对象的生命周期只有这一行指令。\n#### 1.9.3 静态常量整数成员在class内部直接初始化\nclass内含有`const static integral data member`，我们可以直接给予初值。\n```c++\n//1.9.3测试代码如下\ntemplate <typename T>\nclass testclass{\npublic:\n    static const int datai = 5;\n    static const long datal = 3L;\n    static const char datac = 'c';\n};\n\nint main(){\n    cout << testclass<int>::datai << endl;\n    cout << testclass<int>::datal << endl;\n    cout << testclass<int>::datac << endl;\n    return 0;\n}\n```\n运行结果：\n![运行结果](http://p3ax8ersb.bkt.clouddn.com/201801291947_629.png-960.jpg)\n#### 1.9.5 前闭后开区间表示法[)\n**STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。**\n#### 1.9.6 function call操作符(operator())\nfunction call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。**如果你针对某个class进行operator()重载，它就成为一个仿函数。**\n```c++\n//1.9.6测试代码如下\ntemplate <class T>\nstruct Add{\n    //重载了operator()\n    T operator()(const T&x, const T&y) const{\n        return x+y;\n    }\n};\nint main(){\n    Add<int> addxy;\n    system( \"clear\" );\n    //调用重载函数\n    cout << addxy(3,5) << endl;\n    //调用匿名对象\n    cout << Add<int>()(5,5) << endl;\n    return 0;\n}\n```\n运行结果：\n![仿函数](http://p3ax8ersb.bkt.clouddn.com/201801292024_990.png-960.jpg)\n\n## 2 空间配置器(allocator)\n空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。\n### 2.2 具备此配置力的SGI空间配置器\n#### 2.2.1 SGI标准的空间配置器,std::allocator\nSGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：`vector<int,std::allocator<int>>`;SGI STL写法如下：`vector<int, std::aloc>`绝大多数情况下，我们都是使用缺省的空间配置器。\n#### 2.2.2 SGI特殊的空间配置器，std::alloc\nSGI同时也配备了标准空间配置器`std::allocator`，但是这只是对C++的`operator new和operator delete`做了一层封装，效率低下，**SGI并不使用，只是为了向前兼容语法。**\n\n**SGI自身使用的空间配置器是`std::alloc`**一般来说，我们习惯的C++内存操作和释放操作是这样的：\n```c++\nclass Foo{};\nFoo* pf = new Foo;\ndelete pf;\n```\n这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。**为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。**\nSTL的配置器(allocator)定于于`<memory>`，其中包含两个文件,一个是负责内存空间的配置与释放<stl_alloc.h>,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构<stl_construct.h>，定义了全局函数construct()和destroy()。\n\n#### 2.2.3 构造和析构基本工具:construct()和destroy()\nconstruct()的实现如下：\n```c++\n#include <new.h>    //使用placement new 需要这个头文件\ntemplate <class T1, class T2>\ninline void construct(T1* p, const T2& value){\n    new (p) T1(value);  //使用了placement new;调用T1:T1(value);\n}\n```\n代码解释：`construct()`接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，**通过`placement new`实现**。\ndestroy()有两个版本，实现如下:\n```c++\n//第一个版本，接受一个指针\ntemplate <class T>\ninline void destroy(T* pointer){\n    pointer->~T();\n}\n//第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits<>求取最适当的措施。\ntemplate <class ForwardIterator>\ninline void destroy(ForwardIterator first, ForwardIterator last){\n    __destroy(first, last, value_type(first));\n}\n//判断元素的数值型别(value type)是否有 trivial destructor\ntemplate <class ForwardIterator, class T>\ninline void __destroy(ForwardIterator first, ForwardIterator last, T*){\n    typedef typename __type_traits<T>::has_trivial_destructor trivial_destructor;\n    __destroy_aux(first, last, trivial_destructor());\n}\n//如果元素的数值型别(value type)有non-truvial destructor，循环释放\ntemplate <class ForwardIterator>\ninline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type){\n    for( ; first < last; ++first)\n        //调用第一个版本的destroy()\n        destroy(&* first);\n}\n//如果元素的数值型别(value type)有trivial destructor,函数什么也不做\ntemplate <class ForwardIterator, ForwardIterator, __true_type>{\n    inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type){}\n}\n//destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做\ninline void desroy(char*, char*){}\ninline void destroy(wchar_t*,wchar_t*){}\n```\n代码解释：`destroy()`有两个版本，**第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可**。第二个版本接收first和last两个迭代器，准备将`[firat, last)`范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓`trivial destructor`),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，**这里首先利用`value_type()`获得迭代器所指对象的型别，再利用`__type_traits<T>`判断该型别的析构函数是否无关痛痒。若是`(__true_type)`，则什么都不做结束；若不是`(__false_type)`,这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的`destroy()`。**\n\nconstruct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits<>在3.7节。\n![construct()和destroy()图解](http://p3ax8ersb.bkt.clouddn.com/201802011438_654.png-960.jpg)\n\n#### 2.2.4 空间的配置与释放，std::alloc\n对象构造前的空间配置和对象析构后的空间释放，由`<stl_alloc.h>`负责。\n1. 向 system heap 要求空间\n2. 考虑多线程(multi-threads)状态(这里不考虑多线程的情况)\n3. 考虑内存不足时的应变措施\n4. 考虑过多“小型区域”可能造成的内存碎片(fragment)问题\n\n**C++内存配置的基本操作是:`:operator new()`，内存释放的基本操作是`::operator delete()`。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。**\n\n为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，**第一级配置器`(__malloc_alloc_template)`用malloc()和free()，第二级配置器`(__default_alloc_template)`看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池`memory bool`整理方式。**其中具体是开放了第一级配置器还是两级配置器都开放了由__USE_MEALLOC是否定义决定，定义了__USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。\n\n无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口`simple_alloc`，使其能够符合STL的接口规格。\n```c++\ntemplate <class T,class Alloc>\nclass simple_alloc{\npublic:\n    static T* allocate(size_t n){\n        return 0 == n?0 : (T*) Alloc::allocate(n* sizeof (T));\n    }\n    static T* allocate(void){\n        return (T*) Alloc::allocatte(sizeof (T));\n    }\n    static void dallocate(T* p, size_t n){\n        if(0 != n)\n            Alloc::deallocate(p, n*sizeof (T));\n    }\n    static void deallocat(T* p){\n        Alloc::deallocate(p, sizeof (T));\n    }\n};\n```\n内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。\n\n图解如下：\n    第一级配置器和第二级配置器：![第一级配置器和第二级配置器](http://p3ax8ersb.bkt.clouddn.com/201802011620_34.png-960.jpg)\n    包装接口和运用：![包装接口和运用](http://p3ax8ersb.bkt.clouddn.com/201802011647_747.png-960.jpg)\n\n更新时间：2018.02.17\n#### 2.2.5 第一级配置器 __malloc_alloc_template 剖析\n```c++\ntemplate <int inst> //inst 没有用到\nclass __malloc_alloc_template{\nprivate:\n    //处理内存不够的情况\n    //oom: out of memory\n    static void *oom_malloc(size_t);\n    static void *oom_realloc(void*, size_t);\n    static void (* __malloc_alloc_oom_handler)();\n\npublic:\n    //直接调用malloc，free，realloc，只是多了一层封装，使之可以处理内存不够的情况\n    static void* allocate(size_t n){\n        void *result = malloc(n);\n        if(0 == result)\n            result = oom_malloc(n);\n    }\n    static void deallocate(void* p, size_t){\n        free(p);\n    }\n    static void* reallocate(void* p, size_t, size_t new_sz){\n        void* result = realloc(p, new_sz);\n        if(0 = result)\n            result = oom_realloc(p, new_sz);\n            return result;\n    }\n\n    //仿真c++的set_new_handdler()\n    static void(* set_malloc_handler(void(*f)()))(){\n        //被调用的函数__malloc_alloc_oom_handler\n        void(* old)() = __malloc_alloc_oom_handler;\n        __malloc_alloc_oom_handler = f;\n        return (old);\n    }\n    //__malloc_alloc_oom_handler函数初始值是0，该值由客端自己设定\n    template <int inst>\n    void (* __malloc_alloc_template<inst> :: __malloc_alloc_oom_handler)() = 0;\n\n    //oom_malloc\n    template <int inst>\n    void* __malloc_alloc_template<inst> :: oom_malloc(size_t n){\n        void (* my_malloc_handler)();\n        void* result;\n        for(; ;){   //不停的尝试，释放，配置，释放，配置……\n            my_malloc_handler = __malloc_alloc_oom_handler;\n            //如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常\n            if(0 == my_malloc_handler){\n                __THROW_BAD_ALLOC;\n            }\n            (*my_malloc_handler)(); //调用处理例程，企图释放内存\n            result = malloc(n);     //再次配置\n            if(result)\n                return (result);\n        }\n    }\n    //oom_realloc\n    template <int inst>\n    void* __malloc_alloc_template<inst> :: oom_realloc(void* p, size_t n){\n        void (* my_malloc_handler)();\n        void* result;\n        for(; ;){   //不停的尝试，释放，配置，释放，配置……\n            my_malloc_handler = __malloc_alloc_oom_handler;\n            //如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常\n            if(0 == my_malloc_handler){\n                __THROW_BAD_ALLOC;\n            }\n            (*my_malloc_handler)(); //调用处理例程，企图释放内存\n            result = malloc(n);     //再次配置\n            if(result)\n                return (result);\n        }\n    }\n}\n```\n第一级配置器以malloc()、free()、realloc()等C函数执行实际的内存的配置、释放、重配置操作，同时实现出类似C++ new-handler的机制。所谓new-handler就是在系统内存配置需求无法被满足的情况下，调用一个指定的函数。\n#### 2.2.6 第二级配置器__default_alloc_template 剖析\n第二级配置器__default_alloc_template多了些机制，避免太多小额区块造成内存的碎片。\n\n当区块超过128bytes，则用内存池管理，此做法又称为次层配置(sub-allocation)：每次配置一大块内存，并维护对应自由链表(free-lists)。下次如果再有相同大小的内存需求，就直接从free-lists中取出。如果客端释放返还小额区块，就有配置器会受到free-lists中。二级配置器会自动将内存调整为8的倍数，并维护16个free-lists，各自管理8的倍数的小额区块。\n```c++\n//free-list的节点\nunion obj{\n    union obj *free_list_link;\n    char client_data[1];\n}\n```\n其中，obj是一个obj指针，指向下一个相同大小的区块。同时obj是一个指针，指向实际中区块。结合2.2.7的图理解。\n如图：\n![free-lists](http://p3ax8ersb.bkt.clouddn.com/201802171615_46.png-480.jpg)\n#### 2.2.7 空间配置函数allocate()\nallocate()是二级配置器__default_alloc_template的一个标准接口函数。这个函数首先判断区块大小，大于128bytes调用的第一级配置器，小于128bytes的查询对应free-list有可以用的区块，就直接拿来用，如果没有，就将区块大小调至8倍数边界，然后调用refill()，为free list重新填充空间。\n```c++\n//n > 0\nstatic void* allocate(size_t n){\n    //二级指针，但是volatile的用法不详\n    obj* volatile *my_free_list;\n    obj* result;\n\n    if(n>(size_t) __MAX_BYTES){\n        return (malloc_alloc::allocate(n));\n    }\n    //寻找16个free list中适合的一个\n    my_free_list = free_list + FREELIST_INDEX(n);\n    result  = *my_free_list;\n    if(result == 0){\n        //准备填充free list\n        void* r = refill(ROUND_UP(n));\n        return r;\n    }\n    //调整free list\n    *my_free_list = result -> free_list_link;\n    return (result);\n}\n```\n图解如下：\n![freel list 拔出](http://p3ax8ersb.bkt.clouddn.com/201802171658_88.png-480.jpg)\n#### 2.2.8 空间释放函数 deallocate()\ndeallocate()是配置器__default_alloc_template的一个标准接口函数。大于128bytes调用第一级配置器，小于128bytes找到对应的free list将区块回收。\n```c++\n// p不可以是 0\nstatic void deallocate(void *p, size_t n){\n    obj* q = (obj* )p;\n    //二级指针，但是volatile的用法不详\n    obj* volatile *my_free_list;\n\n    if(n>(size_t) __MAX_BYTES){\n        malloc_alloc::deallocate(p, n);\n        return;\n    }\n    //寻找对应的free list\n    my_free_list = free_list + FREELIST_INDEX(n);\n    //调整free list，回收区域\n    q->free_list_link = *my_free_list();\n    *my_free_list = q;\n}\n```\n图解如下：\n![deallocate](http://p3ax8ersb.bkt.clouddn.com/201802171745_127.png-480.jpg)\n#### 2.2.9 重新填充 free lists\nallocate()中，当它发现free list中没有可用区块的时候，调用refill()，为free list重新填充空间。新的空间将取自内存池(chunk_alloc()完成)。缺省获得20个新节点。\n```c++\n//返回一个大小为n的对象，并且有时候会为适当的free list增加节点\n//假设n已经适当上调至8的倍数\ntemplate <bool threads, int inst>\nvoid* __default_alloc_template<threads, inst> :: refill(size_t n){\n    int nobjs = 20; //缺省值\n    //调用chunk_alloc()，尝试获得nobjs个区块作为free list的新节点\n    char* chunk = chunk_alloc(n, nobjs);\n    obj* volatile* my_free_list;\n    obj* result;\n    obj* current_obj, *next_obj;\n    int i;\n    //如果只获得一个区块，这个区块就分配给调用者使用，free list无新节点\n    if(1 == nobjs)\n        return (chunk);\n    //否则调整free list纳入新的节点\n    my_free_list = free_list + FREELIST_INDEX(n)；\n    //以下在chunk空间创建free list\n    result = (obj *)chumk;\n    //以下导引free list 指向新配置的空间(取自内存池)\n    *my_free_list = next_obj = (obj*)(chunk + n);\n    //以下将free list 的各个节点串联起来\n    for(i = 1; ; i++){  //从n == 1开始，因为0号要返回给客端\n        current_obj = next_obj;\n        next_obj = (obj*)((char *)next_obj + n);\n        if(nobjs - 1 == i){\n            current_obj -> free_list_link = 0;\n            break;\n        }\n        else{\n            current_obj->free_list_link = next_obj;\n        }\n    }\n    return (result);\n}\n```\n内存池暂时先按下……\n#### 2.2.10 内存池(memory pool)\n\n### 2.3 内存基本处理工具\nSTL定义了五个全局函数，作用于未初始化化空间上：用于构造的`construct()`和析构的`destroy()`,另外三个是：`uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()`(定于于`<memory>`),分别对应于高层次函数`copy(),fill(),fill_n()`,这些都是STL的算法。\n#### 2.3.1 uninitialized_copy\n#### 2.3.2 uninitialized_fill\n#### 2.3.3 uninitialized_fill_n\n","slug":"浅读《STL源码剖析》笔记-1、2章","published":1,"updated":"2018-03-06T08:44:54.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nr6f001d04d81eqqjwk3","content":"<h2 id=\"1-STL概论与版本简介\"><a href=\"#1-STL概论与版本简介\" class=\"headerlink\" title=\"1 STL概论与版本简介\"></a>1 STL概论与版本简介</h2><h3 id=\"1-2-STL六大组件\"><a href=\"#1-2-STL六大组件\" class=\"headerlink\" title=\"1.2 STL六大组件\"></a>1.2 STL六大组件</h3><ol>\n<li>容器(containers):<code>vector,list,deque,set,map</code>,用来存放数据</li>\n<li>算法(algorithms):<code>sort,search,copy,erase</code></li>\n<li>迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，<a id=\"more\"></a>迭代器器将<code>operator*,operator++,operator--,operator-&gt;</code>等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。</li>\n<li>仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。</li>\n<li>配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。</li>\n<li>配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</li>\n</ol>\n<h3 id=\"1-5-1-8-STL版本之二\"><a href=\"#1-5-1-8-STL版本之二\" class=\"headerlink\" title=\"1.5~1.8 STL版本之二\"></a>1.5~1.8 STL版本之二</h3><ol>\n<li>P.J.Plauger (Microsoft Visual C++)</li>\n<li>SGI STL (Linux GCC)<br> C++标准规范下的C头文件: <code>cstdio,cstdlib,cstring</code><br> C++标准程序库中不属于STL范畴: <code>stream,string</code><br> STL标准头文件: <code>vector,deque,list,map,algorithm,functional</code><br> C++Standard定案前，HP所规范的STL头文件: <code>vector.h,deque.h,list.h,algo.h,function.h</code><br> SGI STL内部文件(STL真正实现于此): <code>stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h</code></li>\n</ol>\n<h3 id=\"1-9-可能令你困惑的C-语法\"><a href=\"#1-9-可能令你困惑的C-语法\" class=\"headerlink\" title=\"1.9 可能令你困惑的C++语法\"></a>1.9 可能令你困惑的C++语法</h3><h4 id=\"1-9-2-临时对象的产生与运用\"><a href=\"#1-9-2-临时对象的产生与运用\" class=\"headerlink\" title=\"1.9.2 临时对象的产生与运用\"></a>1.9.2 临时对象的产生与运用</h4><p>临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。<strong>STL中最常将此技巧用在仿函数(functor)中。</strong>临时对象的生命周期只有这一行指令。</p>\n<h4 id=\"1-9-3-静态常量整数成员在class内部直接初始化\"><a href=\"#1-9-3-静态常量整数成员在class内部直接初始化\" class=\"headerlink\" title=\"1.9.3 静态常量整数成员在class内部直接初始化\"></a>1.9.3 静态常量整数成员在class内部直接初始化</h4><p>class内含有<code>const static integral data member</code>，我们可以直接给予初值。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.9.3测试代码如下</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">testclass</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> datai = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">long</span> datal = <span class=\"number\">3L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> datac = <span class=\"string\">'c'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datai &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datal &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datac &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801291947_629.png-960.jpg\" alt=\"运行结果\"></p>\n<h4 id=\"1-9-5-前闭后开区间表示法\"><a href=\"#1-9-5-前闭后开区间表示法\" class=\"headerlink\" title=\"1.9.5 前闭后开区间表示法[)\"></a>1.9.5 前闭后开区间表示法[)</h4><p><strong>STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。</strong></p>\n<h4 id=\"1-9-6-function-call操作符-operator\"><a href=\"#1-9-6-function-call操作符-operator\" class=\"headerlink\" title=\"1.9.6 function call操作符(operator())\"></a>1.9.6 function call操作符(operator())</h4><p>function call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。<strong>如果你针对某个class进行operator()重载，它就成为一个仿函数。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.9.6测试代码如下</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">Add</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//重载了operator()</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp;x, <span class=\"keyword\">const</span> T&amp;y)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x+y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Add&lt;<span class=\"keyword\">int</span>&gt; addxy;</span><br><span class=\"line\">    system( <span class=\"string\">\"clear\"</span> );</span><br><span class=\"line\">    <span class=\"comment\">//调用重载函数</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; addxy(<span class=\"number\">3</span>,<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//调用匿名对象</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; Add&lt;<span class=\"keyword\">int</span>&gt;()(<span class=\"number\">5</span>,<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801292024_990.png-960.jpg\" alt=\"仿函数\"></p>\n<h2 id=\"2-空间配置器-allocator\"><a href=\"#2-空间配置器-allocator\" class=\"headerlink\" title=\"2 空间配置器(allocator)\"></a>2 空间配置器(allocator)</h2><p>空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。</p>\n<h3 id=\"2-2-具备此配置力的SGI空间配置器\"><a href=\"#2-2-具备此配置力的SGI空间配置器\" class=\"headerlink\" title=\"2.2 具备此配置力的SGI空间配置器\"></a>2.2 具备此配置力的SGI空间配置器</h3><h4 id=\"2-2-1-SGI标准的空间配置器-std-allocator\"><a href=\"#2-2-1-SGI标准的空间配置器-std-allocator\" class=\"headerlink\" title=\"2.2.1 SGI标准的空间配置器,std::allocator\"></a>2.2.1 SGI标准的空间配置器,std::allocator</h4><p>SGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：<code>vector&lt;int,std::allocator&lt;int&gt;&gt;</code>;SGI STL写法如下：<code>vector&lt;int, std::aloc&gt;</code>绝大多数情况下，我们都是使用缺省的空间配置器。</p>\n<h4 id=\"2-2-2-SGI特殊的空间配置器，std-alloc\"><a href=\"#2-2-2-SGI特殊的空间配置器，std-alloc\" class=\"headerlink\" title=\"2.2.2 SGI特殊的空间配置器，std::alloc\"></a>2.2.2 SGI特殊的空间配置器，std::alloc</h4><p>SGI同时也配备了标准空间配置器<code>std::allocator</code>，但是这只是对C++的<code>operator new和operator delete</code>做了一层封装，效率低下，<strong>SGI并不使用，只是为了向前兼容语法。</strong></p>\n<p><strong>SGI自身使用的空间配置器是<code>std::alloc</code></strong>一般来说，我们习惯的C++内存操作和释放操作是这样的：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&#123;</span>&#125;;</span><br><span class=\"line\">Foo* pf = <span class=\"keyword\">new</span> Foo;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> pf;</span><br></pre></td></tr></table></figure></p>\n<p>这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。<strong>为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。</strong><br>STL的配置器(allocator)定于于<code>&lt;memory&gt;</code>，其中包含两个文件,一个是负责内存空间的配置与释放&lt;stl_alloc.h&gt;,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构&lt;stl_construct.h&gt;，定义了全局函数construct()和destroy()。</p>\n<h4 id=\"2-2-3-构造和析构基本工具-construct-和destroy\"><a href=\"#2-2-3-构造和析构基本工具-construct-和destroy\" class=\"headerlink\" title=\"2.2.3 构造和析构基本工具:construct()和destroy()\"></a>2.2.3 构造和析构基本工具:construct()和destroy()</h4><p>construct()的实现如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;new.h&gt;    //使用placement new 需要这个头文件</span></span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>, <span class=\"title\">class</span> <span class=\"title\">T2</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">construct</span>(<span class=\"title\">T1</span>* <span class=\"title\">p</span>, <span class=\"title\">const</span> <span class=\"title\">T2</span>&amp; <span class=\"title\">value</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> (p) T1(value);  <span class=\"comment\">//使用了placement new;调用T1:T1(value);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码解释：<code>construct()</code>接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，<strong>通过<code>placement new</code>实现</strong>。<br>destroy()有两个版本，实现如下:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一个版本，接受一个指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">destroy</span>(<span class=\"title\">T</span>* <span class=\"title\">pointer</span>)&#123;</span></span><br><span class=\"line\">    pointer-&gt;~T();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits&lt;&gt;求取最适当的措施。</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">destroy</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>)&#123;</span></span><br><span class=\"line\">    __destroy(first, last, value_type(first));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//判断元素的数值型别(value type)是否有 trivial destructor</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>, <span class=\"title\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> __<span class=\"title\">destroy</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>, <span class=\"title\">T</span>*)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class=\"line\">    __destroy_aux(first, last, trivial_destructor());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果元素的数值型别(value type)有non-truvial destructor，循环释放</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> __<span class=\"title\">destroy_aux</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>, __<span class=\"title\">false_type</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; first &lt; last; ++first)</span><br><span class=\"line\">        <span class=\"comment\">//调用第一个版本的destroy()</span></span><br><span class=\"line\">        destroy(&amp;* first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果元素的数值型别(value type)有trivial destructor,函数什么也不做</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>, <span class=\"title\">ForwardIterator</span>, __<span class=\"title\">true_type</span>&gt;&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __true_type)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">desroy</span><span class=\"params\">(<span class=\"keyword\">char</span>*, <span class=\"keyword\">char</span>*)</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">(<span class=\"keyword\">wchar_t</span>*,<span class=\"keyword\">wchar_t</span>*)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码解释：<code>destroy()</code>有两个版本，<strong>第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可</strong>。第二个版本接收first和last两个迭代器，准备将<code>[firat, last)</code>范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓<code>trivial destructor</code>),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，<strong>这里首先利用<code>value_type()</code>获得迭代器所指对象的型别，再利用<code>__type_traits&lt;T&gt;</code>判断该型别的析构函数是否无关痛痒。若是<code>(__true_type)</code>，则什么都不做结束；若不是<code>(__false_type)</code>,这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的<code>destroy()</code>。</strong></p>\n<p>construct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits&lt;&gt;在3.7节。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011438_654.png-960.jpg\" alt=\"construct()和destroy()图解\"></p>\n<h4 id=\"2-2-4-空间的配置与释放，std-alloc\"><a href=\"#2-2-4-空间的配置与释放，std-alloc\" class=\"headerlink\" title=\"2.2.4 空间的配置与释放，std::alloc\"></a>2.2.4 空间的配置与释放，std::alloc</h4><p>对象构造前的空间配置和对象析构后的空间释放，由<code>&lt;stl_alloc.h&gt;</code>负责。</p>\n<ol>\n<li>向 system heap 要求空间</li>\n<li>考虑多线程(multi-threads)状态(这里不考虑多线程的情况)</li>\n<li>考虑内存不足时的应变措施</li>\n<li>考虑过多“小型区域”可能造成的内存碎片(fragment)问题</li>\n</ol>\n<p><strong>C++内存配置的基本操作是:<code>:operator new()</code>，内存释放的基本操作是<code>::operator delete()</code>。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。</strong></p>\n<p>为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，<strong>第一级配置器<code>(__malloc_alloc_template)</code>用malloc()和free()，第二级配置器<code>(__default_alloc_template)</code>看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池<code>memory bool</code>整理方式。</strong>其中具体是开放了第一级配置器还是两级配置器都开放了由<strong>USE_MEALLOC是否定义决定，定义了</strong>USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。</p>\n<p>无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口<code>simple_alloc</code>，使其能够符合STL的接口规格。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>,<span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">simple_alloc</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span> == n?<span class=\"number\">0</span> : (T*) Alloc::allocate(n* <span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T*) Alloc::allocatte(<span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dallocate</span><span class=\"params\">(T* p, <span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">0</span> != n)</span><br><span class=\"line\">            Alloc::deallocate(p, n*<span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deallocat</span><span class=\"params\">(T* p)</span></span>&#123;</span><br><span class=\"line\">        Alloc::deallocate(p, <span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。</p>\n<p>图解如下：<br>    第一级配置器和第二级配置器：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011620_34.png-960.jpg\" alt=\"第一级配置器和第二级配置器\"><br>    包装接口和运用：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011647_747.png-960.jpg\" alt=\"包装接口和运用\"></p>\n<p>更新时间：2018.02.17</p>\n<h4 id=\"2-2-5-第一级配置器-malloc-alloc-template-剖析\"><a href=\"#2-2-5-第一级配置器-malloc-alloc-template-剖析\" class=\"headerlink\" title=\"2.2.5 第一级配置器 __malloc_alloc_template 剖析\"></a>2.2.5 第一级配置器 __malloc_alloc_template 剖析</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">int</span> inst&gt; <span class=\"comment\">//inst 没有用到</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> __<span class=\"title\">malloc_alloc_template</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//处理内存不够的情况</span></span><br><span class=\"line\">    <span class=\"comment\">//oom: out of memory</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">oom_malloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">oom_realloc</span><span class=\"params\">(<span class=\"keyword\">void</span>*, <span class=\"keyword\">size_t</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">void</span> <span class=\"params\">(* __malloc_alloc_oom_handler)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//直接调用malloc，free，realloc，只是多了一层封装，使之可以处理内存不够的情况</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span>* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *result = <span class=\"built_in\">malloc</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">0</span> == result)</span><br><span class=\"line\">            result = oom_malloc(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deallocate</span><span class=\"params\">(<span class=\"keyword\">void</span>* p, <span class=\"keyword\">size_t</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span>* <span class=\"title\">reallocate</span><span class=\"params\">(<span class=\"keyword\">void</span>* p, <span class=\"keyword\">size_t</span>, <span class=\"keyword\">size_t</span> new_sz)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span>* result = <span class=\"built_in\">realloc</span>(p, new_sz);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">0</span> = result)</span><br><span class=\"line\">            result = oom_realloc(p, new_sz);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//仿真c++的set_new_handdler()</span></span><br><span class=\"line\">    static void(* set_malloc_handler(void(*f)()))()&#123;</span><br><span class=\"line\">        <span class=\"comment\">//被调用的函数__malloc_alloc_oom_handler</span></span><br><span class=\"line\">        <span class=\"keyword\">void</span>(* old)() = __malloc_alloc_oom_handler;</span><br><span class=\"line\">        __malloc_alloc_oom_handler = f;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (old);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//__malloc_alloc_oom_handler函数初始值是0，该值由客端自己设定</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">int</span> inst&gt;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (* __malloc_alloc_template&lt;inst&gt; :: __malloc_alloc_oom_handler)() = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//oom_malloc</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">int</span> inst&gt;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>* __malloc_alloc_template&lt;inst&gt; :: oom_malloc(<span class=\"keyword\">size_t</span> n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> (* my_malloc_handler)();</span><br><span class=\"line\">        <span class=\"keyword\">void</span>* result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; ;)&#123;   <span class=\"comment\">//不停的尝试，释放，配置，释放，配置……</span></span><br><span class=\"line\">            my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"number\">0</span> == my_malloc_handler)&#123;</span><br><span class=\"line\">                __THROW_BAD_ALLOC;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            (*my_malloc_handler)(); <span class=\"comment\">//调用处理例程，企图释放内存</span></span><br><span class=\"line\">            result = <span class=\"built_in\">malloc</span>(n);     <span class=\"comment\">//再次配置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(result)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//oom_realloc</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">int</span> inst&gt;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>* __malloc_alloc_template&lt;inst&gt; :: oom_realloc(<span class=\"keyword\">void</span>* p, <span class=\"keyword\">size_t</span> n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> (* my_malloc_handler)();</span><br><span class=\"line\">        <span class=\"keyword\">void</span>* result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; ;)&#123;   <span class=\"comment\">//不停的尝试，释放，配置，释放，配置……</span></span><br><span class=\"line\">            my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"number\">0</span> == my_malloc_handler)&#123;</span><br><span class=\"line\">                __THROW_BAD_ALLOC;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            (*my_malloc_handler)(); <span class=\"comment\">//调用处理例程，企图释放内存</span></span><br><span class=\"line\">            result = <span class=\"built_in\">malloc</span>(n);     <span class=\"comment\">//再次配置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(result)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一级配置器以malloc()、free()、realloc()等C函数执行实际的内存的配置、释放、重配置操作，同时实现出类似C++ new-handler的机制。所谓new-handler就是在系统内存配置需求无法被满足的情况下，调用一个指定的函数。</p>\n<h4 id=\"2-2-6-第二级配置器-default-alloc-template-剖析\"><a href=\"#2-2-6-第二级配置器-default-alloc-template-剖析\" class=\"headerlink\" title=\"2.2.6 第二级配置器__default_alloc_template 剖析\"></a>2.2.6 第二级配置器__default_alloc_template 剖析</h4><p>第二级配置器__default_alloc_template多了些机制，避免太多小额区块造成内存的碎片。</p>\n<p>当区块超过128bytes，则用内存池管理，此做法又称为次层配置(sub-allocation)：每次配置一大块内存，并维护对应自由链表(free-lists)。下次如果再有相同大小的内存需求，就直接从free-lists中取出。如果客端释放返还小额区块，就有配置器会受到free-lists中。二级配置器会自动将内存调整为8的倍数，并维护16个free-lists，各自管理8的倍数的小额区块。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//free-list的节点</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> obj&#123;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> obj *free_list_link;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> client_data[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中，obj是一个obj指针，指向下一个相同大小的区块。同时obj是一个指针，指向实际中区块。结合2.2.7的图理解。<br>如图：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802171615_46.png-480.jpg\" alt=\"free-lists\"></p>\n<h4 id=\"2-2-7-空间配置函数allocate\"><a href=\"#2-2-7-空间配置函数allocate\" class=\"headerlink\" title=\"2.2.7 空间配置函数allocate()\"></a>2.2.7 空间配置函数allocate()</h4><p>allocate()是二级配置器__default_alloc_template的一个标准接口函数。这个函数首先判断区块大小，大于128bytes调用的第一级配置器，小于128bytes的查询对应free-list有可以用的区块，就直接拿来用，如果没有，就将区块大小调至8倍数边界，然后调用refill()，为free list重新填充空间。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//n &gt; 0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span>* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//二级指针，但是volatile的用法不详</span></span><br><span class=\"line\">    obj* <span class=\"keyword\">volatile</span> *my_free_list;</span><br><span class=\"line\">    obj* result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&gt;(<span class=\"keyword\">size_t</span>) __MAX_BYTES)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (malloc_alloc::allocate(n));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//寻找16个free list中适合的一个</span></span><br><span class=\"line\">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class=\"line\">    result  = *my_free_list;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//准备填充free list</span></span><br><span class=\"line\">        <span class=\"keyword\">void</span>* r = refill(ROUND_UP(n));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//调整free list</span></span><br><span class=\"line\">    *my_free_list = result -&gt; free_list_link;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>图解如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802171658_88.png-480.jpg\" alt=\"freel list 拔出\"></p>\n<h4 id=\"2-2-8-空间释放函数-deallocate\"><a href=\"#2-2-8-空间释放函数-deallocate\" class=\"headerlink\" title=\"2.2.8 空间释放函数 deallocate()\"></a>2.2.8 空间释放函数 deallocate()</h4><p>deallocate()是配置器__default_alloc_template的一个标准接口函数。大于128bytes调用第一级配置器，小于128bytes找到对应的free list将区块回收。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p不可以是 0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deallocate</span><span class=\"params\">(<span class=\"keyword\">void</span> *p, <span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">    obj* q = (obj* )p;</span><br><span class=\"line\">    <span class=\"comment\">//二级指针，但是volatile的用法不详</span></span><br><span class=\"line\">    obj* <span class=\"keyword\">volatile</span> *my_free_list;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&gt;(<span class=\"keyword\">size_t</span>) __MAX_BYTES)&#123;</span><br><span class=\"line\">        malloc_alloc::deallocate(p, n);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//寻找对应的free list</span></span><br><span class=\"line\">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class=\"line\">    <span class=\"comment\">//调整free list，回收区域</span></span><br><span class=\"line\">    q-&gt;free_list_link = *my_free_list();</span><br><span class=\"line\">    *my_free_list = q;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>图解如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802171745_127.png-480.jpg\" alt=\"deallocate\"></p>\n<h4 id=\"2-2-9-重新填充-free-lists\"><a href=\"#2-2-9-重新填充-free-lists\" class=\"headerlink\" title=\"2.2.9 重新填充 free lists\"></a>2.2.9 重新填充 free lists</h4><p>allocate()中，当它发现free list中没有可用区块的时候，调用refill()，为free list重新填充空间。新的空间将取自内存池(chunk_alloc()完成)。缺省获得20个新节点。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回一个大小为n的对象，并且有时候会为适当的free list增加节点</span></span><br><span class=\"line\"><span class=\"comment\">//假设n已经适当上调至8的倍数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">bool</span> threads, <span class=\"keyword\">int</span> inst&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span>* __default_alloc_template&lt;threads, inst&gt; :: refill(<span class=\"keyword\">size_t</span> n)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nobjs = <span class=\"number\">20</span>; <span class=\"comment\">//缺省值</span></span><br><span class=\"line\">    <span class=\"comment\">//调用chunk_alloc()，尝试获得nobjs个区块作为free list的新节点</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>* chunk = chunk_alloc(n, nobjs);</span><br><span class=\"line\">    obj* <span class=\"keyword\">volatile</span>* my_free_list;</span><br><span class=\"line\">    obj* result;</span><br><span class=\"line\">    obj* current_obj, *next_obj;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"comment\">//如果只获得一个区块，这个区块就分配给调用者使用，free list无新节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">1</span> == nobjs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (chunk);</span><br><span class=\"line\">    <span class=\"comment\">//否则调整free list纳入新的节点</span></span><br><span class=\"line\">    my_free_list = free_list + FREELIST_INDEX(n)；</span><br><span class=\"line\">    <span class=\"comment\">//以下在chunk空间创建free list</span></span><br><span class=\"line\">    result = (obj *)chumk;</span><br><span class=\"line\">    <span class=\"comment\">//以下导引free list 指向新配置的空间(取自内存池)</span></span><br><span class=\"line\">    *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class=\"line\">    <span class=\"comment\">//以下将free list 的各个节点串联起来</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; ; i++)&#123;  <span class=\"comment\">//从n == 1开始，因为0号要返回给客端</span></span><br><span class=\"line\">        current_obj = next_obj;</span><br><span class=\"line\">        next_obj = (obj*)((<span class=\"keyword\">char</span> *)next_obj + n);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nobjs - <span class=\"number\">1</span> == i)&#123;</span><br><span class=\"line\">            current_obj -&gt; free_list_link = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            current_obj-&gt;free_list_link = next_obj;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>内存池暂时先按下……</p>\n<h4 id=\"2-2-10-内存池-memory-pool\"><a href=\"#2-2-10-内存池-memory-pool\" class=\"headerlink\" title=\"2.2.10 内存池(memory pool)\"></a>2.2.10 内存池(memory pool)</h4><h3 id=\"2-3-内存基本处理工具\"><a href=\"#2-3-内存基本处理工具\" class=\"headerlink\" title=\"2.3 内存基本处理工具\"></a>2.3 内存基本处理工具</h3><p>STL定义了五个全局函数，作用于未初始化化空间上：用于构造的<code>construct()</code>和析构的<code>destroy()</code>,另外三个是：<code>uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()</code>(定于于<code>&lt;memory&gt;</code>),分别对应于高层次函数<code>copy(),fill(),fill_n()</code>,这些都是STL的算法。</p>\n<h4 id=\"2-3-1-uninitialized-copy\"><a href=\"#2-3-1-uninitialized-copy\" class=\"headerlink\" title=\"2.3.1 uninitialized_copy\"></a>2.3.1 uninitialized_copy</h4><h4 id=\"2-3-2-uninitialized-fill\"><a href=\"#2-3-2-uninitialized-fill\" class=\"headerlink\" title=\"2.3.2 uninitialized_fill\"></a>2.3.2 uninitialized_fill</h4><h4 id=\"2-3-3-uninitialized-fill-n\"><a href=\"#2-3-3-uninitialized-fill-n\" class=\"headerlink\" title=\"2.3.3 uninitialized_fill_n\"></a>2.3.3 uninitialized_fill_n</h4>","site":{"data":{}},"excerpt":"<h2 id=\"1-STL概论与版本简介\"><a href=\"#1-STL概论与版本简介\" class=\"headerlink\" title=\"1 STL概论与版本简介\"></a>1 STL概论与版本简介</h2><h3 id=\"1-2-STL六大组件\"><a href=\"#1-2-STL六大组件\" class=\"headerlink\" title=\"1.2 STL六大组件\"></a>1.2 STL六大组件</h3><ol>\n<li>容器(containers):<code>vector,list,deque,set,map</code>,用来存放数据</li>\n<li>算法(algorithms):<code>sort,search,copy,erase</code></li>\n<li>迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，","more":"迭代器器将<code>operator*,operator++,operator--,operator-&gt;</code>等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。</li>\n<li>仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。</li>\n<li>配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。</li>\n<li>配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</li>\n</ol>\n<h3 id=\"1-5-1-8-STL版本之二\"><a href=\"#1-5-1-8-STL版本之二\" class=\"headerlink\" title=\"1.5~1.8 STL版本之二\"></a>1.5~1.8 STL版本之二</h3><ol>\n<li>P.J.Plauger (Microsoft Visual C++)</li>\n<li>SGI STL (Linux GCC)<br> C++标准规范下的C头文件: <code>cstdio,cstdlib,cstring</code><br> C++标准程序库中不属于STL范畴: <code>stream,string</code><br> STL标准头文件: <code>vector,deque,list,map,algorithm,functional</code><br> C++Standard定案前，HP所规范的STL头文件: <code>vector.h,deque.h,list.h,algo.h,function.h</code><br> SGI STL内部文件(STL真正实现于此): <code>stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h</code></li>\n</ol>\n<h3 id=\"1-9-可能令你困惑的C-语法\"><a href=\"#1-9-可能令你困惑的C-语法\" class=\"headerlink\" title=\"1.9 可能令你困惑的C++语法\"></a>1.9 可能令你困惑的C++语法</h3><h4 id=\"1-9-2-临时对象的产生与运用\"><a href=\"#1-9-2-临时对象的产生与运用\" class=\"headerlink\" title=\"1.9.2 临时对象的产生与运用\"></a>1.9.2 临时对象的产生与运用</h4><p>临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。<strong>STL中最常将此技巧用在仿函数(functor)中。</strong>临时对象的生命周期只有这一行指令。</p>\n<h4 id=\"1-9-3-静态常量整数成员在class内部直接初始化\"><a href=\"#1-9-3-静态常量整数成员在class内部直接初始化\" class=\"headerlink\" title=\"1.9.3 静态常量整数成员在class内部直接初始化\"></a>1.9.3 静态常量整数成员在class内部直接初始化</h4><p>class内含有<code>const static integral data member</code>，我们可以直接给予初值。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.9.3测试代码如下</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">testclass</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> datai = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">long</span> datal = <span class=\"number\">3L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> datac = <span class=\"string\">'c'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datai &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datal &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; testclass&lt;<span class=\"keyword\">int</span>&gt;::datac &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801291947_629.png-960.jpg\" alt=\"运行结果\"></p>\n<h4 id=\"1-9-5-前闭后开区间表示法\"><a href=\"#1-9-5-前闭后开区间表示法\" class=\"headerlink\" title=\"1.9.5 前闭后开区间表示法[)\"></a>1.9.5 前闭后开区间表示法[)</h4><p><strong>STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。</strong></p>\n<h4 id=\"1-9-6-function-call操作符-operator\"><a href=\"#1-9-6-function-call操作符-operator\" class=\"headerlink\" title=\"1.9.6 function call操作符(operator())\"></a>1.9.6 function call操作符(operator())</h4><p>function call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。<strong>如果你针对某个class进行operator()重载，它就成为一个仿函数。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.9.6测试代码如下</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">Add</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//重载了operator()</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp;x, <span class=\"keyword\">const</span> T&amp;y)</span> <span class=\"keyword\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x+y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Add&lt;<span class=\"keyword\">int</span>&gt; addxy;</span><br><span class=\"line\">    system( <span class=\"string\">\"clear\"</span> );</span><br><span class=\"line\">    <span class=\"comment\">//调用重载函数</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; addxy(<span class=\"number\">3</span>,<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//调用匿名对象</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; Add&lt;<span class=\"keyword\">int</span>&gt;()(<span class=\"number\">5</span>,<span class=\"number\">5</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801292024_990.png-960.jpg\" alt=\"仿函数\"></p>\n<h2 id=\"2-空间配置器-allocator\"><a href=\"#2-空间配置器-allocator\" class=\"headerlink\" title=\"2 空间配置器(allocator)\"></a>2 空间配置器(allocator)</h2><p>空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。</p>\n<h3 id=\"2-2-具备此配置力的SGI空间配置器\"><a href=\"#2-2-具备此配置力的SGI空间配置器\" class=\"headerlink\" title=\"2.2 具备此配置力的SGI空间配置器\"></a>2.2 具备此配置力的SGI空间配置器</h3><h4 id=\"2-2-1-SGI标准的空间配置器-std-allocator\"><a href=\"#2-2-1-SGI标准的空间配置器-std-allocator\" class=\"headerlink\" title=\"2.2.1 SGI标准的空间配置器,std::allocator\"></a>2.2.1 SGI标准的空间配置器,std::allocator</h4><p>SGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：<code>vector&lt;int,std::allocator&lt;int&gt;&gt;</code>;SGI STL写法如下：<code>vector&lt;int, std::aloc&gt;</code>绝大多数情况下，我们都是使用缺省的空间配置器。</p>\n<h4 id=\"2-2-2-SGI特殊的空间配置器，std-alloc\"><a href=\"#2-2-2-SGI特殊的空间配置器，std-alloc\" class=\"headerlink\" title=\"2.2.2 SGI特殊的空间配置器，std::alloc\"></a>2.2.2 SGI特殊的空间配置器，std::alloc</h4><p>SGI同时也配备了标准空间配置器<code>std::allocator</code>，但是这只是对C++的<code>operator new和operator delete</code>做了一层封装，效率低下，<strong>SGI并不使用，只是为了向前兼容语法。</strong></p>\n<p><strong>SGI自身使用的空间配置器是<code>std::alloc</code></strong>一般来说，我们习惯的C++内存操作和释放操作是这样的：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&#123;</span>&#125;;</span><br><span class=\"line\">Foo* pf = <span class=\"keyword\">new</span> Foo;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> pf;</span><br></pre></td></tr></table></figure></p>\n<p>这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。<strong>为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。</strong><br>STL的配置器(allocator)定于于<code>&lt;memory&gt;</code>，其中包含两个文件,一个是负责内存空间的配置与释放&lt;stl_alloc.h&gt;,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构&lt;stl_construct.h&gt;，定义了全局函数construct()和destroy()。</p>\n<h4 id=\"2-2-3-构造和析构基本工具-construct-和destroy\"><a href=\"#2-2-3-构造和析构基本工具-construct-和destroy\" class=\"headerlink\" title=\"2.2.3 构造和析构基本工具:construct()和destroy()\"></a>2.2.3 构造和析构基本工具:construct()和destroy()</h4><p>construct()的实现如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;new.h&gt;    //使用placement new 需要这个头文件</span></span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>, <span class=\"title\">class</span> <span class=\"title\">T2</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">construct</span>(<span class=\"title\">T1</span>* <span class=\"title\">p</span>, <span class=\"title\">const</span> <span class=\"title\">T2</span>&amp; <span class=\"title\">value</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> (p) T1(value);  <span class=\"comment\">//使用了placement new;调用T1:T1(value);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码解释：<code>construct()</code>接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，<strong>通过<code>placement new</code>实现</strong>。<br>destroy()有两个版本，实现如下:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一个版本，接受一个指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">destroy</span>(<span class=\"title\">T</span>* <span class=\"title\">pointer</span>)&#123;</span></span><br><span class=\"line\">    pointer-&gt;~T();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits&lt;&gt;求取最适当的措施。</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> <span class=\"title\">destroy</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>)&#123;</span></span><br><span class=\"line\">    __destroy(first, last, value_type(first));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//判断元素的数值型别(value type)是否有 trivial destructor</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>, <span class=\"title\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> __<span class=\"title\">destroy</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>, <span class=\"title\">T</span>*)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class=\"line\">    __destroy_aux(first, last, trivial_destructor());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果元素的数值型别(value type)有non-truvial destructor，循环释放</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">inline</span> <span class=\"title\">void</span> __<span class=\"title\">destroy_aux</span>(<span class=\"title\">ForwardIterator</span> <span class=\"title\">first</span>, <span class=\"title\">ForwardIterator</span> <span class=\"title\">last</span>, __<span class=\"title\">false_type</span>)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; first &lt; last; ++first)</span><br><span class=\"line\">        <span class=\"comment\">//调用第一个版本的destroy()</span></span><br><span class=\"line\">        destroy(&amp;* first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果元素的数值型别(value type)有trivial destructor,函数什么也不做</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardIterator</span>, <span class=\"title\">ForwardIterator</span>, __<span class=\"title\">true_type</span>&gt;&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __true_type)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">desroy</span><span class=\"params\">(<span class=\"keyword\">char</span>*, <span class=\"keyword\">char</span>*)</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">(<span class=\"keyword\">wchar_t</span>*,<span class=\"keyword\">wchar_t</span>*)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码解释：<code>destroy()</code>有两个版本，<strong>第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可</strong>。第二个版本接收first和last两个迭代器，准备将<code>[firat, last)</code>范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓<code>trivial destructor</code>),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，<strong>这里首先利用<code>value_type()</code>获得迭代器所指对象的型别，再利用<code>__type_traits&lt;T&gt;</code>判断该型别的析构函数是否无关痛痒。若是<code>(__true_type)</code>，则什么都不做结束；若不是<code>(__false_type)</code>,这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的<code>destroy()</code>。</strong></p>\n<p>construct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits&lt;&gt;在3.7节。<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011438_654.png-960.jpg\" alt=\"construct()和destroy()图解\"></p>\n<h4 id=\"2-2-4-空间的配置与释放，std-alloc\"><a href=\"#2-2-4-空间的配置与释放，std-alloc\" class=\"headerlink\" title=\"2.2.4 空间的配置与释放，std::alloc\"></a>2.2.4 空间的配置与释放，std::alloc</h4><p>对象构造前的空间配置和对象析构后的空间释放，由<code>&lt;stl_alloc.h&gt;</code>负责。</p>\n<ol>\n<li>向 system heap 要求空间</li>\n<li>考虑多线程(multi-threads)状态(这里不考虑多线程的情况)</li>\n<li>考虑内存不足时的应变措施</li>\n<li>考虑过多“小型区域”可能造成的内存碎片(fragment)问题</li>\n</ol>\n<p><strong>C++内存配置的基本操作是:<code>:operator new()</code>，内存释放的基本操作是<code>::operator delete()</code>。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。</strong></p>\n<p>为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，<strong>第一级配置器<code>(__malloc_alloc_template)</code>用malloc()和free()，第二级配置器<code>(__default_alloc_template)</code>看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池<code>memory bool</code>整理方式。</strong>其中具体是开放了第一级配置器还是两级配置器都开放了由<strong>USE_MEALLOC是否定义决定，定义了</strong>USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。</p>\n<p>无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口<code>simple_alloc</code>，使其能够符合STL的接口规格。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>,<span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">simple_alloc</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span> == n?<span class=\"number\">0</span> : (T*) Alloc::allocate(n* <span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T*) Alloc::allocatte(<span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dallocate</span><span class=\"params\">(T* p, <span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">0</span> != n)</span><br><span class=\"line\">            Alloc::deallocate(p, n*<span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deallocat</span><span class=\"params\">(T* p)</span></span>&#123;</span><br><span class=\"line\">        Alloc::deallocate(p, <span class=\"keyword\">sizeof</span> (T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。</p>\n<p>图解如下：<br>    第一级配置器和第二级配置器：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011620_34.png-960.jpg\" alt=\"第一级配置器和第二级配置器\"><br>    包装接口和运用：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011647_747.png-960.jpg\" alt=\"包装接口和运用\"></p>\n<p>更新时间：2018.02.17</p>\n<h4 id=\"2-2-5-第一级配置器-malloc-alloc-template-剖析\"><a href=\"#2-2-5-第一级配置器-malloc-alloc-template-剖析\" class=\"headerlink\" title=\"2.2.5 第一级配置器 __malloc_alloc_template 剖析\"></a>2.2.5 第一级配置器 __malloc_alloc_template 剖析</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">int</span> inst&gt; <span class=\"comment\">//inst 没有用到</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> __<span class=\"title\">malloc_alloc_template</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//处理内存不够的情况</span></span><br><span class=\"line\">    <span class=\"comment\">//oom: out of memory</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">oom_malloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">oom_realloc</span><span class=\"params\">(<span class=\"keyword\">void</span>*, <span class=\"keyword\">size_t</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">void</span> <span class=\"params\">(* __malloc_alloc_oom_handler)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//直接调用malloc，free，realloc，只是多了一层封装，使之可以处理内存不够的情况</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span>* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *result = <span class=\"built_in\">malloc</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">0</span> == result)</span><br><span class=\"line\">            result = oom_malloc(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deallocate</span><span class=\"params\">(<span class=\"keyword\">void</span>* p, <span class=\"keyword\">size_t</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span>* <span class=\"title\">reallocate</span><span class=\"params\">(<span class=\"keyword\">void</span>* p, <span class=\"keyword\">size_t</span>, <span class=\"keyword\">size_t</span> new_sz)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span>* result = <span class=\"built_in\">realloc</span>(p, new_sz);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">0</span> = result)</span><br><span class=\"line\">            result = oom_realloc(p, new_sz);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//仿真c++的set_new_handdler()</span></span><br><span class=\"line\">    static void(* set_malloc_handler(void(*f)()))()&#123;</span><br><span class=\"line\">        <span class=\"comment\">//被调用的函数__malloc_alloc_oom_handler</span></span><br><span class=\"line\">        <span class=\"keyword\">void</span>(* old)() = __malloc_alloc_oom_handler;</span><br><span class=\"line\">        __malloc_alloc_oom_handler = f;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (old);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//__malloc_alloc_oom_handler函数初始值是0，该值由客端自己设定</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">int</span> inst&gt;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (* __malloc_alloc_template&lt;inst&gt; :: __malloc_alloc_oom_handler)() = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//oom_malloc</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">int</span> inst&gt;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>* __malloc_alloc_template&lt;inst&gt; :: oom_malloc(<span class=\"keyword\">size_t</span> n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> (* my_malloc_handler)();</span><br><span class=\"line\">        <span class=\"keyword\">void</span>* result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; ;)&#123;   <span class=\"comment\">//不停的尝试，释放，配置，释放，配置……</span></span><br><span class=\"line\">            my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"number\">0</span> == my_malloc_handler)&#123;</span><br><span class=\"line\">                __THROW_BAD_ALLOC;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            (*my_malloc_handler)(); <span class=\"comment\">//调用处理例程，企图释放内存</span></span><br><span class=\"line\">            result = <span class=\"built_in\">malloc</span>(n);     <span class=\"comment\">//再次配置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(result)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//oom_realloc</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">int</span> inst&gt;</span><br><span class=\"line\">    <span class=\"keyword\">void</span>* __malloc_alloc_template&lt;inst&gt; :: oom_realloc(<span class=\"keyword\">void</span>* p, <span class=\"keyword\">size_t</span> n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> (* my_malloc_handler)();</span><br><span class=\"line\">        <span class=\"keyword\">void</span>* result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; ;)&#123;   <span class=\"comment\">//不停的尝试，释放，配置，释放，配置……</span></span><br><span class=\"line\">            my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class=\"line\">            <span class=\"comment\">//如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"number\">0</span> == my_malloc_handler)&#123;</span><br><span class=\"line\">                __THROW_BAD_ALLOC;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            (*my_malloc_handler)(); <span class=\"comment\">//调用处理例程，企图释放内存</span></span><br><span class=\"line\">            result = <span class=\"built_in\">malloc</span>(n);     <span class=\"comment\">//再次配置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(result)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一级配置器以malloc()、free()、realloc()等C函数执行实际的内存的配置、释放、重配置操作，同时实现出类似C++ new-handler的机制。所谓new-handler就是在系统内存配置需求无法被满足的情况下，调用一个指定的函数。</p>\n<h4 id=\"2-2-6-第二级配置器-default-alloc-template-剖析\"><a href=\"#2-2-6-第二级配置器-default-alloc-template-剖析\" class=\"headerlink\" title=\"2.2.6 第二级配置器__default_alloc_template 剖析\"></a>2.2.6 第二级配置器__default_alloc_template 剖析</h4><p>第二级配置器__default_alloc_template多了些机制，避免太多小额区块造成内存的碎片。</p>\n<p>当区块超过128bytes，则用内存池管理，此做法又称为次层配置(sub-allocation)：每次配置一大块内存，并维护对应自由链表(free-lists)。下次如果再有相同大小的内存需求，就直接从free-lists中取出。如果客端释放返还小额区块，就有配置器会受到free-lists中。二级配置器会自动将内存调整为8的倍数，并维护16个free-lists，各自管理8的倍数的小额区块。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//free-list的节点</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> obj&#123;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> obj *free_list_link;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> client_data[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中，obj是一个obj指针，指向下一个相同大小的区块。同时obj是一个指针，指向实际中区块。结合2.2.7的图理解。<br>如图：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802171615_46.png-480.jpg\" alt=\"free-lists\"></p>\n<h4 id=\"2-2-7-空间配置函数allocate\"><a href=\"#2-2-7-空间配置函数allocate\" class=\"headerlink\" title=\"2.2.7 空间配置函数allocate()\"></a>2.2.7 空间配置函数allocate()</h4><p>allocate()是二级配置器__default_alloc_template的一个标准接口函数。这个函数首先判断区块大小，大于128bytes调用的第一级配置器，小于128bytes的查询对应free-list有可以用的区块，就直接拿来用，如果没有，就将区块大小调至8倍数边界，然后调用refill()，为free list重新填充空间。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//n &gt; 0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span>* <span class=\"title\">allocate</span><span class=\"params\">(<span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//二级指针，但是volatile的用法不详</span></span><br><span class=\"line\">    obj* <span class=\"keyword\">volatile</span> *my_free_list;</span><br><span class=\"line\">    obj* result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&gt;(<span class=\"keyword\">size_t</span>) __MAX_BYTES)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (malloc_alloc::allocate(n));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//寻找16个free list中适合的一个</span></span><br><span class=\"line\">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class=\"line\">    result  = *my_free_list;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//准备填充free list</span></span><br><span class=\"line\">        <span class=\"keyword\">void</span>* r = refill(ROUND_UP(n));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//调整free list</span></span><br><span class=\"line\">    *my_free_list = result -&gt; free_list_link;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>图解如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802171658_88.png-480.jpg\" alt=\"freel list 拔出\"></p>\n<h4 id=\"2-2-8-空间释放函数-deallocate\"><a href=\"#2-2-8-空间释放函数-deallocate\" class=\"headerlink\" title=\"2.2.8 空间释放函数 deallocate()\"></a>2.2.8 空间释放函数 deallocate()</h4><p>deallocate()是配置器__default_alloc_template的一个标准接口函数。大于128bytes调用第一级配置器，小于128bytes找到对应的free list将区块回收。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p不可以是 0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deallocate</span><span class=\"params\">(<span class=\"keyword\">void</span> *p, <span class=\"keyword\">size_t</span> n)</span></span>&#123;</span><br><span class=\"line\">    obj* q = (obj* )p;</span><br><span class=\"line\">    <span class=\"comment\">//二级指针，但是volatile的用法不详</span></span><br><span class=\"line\">    obj* <span class=\"keyword\">volatile</span> *my_free_list;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&gt;(<span class=\"keyword\">size_t</span>) __MAX_BYTES)&#123;</span><br><span class=\"line\">        malloc_alloc::deallocate(p, n);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//寻找对应的free list</span></span><br><span class=\"line\">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class=\"line\">    <span class=\"comment\">//调整free list，回收区域</span></span><br><span class=\"line\">    q-&gt;free_list_link = *my_free_list();</span><br><span class=\"line\">    *my_free_list = q;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>图解如下：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802171745_127.png-480.jpg\" alt=\"deallocate\"></p>\n<h4 id=\"2-2-9-重新填充-free-lists\"><a href=\"#2-2-9-重新填充-free-lists\" class=\"headerlink\" title=\"2.2.9 重新填充 free lists\"></a>2.2.9 重新填充 free lists</h4><p>allocate()中，当它发现free list中没有可用区块的时候，调用refill()，为free list重新填充空间。新的空间将取自内存池(chunk_alloc()完成)。缺省获得20个新节点。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回一个大小为n的对象，并且有时候会为适当的free list增加节点</span></span><br><span class=\"line\"><span class=\"comment\">//假设n已经适当上调至8的倍数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">bool</span> threads, <span class=\"keyword\">int</span> inst&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span>* __default_alloc_template&lt;threads, inst&gt; :: refill(<span class=\"keyword\">size_t</span> n)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nobjs = <span class=\"number\">20</span>; <span class=\"comment\">//缺省值</span></span><br><span class=\"line\">    <span class=\"comment\">//调用chunk_alloc()，尝试获得nobjs个区块作为free list的新节点</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>* chunk = chunk_alloc(n, nobjs);</span><br><span class=\"line\">    obj* <span class=\"keyword\">volatile</span>* my_free_list;</span><br><span class=\"line\">    obj* result;</span><br><span class=\"line\">    obj* current_obj, *next_obj;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"comment\">//如果只获得一个区块，这个区块就分配给调用者使用，free list无新节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">1</span> == nobjs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (chunk);</span><br><span class=\"line\">    <span class=\"comment\">//否则调整free list纳入新的节点</span></span><br><span class=\"line\">    my_free_list = free_list + FREELIST_INDEX(n)；</span><br><span class=\"line\">    <span class=\"comment\">//以下在chunk空间创建free list</span></span><br><span class=\"line\">    result = (obj *)chumk;</span><br><span class=\"line\">    <span class=\"comment\">//以下导引free list 指向新配置的空间(取自内存池)</span></span><br><span class=\"line\">    *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class=\"line\">    <span class=\"comment\">//以下将free list 的各个节点串联起来</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; ; i++)&#123;  <span class=\"comment\">//从n == 1开始，因为0号要返回给客端</span></span><br><span class=\"line\">        current_obj = next_obj;</span><br><span class=\"line\">        next_obj = (obj*)((<span class=\"keyword\">char</span> *)next_obj + n);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nobjs - <span class=\"number\">1</span> == i)&#123;</span><br><span class=\"line\">            current_obj -&gt; free_list_link = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            current_obj-&gt;free_list_link = next_obj;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>内存池暂时先按下……</p>\n<h4 id=\"2-2-10-内存池-memory-pool\"><a href=\"#2-2-10-内存池-memory-pool\" class=\"headerlink\" title=\"2.2.10 内存池(memory pool)\"></a>2.2.10 内存池(memory pool)</h4><h3 id=\"2-3-内存基本处理工具\"><a href=\"#2-3-内存基本处理工具\" class=\"headerlink\" title=\"2.3 内存基本处理工具\"></a>2.3 内存基本处理工具</h3><p>STL定义了五个全局函数，作用于未初始化化空间上：用于构造的<code>construct()</code>和析构的<code>destroy()</code>,另外三个是：<code>uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()</code>(定于于<code>&lt;memory&gt;</code>),分别对应于高层次函数<code>copy(),fill(),fill_n()</code>,这些都是STL的算法。</p>\n<h4 id=\"2-3-1-uninitialized-copy\"><a href=\"#2-3-1-uninitialized-copy\" class=\"headerlink\" title=\"2.3.1 uninitialized_copy\"></a>2.3.1 uninitialized_copy</h4><h4 id=\"2-3-2-uninitialized-fill\"><a href=\"#2-3-2-uninitialized-fill\" class=\"headerlink\" title=\"2.3.2 uninitialized_fill\"></a>2.3.2 uninitialized_fill</h4><h4 id=\"2-3-3-uninitialized-fill-n\"><a href=\"#2-3-3-uninitialized-fill-n\" class=\"headerlink\" title=\"2.3.3 uninitialized_fill_n\"></a>2.3.3 uninitialized_fill_n</h4>"},{"title":"浅读《More Effective C++》笔记","date":"2018-01-30T06:27:03.000Z","_content":"## 第一章 基础议题\n### 条款1：区分指针和引用\n**不存在空引用，引用必须要指向某个对象。当确定某个对象不允许有空值，就需要定义为引用，而不是指针。**\n```c++\n//这种做法语法上没有错误，出现了引用为空的情况。但是不同的编译器会有不同的报错。不允许出现这样的代码。\nchar* pc = 0;\nchar &rc = *pc;\n```\n因为不存在空引用这种情况，所以使引用会比指针更高效。\n<!--more-->\n```c++\n//引用不用判空\nvoid print_double(const double& rd){\n    cout << rd;\n}\n//指针要判空\nvoid print_double1(const double *pd){\n    if(pd){ cout << *pd; }\n}\n    ```\n指针可以被重新赋值用以指向另外一个不同的对象，而引用则总是指向初始化时它指向的对象。\n```c++\nstring s1(\"nancy\");\nstring s2(\"clancy\");\nstring& rs = s1;\nstring *ps = &s1;\n//rs依然是s1的引用，此时rs = s1 = s2 = \"clancy\"\nrs = s2;\n//ps指向了s2,不再指向s1\nps = &s2;\n```\n**实现某些操作符的时候，最常见的是[]操作符，绝大多数应该返回引用。**\n```c++\nvector<int> v(10);\n//一般情况下的返回值，此时是引用\nv[5] = 10;\n//如果返回的是指针就需要这样解引用，看起来v就像是一个指针vector一样。\n*v[5] = 10;\n```\n\n### 条款2：优先考虑C++风格的类型转换\n四个类型转换操作符：static_cast,const_cast,dynamic_cast,reinterpret_cast\n\n- **static_cast：作用类似于C中的隐式类型转换，只能转换相近类型的变量。比如struct到int的转换就不能实现。而且在C++中，static_cast并不能将const属性转换为非const属性。**\n- **const_cast：专门用来去除const属性和volatile属性。const_cast被用来用作其他的类型转换会被拒绝。**\n- **dynamic_cast：它是用来针对一个继承体系做向下或者横向的安全转换的。也就是说，用dynamic_cast把指向基类的指针或引用转换成指向派生类或者基类的兄弟类的指针或引用，同时可以知道是否成功。出现空指针(转换指针的时候)或者出现异常(转换引用的时候)意味着失败。他不能用于哪些没有虚函数的类型，也不能去除const属性。**\n- **reinterpret_const：这个操作符，转换结果往往是编译器定义的。因此它几乎是不可以移植的。最常见的用法是在函数指针之间进行类型转换。但是一般我们不使用这种转换，因为c++没有规定这种做法，有可能出现未知的错误，除非万不得已，不然不使用。**\n\n使用格式举例：\n`static_cast<double> (first); const_cast<special*>(first); dynamic_cast<special *>(&first); reinterpret_cast<funcptr> (&dosomething)`\n\n### 条款3：绝不要把多态应用于数组\n继承的一大特性，它允许你通过指向基类的指针和引用来操纵派生类对象。这种指针和引用的行为具有多态性。**同时C++也允许你通过基类指针和引用来操纵派生类数组，但是这个应该不被允许**。见下面这个例子：\n```c++\n//一个BST类，有一个BalancedBST的类，它继承与BST\nclass BST{\n    //...\n};\nclass BalancedBST{\n    //...\n};\n//一个用于打印BST数组中BST元素的函数\nvoid printBSTArray(ostream&s, const BST array[], int numElements){\n    for( int i = 0; i < numElements; ++i ){\n        s << array[i];\n    }\n}\n```\n第一种情况，传递的数组是BST数组，程序没有问题；第二种情况，传递的数组是BalancedBST数组(继承于BST),编译器并不会报错，但是会出现问题，关键在于对array[i]的使用。`array[i]=*(array+i)`，我们知道array是指向数组的首地址的指针，其中array+i偏移的地址是根据元素的大小而定的。因为上例子中，array的类型是BST，所以array[i]的偏移是array+i*sizeof(SBT)。但我们传递了BST的子类BalancedBST给array，这样array的访问就会出现问题。\n\n同时，如果打算通过一个基类指针删除一个包含派生类对象的数组，一样会出现问题。\n```c++\nvoid deleteArray(ostream& logStream, BST array[]){\n    logStream << static_cast<void*>(array) << endl;\n    delete[] array;\n}\nBalancedBST *balTreeArray = new BalancedBST[50];\n//...\ndeleteArray(cout, balTreeArray);\n```\n明面上这里并没有调用指针，但是当删除数组的时候，数组元素的析构函数必须被调用。\n\n### 条款4 避免不必要的默认构造函数\n更新时间：2018.02.19\n默认构造函数指的是在C++语言中，不需要传参数就可以调用的构造函数，用于对象的初始化。但有的时候，我们要求这个对象，必须包含一些特定的值。比如下面例子：\n```c++\nclass EquipmentPiece{\npublic:\n    EquipmentPiece( int IDNumber ){}\n    //...\n};\n```\n此时EquipmentPiece类没有默认的构造函数，有三种情况，对它的应用会出现问题。第一种情况，如下：\n```c++\nEquipmentPiece bestPieces[10];  //没法调用构造函数\nEquipmentPiece *bestPieces = new EquipmentPiece[10];    //没法调用构造函数\n```\n这里有三种方法可以避开这个限制。第一种，对于不在堆上分配内存的数组，在定义数组的时候，提供必要参数。**第二种，不使用对象数组，使用一个指针数组**，如下：\n```c++\ntypedef EquipmentPiece* PEP;\nPEP bestPieces[10];\nPEP *bestPieces = new PEP[10];\n//这样，数值的每一个指针都可以被重新赋值以指向不同的EquipmentPiece对象。\nfor( int i = 0; i < 10; ++i ){\n    bestPieces[i] = new EquipmentPiece( ID Number );\n}\n```\n但是这两种方法有两个缺点，**第一个是，你必须记住删除数组指针所指向的所有对象，不然会出现内存泄漏。第二，这样的方法所需要的内存需求总量会增加，需要额外的空间去存储指针。**\n\n第三种方法，为数组分配原始内存，可以避免额外的内存消耗，利用placement new技术，如下：\n```c++\nvoid * rawMemory = operator new[](10*sizeof(EquipmentPiece));\nEquipmentPiece* bestPieces = static_cast<EquipmentPiece*>(rawMemory);\nfor( int i = 0; i < 10; ++i ){\n    new(bestPieces+i) EquipmentPiece( ID Number );\n}\n```\n这个方法的缺点是，删除的时候，先要手工调用析构函数，然后再手工调用delete[]函数，这样才能够释放原始内存。\n```c++\nfor( int i = 9; i >= 0; --i ){\n    bestPieces[i].~EquipmentPiece();\n}\noperator delete[](rawMemory);\n```\n没有默认构造函数所造成的第二个问题是，他们没有办法作为许多基于模板的容器类的类型参数使用。因为通常用于实例化模板的那些类型需要提供默认构造函数。这个要求大多数时候来自模板内部需要创建关于模板参数类型的数组。例子如下：\n```c++\ntemplate<class T>\nclass Array{\npublic:\n    Array( int size );\nprivate:\n    T* data;\n};\ntemplate <class T>\nArray<T>::Array(int size){\n    date = new T[size];\n}\n```\n在大多数情况下，可以通过谨慎的设计排除对默认构造函数的需要。标准的vector模板就不要求。\n没有默认构造函数的第三个问题是。在有虚基类的时候，到底要不要提供默认构造函数。没有默认构造函数的虚基类使用起来十分痛苦。这是因为虚基类的构造函数所要求的参数必须由被创建对象所属的最远的派生类提供。这样就导致了，没有默认构造函数的虚基类会要求所有由它继承下来的派生类都必须知道、理解虚基类构造函数的参数的含义并提供这些参数。\n## 第二章 运算符\n### 条款5：小心用户自定义的转换函数\nC++允许编译器在两种数据类型之间进行隐式转换，char到int、short到double。甚至会出现数据丢失的也可以，int到char、double到short的转换。\n接下来介绍两种类型函数可以让编译器实施这种隐式转换：单个参数的构造函数和隐式的类型转换运算符。\n**单个参数的构造函数**指的是，只传递给它一个参数就可以调用的构造函数。这种构造函数可以只定义一个参数，也可以定义多个参数。定义多个参数的时候，除了第一个参数，后面的参数应该是有默认值的。例子如下：\n```c++\nclass Name{\npublic:\n    Name(const string& s);\n};\nclass Ratinal{\npublic:\n    Rational(int numerator = 0, int denominator = 1);\n};\n```\n隐式的类型转换运算符只不过是名字看上去比较奇怪的成员函数：在operator关键字后面指定类型。\n\n\n### 条款6：区分自增运算符和自减运算符的前缀形式和后缀形式\n#### 前缀形式和后缀形式的区别\n```c++\nclass UPInt{\npublic:\n    UPInt& operator++();\n    const UPInt operator++(int);\n    UPInt& operator--();\n    const UPInt operator--(int);\n};\n```\n当函数被调用的时候，编译器悄无声息的传递一个0作为int参数的值给该函数。**其中前缀形式返回一个引用，后缀形式返回一个const对象。**\n\n```c++\nUPInt& UPInt::operator++(){\n    *this += 1;\n    return *this;\n}\n\nconst UPInt UPInt::operator++(int){\n    count UPInt oldvalue = *this;\n    //*this += 1;\n    //复用前缀自增\n    ++(*this);\n    return oldvalue;\n}\n```\n#### 后缀形式返回const\n后缀自增形式的返回值是一个const对象，为什么是一个const对象呢？如果不是const对象，那么下面这个代码就是正确的：\n\n```c++\nUPInt i;\ni++++;\n```\n但是很明显这样是不正确的。根据内置类型的性质，当我们自增两次int类型的数据的时候，这个是不允许发生的。\n有一个点需要说明的是，如果不是很必要使用后缀自增的形式，那么尽量使用前缀自增。**因为后缀自增首先需要显示创建一个临时变量，然后返回的时候，还需要创建一个临时对象作为返回。最后结束函数的时候需要析构两者。如果十分在意效率问题，尽量使用前缀自增。**\n最后，为了降低维护成本，后缀自增或自减最好复用前缀自增或自减。这样只需要维护前缀自增或自减即可。\n\n### 条款7：不要重载“ && ”、“ || ”和“ , ”\n#### 短路求值法\nC++使用了**短路求值法**对布尔表达式求值。这个表示，一旦确定了布尔表达式为真或为假，即使还有部分表达式还没有测试，布尔表达式也会停止运算。\n\n```c++\nchar* p;\n//...\nif(p != 0 && strlen(p) > 10)\n    //...\n```\n这里我们永远不需要担心strlen中的p是否为0值，因为p=0的时候，strlen(p)根本就不会进行运算。\n\n#### 不要重载“ && ” 和 “ || ”\n实际上，C++允许我们对`&& ||`进行重载，但是为了保证短路求值法的正确性，我们要确定不要重载`&& ||`这两个运算符。如果重载了`&&`，效果如下：\n\n```\nif(exp1 && exp2)\nif(exp1.operator&&(exp2)\nif(operator(ex1, ex2)\n```\n这样就变成了函数的调用，首先，函数的调用需要求出两个参数的运算结果，这样就不能实现短路求值的功能；其次，函数的调用没有规定先运算哪个参数，有可能是第一个，也有可能是第二个。\n### 不要重载逗号运算符\n逆置一个字符串的例子：\n```c++\nvoid reverse(char s[]){\n    for(int i = 0, j = strlen(s) - 1; i < j; ++i, --j){\n        int c = s[i];\n        s[i] = s[j];\n        s[j] = c;\n    }\n}\n```\n**包含逗号的表达式，首先计算逗号左边的表达式，然后计算右边的表达式；整个表达式返回最右边的表达式的值。**鉴于你完全没有办法模拟这个行为，所以不要重载逗号运算符。\n#### 同时也不要重载以下的运算符\n\n - `.`\n - `.*`\n - `::`\n - `?:`\n - `new delete sizeof typeid`\n - `static_cast dynamic_cast const_cast reinterpret_cast`\n\n### 条款8：理解new和delete在不同情形下的含义\n#### 区分 new 操作符(new operator)和 operator new 函数\n```c++\nstring *ps = new string(\"Memory Management\");\n```\n上面的代码中使用的new 指的是 new 操作符。","source":"_posts/浅读《More-Effective-C-》笔记.md","raw":"---\ntitle: 浅读《More Effective C++》笔记\ndate: 2018-01-30 14:27:03\ntags:\ncategories:\n    - \"learning\"\n---\n## 第一章 基础议题\n### 条款1：区分指针和引用\n**不存在空引用，引用必须要指向某个对象。当确定某个对象不允许有空值，就需要定义为引用，而不是指针。**\n```c++\n//这种做法语法上没有错误，出现了引用为空的情况。但是不同的编译器会有不同的报错。不允许出现这样的代码。\nchar* pc = 0;\nchar &rc = *pc;\n```\n因为不存在空引用这种情况，所以使引用会比指针更高效。\n<!--more-->\n```c++\n//引用不用判空\nvoid print_double(const double& rd){\n    cout << rd;\n}\n//指针要判空\nvoid print_double1(const double *pd){\n    if(pd){ cout << *pd; }\n}\n    ```\n指针可以被重新赋值用以指向另外一个不同的对象，而引用则总是指向初始化时它指向的对象。\n```c++\nstring s1(\"nancy\");\nstring s2(\"clancy\");\nstring& rs = s1;\nstring *ps = &s1;\n//rs依然是s1的引用，此时rs = s1 = s2 = \"clancy\"\nrs = s2;\n//ps指向了s2,不再指向s1\nps = &s2;\n```\n**实现某些操作符的时候，最常见的是[]操作符，绝大多数应该返回引用。**\n```c++\nvector<int> v(10);\n//一般情况下的返回值，此时是引用\nv[5] = 10;\n//如果返回的是指针就需要这样解引用，看起来v就像是一个指针vector一样。\n*v[5] = 10;\n```\n\n### 条款2：优先考虑C++风格的类型转换\n四个类型转换操作符：static_cast,const_cast,dynamic_cast,reinterpret_cast\n\n- **static_cast：作用类似于C中的隐式类型转换，只能转换相近类型的变量。比如struct到int的转换就不能实现。而且在C++中，static_cast并不能将const属性转换为非const属性。**\n- **const_cast：专门用来去除const属性和volatile属性。const_cast被用来用作其他的类型转换会被拒绝。**\n- **dynamic_cast：它是用来针对一个继承体系做向下或者横向的安全转换的。也就是说，用dynamic_cast把指向基类的指针或引用转换成指向派生类或者基类的兄弟类的指针或引用，同时可以知道是否成功。出现空指针(转换指针的时候)或者出现异常(转换引用的时候)意味着失败。他不能用于哪些没有虚函数的类型，也不能去除const属性。**\n- **reinterpret_const：这个操作符，转换结果往往是编译器定义的。因此它几乎是不可以移植的。最常见的用法是在函数指针之间进行类型转换。但是一般我们不使用这种转换，因为c++没有规定这种做法，有可能出现未知的错误，除非万不得已，不然不使用。**\n\n使用格式举例：\n`static_cast<double> (first); const_cast<special*>(first); dynamic_cast<special *>(&first); reinterpret_cast<funcptr> (&dosomething)`\n\n### 条款3：绝不要把多态应用于数组\n继承的一大特性，它允许你通过指向基类的指针和引用来操纵派生类对象。这种指针和引用的行为具有多态性。**同时C++也允许你通过基类指针和引用来操纵派生类数组，但是这个应该不被允许**。见下面这个例子：\n```c++\n//一个BST类，有一个BalancedBST的类，它继承与BST\nclass BST{\n    //...\n};\nclass BalancedBST{\n    //...\n};\n//一个用于打印BST数组中BST元素的函数\nvoid printBSTArray(ostream&s, const BST array[], int numElements){\n    for( int i = 0; i < numElements; ++i ){\n        s << array[i];\n    }\n}\n```\n第一种情况，传递的数组是BST数组，程序没有问题；第二种情况，传递的数组是BalancedBST数组(继承于BST),编译器并不会报错，但是会出现问题，关键在于对array[i]的使用。`array[i]=*(array+i)`，我们知道array是指向数组的首地址的指针，其中array+i偏移的地址是根据元素的大小而定的。因为上例子中，array的类型是BST，所以array[i]的偏移是array+i*sizeof(SBT)。但我们传递了BST的子类BalancedBST给array，这样array的访问就会出现问题。\n\n同时，如果打算通过一个基类指针删除一个包含派生类对象的数组，一样会出现问题。\n```c++\nvoid deleteArray(ostream& logStream, BST array[]){\n    logStream << static_cast<void*>(array) << endl;\n    delete[] array;\n}\nBalancedBST *balTreeArray = new BalancedBST[50];\n//...\ndeleteArray(cout, balTreeArray);\n```\n明面上这里并没有调用指针，但是当删除数组的时候，数组元素的析构函数必须被调用。\n\n### 条款4 避免不必要的默认构造函数\n更新时间：2018.02.19\n默认构造函数指的是在C++语言中，不需要传参数就可以调用的构造函数，用于对象的初始化。但有的时候，我们要求这个对象，必须包含一些特定的值。比如下面例子：\n```c++\nclass EquipmentPiece{\npublic:\n    EquipmentPiece( int IDNumber ){}\n    //...\n};\n```\n此时EquipmentPiece类没有默认的构造函数，有三种情况，对它的应用会出现问题。第一种情况，如下：\n```c++\nEquipmentPiece bestPieces[10];  //没法调用构造函数\nEquipmentPiece *bestPieces = new EquipmentPiece[10];    //没法调用构造函数\n```\n这里有三种方法可以避开这个限制。第一种，对于不在堆上分配内存的数组，在定义数组的时候，提供必要参数。**第二种，不使用对象数组，使用一个指针数组**，如下：\n```c++\ntypedef EquipmentPiece* PEP;\nPEP bestPieces[10];\nPEP *bestPieces = new PEP[10];\n//这样，数值的每一个指针都可以被重新赋值以指向不同的EquipmentPiece对象。\nfor( int i = 0; i < 10; ++i ){\n    bestPieces[i] = new EquipmentPiece( ID Number );\n}\n```\n但是这两种方法有两个缺点，**第一个是，你必须记住删除数组指针所指向的所有对象，不然会出现内存泄漏。第二，这样的方法所需要的内存需求总量会增加，需要额外的空间去存储指针。**\n\n第三种方法，为数组分配原始内存，可以避免额外的内存消耗，利用placement new技术，如下：\n```c++\nvoid * rawMemory = operator new[](10*sizeof(EquipmentPiece));\nEquipmentPiece* bestPieces = static_cast<EquipmentPiece*>(rawMemory);\nfor( int i = 0; i < 10; ++i ){\n    new(bestPieces+i) EquipmentPiece( ID Number );\n}\n```\n这个方法的缺点是，删除的时候，先要手工调用析构函数，然后再手工调用delete[]函数，这样才能够释放原始内存。\n```c++\nfor( int i = 9; i >= 0; --i ){\n    bestPieces[i].~EquipmentPiece();\n}\noperator delete[](rawMemory);\n```\n没有默认构造函数所造成的第二个问题是，他们没有办法作为许多基于模板的容器类的类型参数使用。因为通常用于实例化模板的那些类型需要提供默认构造函数。这个要求大多数时候来自模板内部需要创建关于模板参数类型的数组。例子如下：\n```c++\ntemplate<class T>\nclass Array{\npublic:\n    Array( int size );\nprivate:\n    T* data;\n};\ntemplate <class T>\nArray<T>::Array(int size){\n    date = new T[size];\n}\n```\n在大多数情况下，可以通过谨慎的设计排除对默认构造函数的需要。标准的vector模板就不要求。\n没有默认构造函数的第三个问题是。在有虚基类的时候，到底要不要提供默认构造函数。没有默认构造函数的虚基类使用起来十分痛苦。这是因为虚基类的构造函数所要求的参数必须由被创建对象所属的最远的派生类提供。这样就导致了，没有默认构造函数的虚基类会要求所有由它继承下来的派生类都必须知道、理解虚基类构造函数的参数的含义并提供这些参数。\n## 第二章 运算符\n### 条款5：小心用户自定义的转换函数\nC++允许编译器在两种数据类型之间进行隐式转换，char到int、short到double。甚至会出现数据丢失的也可以，int到char、double到short的转换。\n接下来介绍两种类型函数可以让编译器实施这种隐式转换：单个参数的构造函数和隐式的类型转换运算符。\n**单个参数的构造函数**指的是，只传递给它一个参数就可以调用的构造函数。这种构造函数可以只定义一个参数，也可以定义多个参数。定义多个参数的时候，除了第一个参数，后面的参数应该是有默认值的。例子如下：\n```c++\nclass Name{\npublic:\n    Name(const string& s);\n};\nclass Ratinal{\npublic:\n    Rational(int numerator = 0, int denominator = 1);\n};\n```\n隐式的类型转换运算符只不过是名字看上去比较奇怪的成员函数：在operator关键字后面指定类型。\n\n\n### 条款6：区分自增运算符和自减运算符的前缀形式和后缀形式\n#### 前缀形式和后缀形式的区别\n```c++\nclass UPInt{\npublic:\n    UPInt& operator++();\n    const UPInt operator++(int);\n    UPInt& operator--();\n    const UPInt operator--(int);\n};\n```\n当函数被调用的时候，编译器悄无声息的传递一个0作为int参数的值给该函数。**其中前缀形式返回一个引用，后缀形式返回一个const对象。**\n\n```c++\nUPInt& UPInt::operator++(){\n    *this += 1;\n    return *this;\n}\n\nconst UPInt UPInt::operator++(int){\n    count UPInt oldvalue = *this;\n    //*this += 1;\n    //复用前缀自增\n    ++(*this);\n    return oldvalue;\n}\n```\n#### 后缀形式返回const\n后缀自增形式的返回值是一个const对象，为什么是一个const对象呢？如果不是const对象，那么下面这个代码就是正确的：\n\n```c++\nUPInt i;\ni++++;\n```\n但是很明显这样是不正确的。根据内置类型的性质，当我们自增两次int类型的数据的时候，这个是不允许发生的。\n有一个点需要说明的是，如果不是很必要使用后缀自增的形式，那么尽量使用前缀自增。**因为后缀自增首先需要显示创建一个临时变量，然后返回的时候，还需要创建一个临时对象作为返回。最后结束函数的时候需要析构两者。如果十分在意效率问题，尽量使用前缀自增。**\n最后，为了降低维护成本，后缀自增或自减最好复用前缀自增或自减。这样只需要维护前缀自增或自减即可。\n\n### 条款7：不要重载“ && ”、“ || ”和“ , ”\n#### 短路求值法\nC++使用了**短路求值法**对布尔表达式求值。这个表示，一旦确定了布尔表达式为真或为假，即使还有部分表达式还没有测试，布尔表达式也会停止运算。\n\n```c++\nchar* p;\n//...\nif(p != 0 && strlen(p) > 10)\n    //...\n```\n这里我们永远不需要担心strlen中的p是否为0值，因为p=0的时候，strlen(p)根本就不会进行运算。\n\n#### 不要重载“ && ” 和 “ || ”\n实际上，C++允许我们对`&& ||`进行重载，但是为了保证短路求值法的正确性，我们要确定不要重载`&& ||`这两个运算符。如果重载了`&&`，效果如下：\n\n```\nif(exp1 && exp2)\nif(exp1.operator&&(exp2)\nif(operator(ex1, ex2)\n```\n这样就变成了函数的调用，首先，函数的调用需要求出两个参数的运算结果，这样就不能实现短路求值的功能；其次，函数的调用没有规定先运算哪个参数，有可能是第一个，也有可能是第二个。\n### 不要重载逗号运算符\n逆置一个字符串的例子：\n```c++\nvoid reverse(char s[]){\n    for(int i = 0, j = strlen(s) - 1; i < j; ++i, --j){\n        int c = s[i];\n        s[i] = s[j];\n        s[j] = c;\n    }\n}\n```\n**包含逗号的表达式，首先计算逗号左边的表达式，然后计算右边的表达式；整个表达式返回最右边的表达式的值。**鉴于你完全没有办法模拟这个行为，所以不要重载逗号运算符。\n#### 同时也不要重载以下的运算符\n\n - `.`\n - `.*`\n - `::`\n - `?:`\n - `new delete sizeof typeid`\n - `static_cast dynamic_cast const_cast reinterpret_cast`\n\n### 条款8：理解new和delete在不同情形下的含义\n#### 区分 new 操作符(new operator)和 operator new 函数\n```c++\nstring *ps = new string(\"Memory Management\");\n```\n上面的代码中使用的new 指的是 new 操作符。","slug":"浅读《More-Effective-C-》笔记","published":1,"updated":"2018-03-06T13:52:36.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nr6h001f04d8xkd1w7lc","content":"<h2 id=\"第一章-基础议题\"><a href=\"#第一章-基础议题\" class=\"headerlink\" title=\"第一章 基础议题\"></a>第一章 基础议题</h2><h3 id=\"条款1：区分指针和引用\"><a href=\"#条款1：区分指针和引用\" class=\"headerlink\" title=\"条款1：区分指针和引用\"></a>条款1：区分指针和引用</h3><p><strong>不存在空引用，引用必须要指向某个对象。当确定某个对象不允许有空值，就需要定义为引用，而不是指针。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这种做法语法上没有错误，出现了引用为空的情况。但是不同的编译器会有不同的报错。不允许出现这样的代码。</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>* pc = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> &amp;rc = *pc;</span><br></pre></td></tr></table></figure></p>\n<p>因为不存在空引用这种情况，所以使引用会比指针更高效。<br><a id=\"more\"></a><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引用不用判空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_double</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">double</span>&amp; rd)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; rd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//指针要判空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_double1</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *pd)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pd)&#123; <span class=\"built_in\">cout</span> &lt;&lt; *pd; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>指针可以被重新赋值用以指向另外一个不同的对象，而引用则总是指向初始化时它指向的对象。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">\"nancy\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s2</span><span class=\"params\">(<span class=\"string\">\"clancy\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span>&amp; rs = s1;</span><br><span class=\"line\"><span class=\"built_in\">string</span> *ps = &amp;s1;</span><br><span class=\"line\"><span class=\"comment\">//rs依然是s1的引用，此时rs = s1 = s2 = \"clancy\"</span></span><br><span class=\"line\">rs = s2;</span><br><span class=\"line\"><span class=\"comment\">//ps指向了s2,不再指向s1</span></span><br><span class=\"line\">ps = &amp;s2;</span><br></pre></td></tr></table></figure></p>\n<p><strong>实现某些操作符的时候，最常见的是[]操作符，绝大多数应该返回引用。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">//一般情况下的返回值，此时是引用</span></span><br><span class=\"line\">v[<span class=\"number\">5</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">//如果返回的是指针就需要这样解引用，看起来v就像是一个指针vector一样。</span></span><br><span class=\"line\">*v[<span class=\"number\">5</span>] = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"条款2：优先考虑C-风格的类型转换\"><a href=\"#条款2：优先考虑C-风格的类型转换\" class=\"headerlink\" title=\"条款2：优先考虑C++风格的类型转换\"></a>条款2：优先考虑C++风格的类型转换</h3><p>四个类型转换操作符：static_cast,const_cast,dynamic_cast,reinterpret_cast</p>\n<ul>\n<li><strong>static_cast：作用类似于C中的隐式类型转换，只能转换相近类型的变量。比如struct到int的转换就不能实现。而且在C++中，static_cast并不能将const属性转换为非const属性。</strong></li>\n<li><strong>const_cast：专门用来去除const属性和volatile属性。const_cast被用来用作其他的类型转换会被拒绝。</strong></li>\n<li><strong>dynamic_cast：它是用来针对一个继承体系做向下或者横向的安全转换的。也就是说，用dynamic_cast把指向基类的指针或引用转换成指向派生类或者基类的兄弟类的指针或引用，同时可以知道是否成功。出现空指针(转换指针的时候)或者出现异常(转换引用的时候)意味着失败。他不能用于哪些没有虚函数的类型，也不能去除const属性。</strong></li>\n<li><strong>reinterpret_const：这个操作符，转换结果往往是编译器定义的。因此它几乎是不可以移植的。最常见的用法是在函数指针之间进行类型转换。但是一般我们不使用这种转换，因为c++没有规定这种做法，有可能出现未知的错误，除非万不得已，不然不使用。</strong></li>\n</ul>\n<p>使用格式举例：<br><code>static_cast&lt;double&gt; (first); const_cast&lt;special*&gt;(first); dynamic_cast&lt;special *&gt;(&amp;first); reinterpret_cast&lt;funcptr&gt; (&amp;dosomething)</code></p>\n<h3 id=\"条款3：绝不要把多态应用于数组\"><a href=\"#条款3：绝不要把多态应用于数组\" class=\"headerlink\" title=\"条款3：绝不要把多态应用于数组\"></a>条款3：绝不要把多态应用于数组</h3><p>继承的一大特性，它允许你通过指向基类的指针和引用来操纵派生类对象。这种指针和引用的行为具有多态性。<strong>同时C++也允许你通过基类指针和引用来操纵派生类数组，但是这个应该不被允许</strong>。见下面这个例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一个BST类，有一个BalancedBST的类，它继承与BST</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BST</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BalancedBST</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//一个用于打印BST数组中BST元素的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printBSTArray</span><span class=\"params\">(ostream&amp;s, <span class=\"keyword\">const</span> BST <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> numElements)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numElements; ++i )&#123;</span><br><span class=\"line\">        s &lt;&lt; <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第一种情况，传递的数组是BST数组，程序没有问题；第二种情况，传递的数组是BalancedBST数组(继承于BST),编译器并不会报错，但是会出现问题，关键在于对array[i]的使用。<code>array[i]=*(array+i)</code>，我们知道array是指向数组的首地址的指针，其中array+i偏移的地址是根据元素的大小而定的。因为上例子中，array的类型是BST，所以array[i]的偏移是array+i*sizeof(SBT)。但我们传递了BST的子类BalancedBST给array，这样array的访问就会出现问题。</p>\n<p>同时，如果打算通过一个基类指针删除一个包含派生类对象的数组，一样会出现问题。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteArray</span><span class=\"params\">(ostream&amp; logStream, BST <span class=\"built_in\">array</span>[])</span></span>&#123;</span><br><span class=\"line\">    logStream &lt;&lt; <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">void</span>*&gt;(<span class=\"built_in\">array</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] <span class=\"built_in\">array</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BalancedBST *balTreeArray = <span class=\"keyword\">new</span> BalancedBST[<span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">deleteArray(<span class=\"built_in\">cout</span>, balTreeArray);</span><br></pre></td></tr></table></figure></p>\n<p>明面上这里并没有调用指针，但是当删除数组的时候，数组元素的析构函数必须被调用。</p>\n<h3 id=\"条款4-避免不必要的默认构造函数\"><a href=\"#条款4-避免不必要的默认构造函数\" class=\"headerlink\" title=\"条款4 避免不必要的默认构造函数\"></a>条款4 避免不必要的默认构造函数</h3><p>更新时间：2018.02.19<br>默认构造函数指的是在C++语言中，不需要传参数就可以调用的构造函数，用于对象的初始化。但有的时候，我们要求这个对象，必须包含一些特定的值。比如下面例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EquipmentPiece</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    EquipmentPiece( <span class=\"keyword\">int</span> IDNumber )&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>此时EquipmentPiece类没有默认的构造函数，有三种情况，对它的应用会出现问题。第一种情况，如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EquipmentPiece bestPieces[<span class=\"number\">10</span>];  <span class=\"comment\">//没法调用构造函数</span></span><br><span class=\"line\">EquipmentPiece *bestPieces = <span class=\"keyword\">new</span> EquipmentPiece[<span class=\"number\">10</span>];    <span class=\"comment\">//没法调用构造函数</span></span><br></pre></td></tr></table></figure></p>\n<p>这里有三种方法可以避开这个限制。第一种，对于不在堆上分配内存的数组，在定义数组的时候，提供必要参数。<strong>第二种，不使用对象数组，使用一个指针数组</strong>，如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> EquipmentPiece* PEP;</span><br><span class=\"line\">PEP bestPieces[<span class=\"number\">10</span>];</span><br><span class=\"line\">PEP *bestPieces = <span class=\"keyword\">new</span> PEP[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">//这样，数值的每一个指针都可以被重新赋值以指向不同的EquipmentPiece对象。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i )&#123;</span><br><span class=\"line\">    bestPieces[i] = <span class=\"keyword\">new</span> EquipmentPiece( ID Number );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是这两种方法有两个缺点，<strong>第一个是，你必须记住删除数组指针所指向的所有对象，不然会出现内存泄漏。第二，这样的方法所需要的内存需求总量会增加，需要额外的空间去存储指针。</strong></p>\n<p>第三种方法，为数组分配原始内存，可以避免额外的内存消耗，利用placement new技术，如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> * rawMemory = <span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>[](<span class=\"number\">10</span>*<span class=\"keyword\">sizeof</span>(EquipmentPiece));</span><br><span class=\"line\">EquipmentPiece* bestPieces = <span class=\"keyword\">static_cast</span>&lt;EquipmentPiece*&gt;(rawMemory);</span><br><span class=\"line\"><span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>(bestPieces+i) EquipmentPiece( ID Number );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法的缺点是，删除的时候，先要手工调用析构函数，然后再手工调用delete[]函数，这样才能够释放原始内存。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">9</span>; i &gt;= <span class=\"number\">0</span>; --i )&#123;</span><br><span class=\"line\">    bestPieces[i].~EquipmentPiece();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span>[](rawMemory);</span><br></pre></td></tr></table></figure></p>\n<p>没有默认构造函数所造成的第二个问题是，他们没有办法作为许多基于模板的容器类的类型参数使用。因为通常用于实例化模板的那些类型需要提供默认构造函数。这个要求大多数时候来自模板内部需要创建关于模板参数类型的数组。例子如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Array</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Array( <span class=\"keyword\">int</span> size );</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* data;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Array</span>&lt;T&gt;:</span>:Array(<span class=\"keyword\">int</span> size)&#123;</span><br><span class=\"line\">    date = <span class=\"keyword\">new</span> T[size];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在大多数情况下，可以通过谨慎的设计排除对默认构造函数的需要。标准的vector模板就不要求。<br>没有默认构造函数的第三个问题是。在有虚基类的时候，到底要不要提供默认构造函数。没有默认构造函数的虚基类使用起来十分痛苦。这是因为虚基类的构造函数所要求的参数必须由被创建对象所属的最远的派生类提供。这样就导致了，没有默认构造函数的虚基类会要求所有由它继承下来的派生类都必须知道、理解虚基类构造函数的参数的含义并提供这些参数。</p>\n<h2 id=\"第二章-运算符\"><a href=\"#第二章-运算符\" class=\"headerlink\" title=\"第二章 运算符\"></a>第二章 运算符</h2><h3 id=\"条款5：小心用户自定义的转换函数\"><a href=\"#条款5：小心用户自定义的转换函数\" class=\"headerlink\" title=\"条款5：小心用户自定义的转换函数\"></a>条款5：小心用户自定义的转换函数</h3><p>C++允许编译器在两种数据类型之间进行隐式转换，char到int、short到double。甚至会出现数据丢失的也可以，int到char、double到short的转换。<br>接下来介绍两种类型函数可以让编译器实施这种隐式转换：单个参数的构造函数和隐式的类型转换运算符。<br><strong>单个参数的构造函数</strong>指的是，只传递给它一个参数就可以调用的构造函数。这种构造函数可以只定义一个参数，也可以定义多个参数。定义多个参数的时候，除了第一个参数，后面的参数应该是有默认值的。例子如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Name</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Name(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; s);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ratinal</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Rational(<span class=\"keyword\">int</span> numerator = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> denominator = <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>隐式的类型转换运算符只不过是名字看上去比较奇怪的成员函数：在operator关键字后面指定类型。</p>\n<h3 id=\"条款6：区分自增运算符和自减运算符的前缀形式和后缀形式\"><a href=\"#条款6：区分自增运算符和自减运算符的前缀形式和后缀形式\" class=\"headerlink\" title=\"条款6：区分自增运算符和自减运算符的前缀形式和后缀形式\"></a>条款6：区分自增运算符和自减运算符的前缀形式和后缀形式</h3><h4 id=\"前缀形式和后缀形式的区别\"><a href=\"#前缀形式和后缀形式的区别\" class=\"headerlink\" title=\"前缀形式和后缀形式的区别\"></a>前缀形式和后缀形式的区别</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UPInt</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    UPInt&amp; <span class=\"keyword\">operator</span>++();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> UPInt <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">    UPInt&amp; <span class=\"keyword\">operator</span>--();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> UPInt <span class=\"keyword\">operator</span>--(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当函数被调用的时候，编译器悄无声息的传递一个0作为int参数的值给该函数。<strong>其中前缀形式返回一个引用，后缀形式返回一个const对象。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPInt&amp; UPInt::<span class=\"keyword\">operator</span>++()&#123;</span><br><span class=\"line\">    *<span class=\"keyword\">this</span> += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> UPInt UPInt::<span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)&#123;</span><br><span class=\"line\">    count UPInt oldvalue = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">//*this += 1;</span></span><br><span class=\"line\">    <span class=\"comment\">//复用前缀自增</span></span><br><span class=\"line\">    ++(*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldvalue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"后缀形式返回const\"><a href=\"#后缀形式返回const\" class=\"headerlink\" title=\"后缀形式返回const\"></a>后缀形式返回const</h4><p>后缀自增形式的返回值是一个const对象，为什么是一个const对象呢？如果不是const对象，那么下面这个代码就是正确的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPInt i;</span><br><span class=\"line\">i++++;</span><br></pre></td></tr></table></figure>\n<p>但是很明显这样是不正确的。根据内置类型的性质，当我们自增两次int类型的数据的时候，这个是不允许发生的。<br>有一个点需要说明的是，如果不是很必要使用后缀自增的形式，那么尽量使用前缀自增。<strong>因为后缀自增首先需要显示创建一个临时变量，然后返回的时候，还需要创建一个临时对象作为返回。最后结束函数的时候需要析构两者。如果十分在意效率问题，尽量使用前缀自增。</strong><br>最后，为了降低维护成本，后缀自增或自减最好复用前缀自增或自减。这样只需要维护前缀自增或自减即可。</p>\n<h3 id=\"条款7：不要重载“-amp-amp-”、“-”和“-”\"><a href=\"#条款7：不要重载“-amp-amp-”、“-”和“-”\" class=\"headerlink\" title=\"条款7：不要重载“ &amp;&amp; ”、“ || ”和“ , ”\"></a>条款7：不要重载“ &amp;&amp; ”、“ || ”和“ , ”</h3><h4 id=\"短路求值法\"><a href=\"#短路求值法\" class=\"headerlink\" title=\"短路求值法\"></a>短路求值法</h4><p>C++使用了<strong>短路求值法</strong>对布尔表达式求值。这个表示，一旦确定了布尔表达式为真或为假，即使还有部分表达式还没有测试，布尔表达式也会停止运算。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* p;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(p != <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">strlen</span>(p) &gt; <span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n<p>这里我们永远不需要担心strlen中的p是否为0值，因为p=0的时候，strlen(p)根本就不会进行运算。</p>\n<h4 id=\"不要重载“-amp-amp-”-和-“-”\"><a href=\"#不要重载“-amp-amp-”-和-“-”\" class=\"headerlink\" title=\"不要重载“ &amp;&amp; ” 和 “ || ”\"></a>不要重载“ &amp;&amp; ” 和 “ || ”</h4><p>实际上，C++允许我们对<code>&amp;&amp; ||</code>进行重载，但是为了保证短路求值法的正确性，我们要确定不要重载<code>&amp;&amp; ||</code>这两个运算符。如果重载了<code>&amp;&amp;</code>，效果如下：</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(<span class=\"name\">exp1</span> <span class=\"symbol\">&amp;&amp;</span> exp2)</span><br><span class=\"line\">if(<span class=\"name\">exp1</span>.operator&amp;&amp;(<span class=\"name\">exp2</span>)</span><br><span class=\"line\">if(<span class=\"name\">operator</span>(<span class=\"name\">ex1</span>, ex2)</span><br></pre></td></tr></table></figure>\n<p>这样就变成了函数的调用，首先，函数的调用需要求出两个参数的运算结果，这样就不能实现短路求值的功能；其次，函数的调用没有规定先运算哪个参数，有可能是第一个，也有可能是第二个。</p>\n<h3 id=\"不要重载逗号运算符\"><a href=\"#不要重载逗号运算符\" class=\"headerlink\" title=\"不要重载逗号运算符\"></a>不要重载逗号运算符</h3><p>逆置一个字符串的例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">char</span> s[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"built_in\">strlen</span>(s) - <span class=\"number\">1</span>; i &lt; j; ++i, --j)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = s[i];</span><br><span class=\"line\">        s[i] = s[j];</span><br><span class=\"line\">        s[j] = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>包含逗号的表达式，首先计算逗号左边的表达式，然后计算右边的表达式；整个表达式返回最右边的表达式的值。</strong>鉴于你完全没有办法模拟这个行为，所以不要重载逗号运算符。</p>\n<h4 id=\"同时也不要重载以下的运算符\"><a href=\"#同时也不要重载以下的运算符\" class=\"headerlink\" title=\"同时也不要重载以下的运算符\"></a>同时也不要重载以下的运算符</h4><ul>\n<li><code>.</code></li>\n<li><code>.*</code></li>\n<li><code>::</code></li>\n<li><code>?:</code></li>\n<li><code>new delete sizeof typeid</code></li>\n<li><code>static_cast dynamic_cast const_cast reinterpret_cast</code></li>\n</ul>\n<h3 id=\"条款8：理解new和delete在不同情形下的含义\"><a href=\"#条款8：理解new和delete在不同情形下的含义\" class=\"headerlink\" title=\"条款8：理解new和delete在不同情形下的含义\"></a>条款8：理解new和delete在不同情形下的含义</h3><h4 id=\"区分-new-操作符-new-operator-和-operator-new-函数\"><a href=\"#区分-new-操作符-new-operator-和-operator-new-函数\" class=\"headerlink\" title=\"区分 new 操作符(new operator)和 operator new 函数\"></a>区分 new 操作符(new operator)和 operator new 函数</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> *ps = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"string\">\"Memory Management\"</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码中使用的new 指的是 new 操作符。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"第一章-基础议题\"><a href=\"#第一章-基础议题\" class=\"headerlink\" title=\"第一章 基础议题\"></a>第一章 基础议题</h2><h3 id=\"条款1：区分指针和引用\"><a href=\"#条款1：区分指针和引用\" class=\"headerlink\" title=\"条款1：区分指针和引用\"></a>条款1：区分指针和引用</h3><p><strong>不存在空引用，引用必须要指向某个对象。当确定某个对象不允许有空值，就需要定义为引用，而不是指针。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这种做法语法上没有错误，出现了引用为空的情况。但是不同的编译器会有不同的报错。不允许出现这样的代码。</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>* pc = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> &amp;rc = *pc;</span><br></pre></td></tr></table></figure></p>\n<p>因为不存在空引用这种情况，所以使引用会比指针更高效。<br>","more":"<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引用不用判空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_double</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">double</span>&amp; rd)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; rd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//指针要判空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_double1</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *pd)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pd)&#123; <span class=\"built_in\">cout</span> &lt;&lt; *pd; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>指针可以被重新赋值用以指向另外一个不同的对象，而引用则总是指向初始化时它指向的对象。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">\"nancy\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s2</span><span class=\"params\">(<span class=\"string\">\"clancy\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span>&amp; rs = s1;</span><br><span class=\"line\"><span class=\"built_in\">string</span> *ps = &amp;s1;</span><br><span class=\"line\"><span class=\"comment\">//rs依然是s1的引用，此时rs = s1 = s2 = \"clancy\"</span></span><br><span class=\"line\">rs = s2;</span><br><span class=\"line\"><span class=\"comment\">//ps指向了s2,不再指向s1</span></span><br><span class=\"line\">ps = &amp;s2;</span><br></pre></td></tr></table></figure></p>\n<p><strong>实现某些操作符的时候，最常见的是[]操作符，绝大多数应该返回引用。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">//一般情况下的返回值，此时是引用</span></span><br><span class=\"line\">v[<span class=\"number\">5</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">//如果返回的是指针就需要这样解引用，看起来v就像是一个指针vector一样。</span></span><br><span class=\"line\">*v[<span class=\"number\">5</span>] = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"条款2：优先考虑C-风格的类型转换\"><a href=\"#条款2：优先考虑C-风格的类型转换\" class=\"headerlink\" title=\"条款2：优先考虑C++风格的类型转换\"></a>条款2：优先考虑C++风格的类型转换</h3><p>四个类型转换操作符：static_cast,const_cast,dynamic_cast,reinterpret_cast</p>\n<ul>\n<li><strong>static_cast：作用类似于C中的隐式类型转换，只能转换相近类型的变量。比如struct到int的转换就不能实现。而且在C++中，static_cast并不能将const属性转换为非const属性。</strong></li>\n<li><strong>const_cast：专门用来去除const属性和volatile属性。const_cast被用来用作其他的类型转换会被拒绝。</strong></li>\n<li><strong>dynamic_cast：它是用来针对一个继承体系做向下或者横向的安全转换的。也就是说，用dynamic_cast把指向基类的指针或引用转换成指向派生类或者基类的兄弟类的指针或引用，同时可以知道是否成功。出现空指针(转换指针的时候)或者出现异常(转换引用的时候)意味着失败。他不能用于哪些没有虚函数的类型，也不能去除const属性。</strong></li>\n<li><strong>reinterpret_const：这个操作符，转换结果往往是编译器定义的。因此它几乎是不可以移植的。最常见的用法是在函数指针之间进行类型转换。但是一般我们不使用这种转换，因为c++没有规定这种做法，有可能出现未知的错误，除非万不得已，不然不使用。</strong></li>\n</ul>\n<p>使用格式举例：<br><code>static_cast&lt;double&gt; (first); const_cast&lt;special*&gt;(first); dynamic_cast&lt;special *&gt;(&amp;first); reinterpret_cast&lt;funcptr&gt; (&amp;dosomething)</code></p>\n<h3 id=\"条款3：绝不要把多态应用于数组\"><a href=\"#条款3：绝不要把多态应用于数组\" class=\"headerlink\" title=\"条款3：绝不要把多态应用于数组\"></a>条款3：绝不要把多态应用于数组</h3><p>继承的一大特性，它允许你通过指向基类的指针和引用来操纵派生类对象。这种指针和引用的行为具有多态性。<strong>同时C++也允许你通过基类指针和引用来操纵派生类数组，但是这个应该不被允许</strong>。见下面这个例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一个BST类，有一个BalancedBST的类，它继承与BST</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BST</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BalancedBST</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//一个用于打印BST数组中BST元素的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printBSTArray</span><span class=\"params\">(ostream&amp;s, <span class=\"keyword\">const</span> BST <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> numElements)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numElements; ++i )&#123;</span><br><span class=\"line\">        s &lt;&lt; <span class=\"built_in\">array</span>[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第一种情况，传递的数组是BST数组，程序没有问题；第二种情况，传递的数组是BalancedBST数组(继承于BST),编译器并不会报错，但是会出现问题，关键在于对array[i]的使用。<code>array[i]=*(array+i)</code>，我们知道array是指向数组的首地址的指针，其中array+i偏移的地址是根据元素的大小而定的。因为上例子中，array的类型是BST，所以array[i]的偏移是array+i*sizeof(SBT)。但我们传递了BST的子类BalancedBST给array，这样array的访问就会出现问题。</p>\n<p>同时，如果打算通过一个基类指针删除一个包含派生类对象的数组，一样会出现问题。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteArray</span><span class=\"params\">(ostream&amp; logStream, BST <span class=\"built_in\">array</span>[])</span></span>&#123;</span><br><span class=\"line\">    logStream &lt;&lt; <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">void</span>*&gt;(<span class=\"built_in\">array</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] <span class=\"built_in\">array</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BalancedBST *balTreeArray = <span class=\"keyword\">new</span> BalancedBST[<span class=\"number\">50</span>];</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">deleteArray(<span class=\"built_in\">cout</span>, balTreeArray);</span><br></pre></td></tr></table></figure></p>\n<p>明面上这里并没有调用指针，但是当删除数组的时候，数组元素的析构函数必须被调用。</p>\n<h3 id=\"条款4-避免不必要的默认构造函数\"><a href=\"#条款4-避免不必要的默认构造函数\" class=\"headerlink\" title=\"条款4 避免不必要的默认构造函数\"></a>条款4 避免不必要的默认构造函数</h3><p>更新时间：2018.02.19<br>默认构造函数指的是在C++语言中，不需要传参数就可以调用的构造函数，用于对象的初始化。但有的时候，我们要求这个对象，必须包含一些特定的值。比如下面例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EquipmentPiece</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    EquipmentPiece( <span class=\"keyword\">int</span> IDNumber )&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>此时EquipmentPiece类没有默认的构造函数，有三种情况，对它的应用会出现问题。第一种情况，如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EquipmentPiece bestPieces[<span class=\"number\">10</span>];  <span class=\"comment\">//没法调用构造函数</span></span><br><span class=\"line\">EquipmentPiece *bestPieces = <span class=\"keyword\">new</span> EquipmentPiece[<span class=\"number\">10</span>];    <span class=\"comment\">//没法调用构造函数</span></span><br></pre></td></tr></table></figure></p>\n<p>这里有三种方法可以避开这个限制。第一种，对于不在堆上分配内存的数组，在定义数组的时候，提供必要参数。<strong>第二种，不使用对象数组，使用一个指针数组</strong>，如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> EquipmentPiece* PEP;</span><br><span class=\"line\">PEP bestPieces[<span class=\"number\">10</span>];</span><br><span class=\"line\">PEP *bestPieces = <span class=\"keyword\">new</span> PEP[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">//这样，数值的每一个指针都可以被重新赋值以指向不同的EquipmentPiece对象。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i )&#123;</span><br><span class=\"line\">    bestPieces[i] = <span class=\"keyword\">new</span> EquipmentPiece( ID Number );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是这两种方法有两个缺点，<strong>第一个是，你必须记住删除数组指针所指向的所有对象，不然会出现内存泄漏。第二，这样的方法所需要的内存需求总量会增加，需要额外的空间去存储指针。</strong></p>\n<p>第三种方法，为数组分配原始内存，可以避免额外的内存消耗，利用placement new技术，如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> * rawMemory = <span class=\"keyword\">operator</span> <span class=\"keyword\">new</span>[](<span class=\"number\">10</span>*<span class=\"keyword\">sizeof</span>(EquipmentPiece));</span><br><span class=\"line\">EquipmentPiece* bestPieces = <span class=\"keyword\">static_cast</span>&lt;EquipmentPiece*&gt;(rawMemory);</span><br><span class=\"line\"><span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span>(bestPieces+i) EquipmentPiece( ID Number );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个方法的缺点是，删除的时候，先要手工调用析构函数，然后再手工调用delete[]函数，这样才能够释放原始内存。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">9</span>; i &gt;= <span class=\"number\">0</span>; --i )&#123;</span><br><span class=\"line\">    bestPieces[i].~EquipmentPiece();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">operator</span> <span class=\"keyword\">delete</span>[](rawMemory);</span><br></pre></td></tr></table></figure></p>\n<p>没有默认构造函数所造成的第二个问题是，他们没有办法作为许多基于模板的容器类的类型参数使用。因为通常用于实例化模板的那些类型需要提供默认构造函数。这个要求大多数时候来自模板内部需要创建关于模板参数类型的数组。例子如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Array</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Array( <span class=\"keyword\">int</span> size );</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* data;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Array</span>&lt;T&gt;:</span>:Array(<span class=\"keyword\">int</span> size)&#123;</span><br><span class=\"line\">    date = <span class=\"keyword\">new</span> T[size];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在大多数情况下，可以通过谨慎的设计排除对默认构造函数的需要。标准的vector模板就不要求。<br>没有默认构造函数的第三个问题是。在有虚基类的时候，到底要不要提供默认构造函数。没有默认构造函数的虚基类使用起来十分痛苦。这是因为虚基类的构造函数所要求的参数必须由被创建对象所属的最远的派生类提供。这样就导致了，没有默认构造函数的虚基类会要求所有由它继承下来的派生类都必须知道、理解虚基类构造函数的参数的含义并提供这些参数。</p>\n<h2 id=\"第二章-运算符\"><a href=\"#第二章-运算符\" class=\"headerlink\" title=\"第二章 运算符\"></a>第二章 运算符</h2><h3 id=\"条款5：小心用户自定义的转换函数\"><a href=\"#条款5：小心用户自定义的转换函数\" class=\"headerlink\" title=\"条款5：小心用户自定义的转换函数\"></a>条款5：小心用户自定义的转换函数</h3><p>C++允许编译器在两种数据类型之间进行隐式转换，char到int、short到double。甚至会出现数据丢失的也可以，int到char、double到short的转换。<br>接下来介绍两种类型函数可以让编译器实施这种隐式转换：单个参数的构造函数和隐式的类型转换运算符。<br><strong>单个参数的构造函数</strong>指的是，只传递给它一个参数就可以调用的构造函数。这种构造函数可以只定义一个参数，也可以定义多个参数。定义多个参数的时候，除了第一个参数，后面的参数应该是有默认值的。例子如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Name</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Name(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; s);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ratinal</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Rational(<span class=\"keyword\">int</span> numerator = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> denominator = <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>隐式的类型转换运算符只不过是名字看上去比较奇怪的成员函数：在operator关键字后面指定类型。</p>\n<h3 id=\"条款6：区分自增运算符和自减运算符的前缀形式和后缀形式\"><a href=\"#条款6：区分自增运算符和自减运算符的前缀形式和后缀形式\" class=\"headerlink\" title=\"条款6：区分自增运算符和自减运算符的前缀形式和后缀形式\"></a>条款6：区分自增运算符和自减运算符的前缀形式和后缀形式</h3><h4 id=\"前缀形式和后缀形式的区别\"><a href=\"#前缀形式和后缀形式的区别\" class=\"headerlink\" title=\"前缀形式和后缀形式的区别\"></a>前缀形式和后缀形式的区别</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UPInt</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    UPInt&amp; <span class=\"keyword\">operator</span>++();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> UPInt <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">    UPInt&amp; <span class=\"keyword\">operator</span>--();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> UPInt <span class=\"keyword\">operator</span>--(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当函数被调用的时候，编译器悄无声息的传递一个0作为int参数的值给该函数。<strong>其中前缀形式返回一个引用，后缀形式返回一个const对象。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPInt&amp; UPInt::<span class=\"keyword\">operator</span>++()&#123;</span><br><span class=\"line\">    *<span class=\"keyword\">this</span> += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> UPInt UPInt::<span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)&#123;</span><br><span class=\"line\">    count UPInt oldvalue = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">//*this += 1;</span></span><br><span class=\"line\">    <span class=\"comment\">//复用前缀自增</span></span><br><span class=\"line\">    ++(*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldvalue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"后缀形式返回const\"><a href=\"#后缀形式返回const\" class=\"headerlink\" title=\"后缀形式返回const\"></a>后缀形式返回const</h4><p>后缀自增形式的返回值是一个const对象，为什么是一个const对象呢？如果不是const对象，那么下面这个代码就是正确的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPInt i;</span><br><span class=\"line\">i++++;</span><br></pre></td></tr></table></figure>\n<p>但是很明显这样是不正确的。根据内置类型的性质，当我们自增两次int类型的数据的时候，这个是不允许发生的。<br>有一个点需要说明的是，如果不是很必要使用后缀自增的形式，那么尽量使用前缀自增。<strong>因为后缀自增首先需要显示创建一个临时变量，然后返回的时候，还需要创建一个临时对象作为返回。最后结束函数的时候需要析构两者。如果十分在意效率问题，尽量使用前缀自增。</strong><br>最后，为了降低维护成本，后缀自增或自减最好复用前缀自增或自减。这样只需要维护前缀自增或自减即可。</p>\n<h3 id=\"条款7：不要重载“-amp-amp-”、“-”和“-”\"><a href=\"#条款7：不要重载“-amp-amp-”、“-”和“-”\" class=\"headerlink\" title=\"条款7：不要重载“ &amp;&amp; ”、“ || ”和“ , ”\"></a>条款7：不要重载“ &amp;&amp; ”、“ || ”和“ , ”</h3><h4 id=\"短路求值法\"><a href=\"#短路求值法\" class=\"headerlink\" title=\"短路求值法\"></a>短路求值法</h4><p>C++使用了<strong>短路求值法</strong>对布尔表达式求值。这个表示，一旦确定了布尔表达式为真或为假，即使还有部分表达式还没有测试，布尔表达式也会停止运算。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* p;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(p != <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">strlen</span>(p) &gt; <span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n<p>这里我们永远不需要担心strlen中的p是否为0值，因为p=0的时候，strlen(p)根本就不会进行运算。</p>\n<h4 id=\"不要重载“-amp-amp-”-和-“-”\"><a href=\"#不要重载“-amp-amp-”-和-“-”\" class=\"headerlink\" title=\"不要重载“ &amp;&amp; ” 和 “ || ”\"></a>不要重载“ &amp;&amp; ” 和 “ || ”</h4><p>实际上，C++允许我们对<code>&amp;&amp; ||</code>进行重载，但是为了保证短路求值法的正确性，我们要确定不要重载<code>&amp;&amp; ||</code>这两个运算符。如果重载了<code>&amp;&amp;</code>，效果如下：</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(<span class=\"name\">exp1</span> <span class=\"symbol\">&amp;&amp;</span> exp2)</span><br><span class=\"line\">if(<span class=\"name\">exp1</span>.operator&amp;&amp;(<span class=\"name\">exp2</span>)</span><br><span class=\"line\">if(<span class=\"name\">operator</span>(<span class=\"name\">ex1</span>, ex2)</span><br></pre></td></tr></table></figure>\n<p>这样就变成了函数的调用，首先，函数的调用需要求出两个参数的运算结果，这样就不能实现短路求值的功能；其次，函数的调用没有规定先运算哪个参数，有可能是第一个，也有可能是第二个。</p>\n<h3 id=\"不要重载逗号运算符\"><a href=\"#不要重载逗号运算符\" class=\"headerlink\" title=\"不要重载逗号运算符\"></a>不要重载逗号运算符</h3><p>逆置一个字符串的例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">char</span> s[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"built_in\">strlen</span>(s) - <span class=\"number\">1</span>; i &lt; j; ++i, --j)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = s[i];</span><br><span class=\"line\">        s[i] = s[j];</span><br><span class=\"line\">        s[j] = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>包含逗号的表达式，首先计算逗号左边的表达式，然后计算右边的表达式；整个表达式返回最右边的表达式的值。</strong>鉴于你完全没有办法模拟这个行为，所以不要重载逗号运算符。</p>\n<h4 id=\"同时也不要重载以下的运算符\"><a href=\"#同时也不要重载以下的运算符\" class=\"headerlink\" title=\"同时也不要重载以下的运算符\"></a>同时也不要重载以下的运算符</h4><ul>\n<li><code>.</code></li>\n<li><code>.*</code></li>\n<li><code>::</code></li>\n<li><code>?:</code></li>\n<li><code>new delete sizeof typeid</code></li>\n<li><code>static_cast dynamic_cast const_cast reinterpret_cast</code></li>\n</ul>\n<h3 id=\"条款8：理解new和delete在不同情形下的含义\"><a href=\"#条款8：理解new和delete在不同情形下的含义\" class=\"headerlink\" title=\"条款8：理解new和delete在不同情形下的含义\"></a>条款8：理解new和delete在不同情形下的含义</h3><h4 id=\"区分-new-操作符-new-operator-和-operator-new-函数\"><a href=\"#区分-new-操作符-new-operator-和-operator-new-函数\" class=\"headerlink\" title=\"区分 new 操作符(new operator)和 operator new 函数\"></a>区分 new 操作符(new operator)和 operator new 函数</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> *ps = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"string\">\"Memory Management\"</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码中使用的new 指的是 new 操作符。</p>"},{"title":"浅读《STL源码剖析》笔记 3章","date":"2018-02-08T09:07:30.000Z","keywords":["STL源码剖析","iterator"],"_content":"\n## 3 迭代器(iterator)概念与traits编程技法\n迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式\n\n### 3.1 迭代器设计思维\n**STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一**\n<!--more-->\n\n```c++\n//3.1举例说明迭代器的使用\n//find()的定义。\ntemplate <class InputIterator, chass T>\nInputIterator find( InputIterator first, InputIterator last, const T& value ){\n    while ( first != last && *first != value )\n        ++first;\n        return first;\n}\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    const int arraySiza = 7;\n    int ia[arraySiza] = { 0, 1, 2, 3, 4, 5, 6 };\n    vector<int> ivect(ia, ia+arraySiza);\n    //调用vector的iterator用于find()\n    vector<int>::iterator it1 = find(ivect.begin(), ivect.end(), 4);\n    if( it1 == ivect.end() )\n        cout << \"4 not found.\" << endl;\n    else\n        cout << \"4 found:\" << *it1 << endl;\n\n    it1 = find(ivect.begin(), ivect.end(), 8);\n    if( it1 == ivect.end() )\n        cout << \"8 not found.\" << endl;\n    else\n        cout << \"8 found\" << *it1 << endl;\n\n    return 0;\n}\n```\n运行结果：\n![迭代器](http://p3ax8ersb.bkt.clouddn.com/201802011511_588.png-960.jpg)\n\n### 3.2 迭代器(ierator)是一种smart pointer\n**迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-> 进行重载工作。**\n以下，简单模拟一个list的结构，然后设计对应的iterator。\n```c++\n//listnode\ntemplate <typename T>\nclass ListItem{\npublic:\n    T value() const{ return _value; }\n    ListItem* next() const{ return _next; }\n    //...\nprivate:\n    T _value;\n    ListItem* _next; //单向链表(single linked list)\n};\n\n//list\ntemplate <typename T>\nclass List{\npublic:\n    void insert_front(T value); //省略实现\n    void insert_end(T value);   //省略实现\n    voide display(std::ostream &os = std::cout) const;//省略实现\n    //...\nprivate:\n    ListItem<T>* _end;\n    ListItem<T>* _front;\n    long _size;\n};\n```\n当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：\n```c++\n//iterator\ntemplate <class Item>//Item可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的operator++只适用于链表。\nstruct ListIter{\n    Item* ptr;  //保持与容器之间的一个联系\n    ListIter( Item* p = 0 )\n        :ptr(p)\n        {}\n    //不必实现copy ctor，因为编译器提供的缺省行为已经足够\n    //不必实现operator=，因为编译器提供的缺省行为已经足够\n    Item& operator*() const { return *ptr; }\n    Item* operator->() const { return ptr; }\n    //operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator)\n    //pre-increament operator\n    ListIter& operator++(){\n        ptr = ptr->next();\n        return *this;\n    }\n    //post-incteament operator\n    LostIter operator++(int){\n        ListIter tmp = *this;\n        ++*this;\n        return tmp;\n    }\n    bool operator==(const LostIter& i)const{ return ptr == i.ptr; }\n    bool operator!=(const LostIter& i)const{ return ptr != i.ptr; }\n}\n```\n接下来，将List和find()由ListIter粘合起来：\n```c++\nint main(){\n    List<int> mylist;\n    for( int i=0; i<5; ++i ){\n        mylist.insert_front(i);\n        mylist.insert_end(i+2);\n    }\n    mylist.displau();   //10( 4 3 2 1 0 2 3 4 5 6)\n    ListIter<ListItem<int> > begin(mylist.front());\n    ListIter<ListItem<int> > end;\n    ListIter<ListItem<int> > iter;\n\n    iter = find(begin, end, 3);\n    if( iter == end )\n        cout << \"not found\" << endl;\n    else\n        cout << \"found.\" << iter->value() << endl;\n    //执行结果：found.3\n\n    return 0;\n}\n```\n由于find() 函数以`*iter != value`来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 `ListIterm<int>`,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和`ListIterm<int>`。如下：\n```c++\ntemplate <typename T>\nbool operator!=(const ListItem<T>& item, T n){ return item.value() != n; }\n```\n### 3.3 迭代器相应型别(associated types)\n当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：![function template的例子](http://p3ax8ersb.bkt.clouddn.com/201802011841_231.png-960.jpg)\n以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。\n### 3.4 Traits 编程技法——STL源代码门钥\n**value type：迭代器所指对象的型别。**上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的\"template参数推导机制\"推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：\n```c++\ntemplate <class T>\nstruct MyIter{\n    typedef T value_type;   //内嵌型别声明(nested type)\n    MyIter(T* p = 0)\n        :ptr(p)\n        {}\n    T& operator*() const { return *ptr; }\n    //...\n    T* ptr; //成员变量\n};\ntemplate <class I>\ntypename I::value_type func( I ite ){ return *ite; }    //typename I::value_type  这是func的返回值型别；\n//...\nMyIter<int> ite(new int(8));\ncout << func(ite);  //输出:8\n```\n`typename I::value_type`必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。**加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。**\n\n这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 **偏特化(template partial specialization)**。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：\n```c++\n//class template\ntemplate <typename T>\nclass C{    //这个泛化版本接受T为任何型别\n    //...\n};\n//prartial specialization\ntemplate <typename T>\nclass C<T*>{    //这个特化版本只适用于\"T 为原生指针\"的情况\n    //...\n};\n```\n下面这个例子，**专门用来萃取迭代器的特性，value type正是迭代器的特性之一**\n```c++\ntemplate <class I>\nstruct iterator_traits{ //traits意思为“特性”\n    typedef typename I::value_type value_type;\n};\n```\n这样，前面那个func函数可以修改成这样。\n```c++\ntemplate <class I>\n//typename iterator_traits<I>::value_type 是函数的返回型别\ntypename iterator_traits<I>::value_type func(I ite){ return *ite; }\n```\n跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：\n```c++\ntemplate <class T>\nstruct iterator_traits<T*>{ //偏特化版本--迭代器是一个原生指针\n    typedef T value_type;\n}\n```\n此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的`iterator_traits<const int*>::value_type`得到的是const int。所以我们另外设计一个特化版本，让`const T*`转变为T*：\n```c++\ntemplate <class T>\nstruct iterator_traits<const T*>{   //偏特化版本，当迭代器是一个const指针的时候，\n    typedef T value_type;           //萃取出来的是T，而不是const T\n};\n```\n到这里为止，**不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。**\n\n图解iterator_traits：![iterator_traits](http://p3ax8ersb.bkt.clouddn.com/201802012217_572.png-960.jpg)\n常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：\n```c++\ntemplate <class I>\nstruct iterator_traits{\n    typedef typename I::iterator_category iterator_category;\n    typedef typename I::value_type value_type;\n    typedef typename I::difference_type difference_type;\n    typedef typename I::pointer pointer;\n    typedef typename I::reference reference;\n};\n```\n**其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。**\n以上：\n\n#### 3.4.1 value type 如上\n#### 3.4.2 difference type\n#### 3.4.3 reference type\n#### 3.4.4 pointer type\n#### 3.4.5 iterator_catrgory","source":"_posts/浅读《STL源码剖析》笔记-3章.md","raw":"---\ntitle: 浅读《STL源码剖析》笔记 3章\ndate: 2018-02-08 17:07:30\ntags:\ncategories:\n    - \"learning\"\nkeywords:\n    - \"STL源码剖析\"\n    - \"iterator\"\n---\n\n## 3 迭代器(iterator)概念与traits编程技法\n迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式\n\n### 3.1 迭代器设计思维\n**STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一**\n<!--more-->\n\n```c++\n//3.1举例说明迭代器的使用\n//find()的定义。\ntemplate <class InputIterator, chass T>\nInputIterator find( InputIterator first, InputIterator last, const T& value ){\n    while ( first != last && *first != value )\n        ++first;\n        return first;\n}\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    const int arraySiza = 7;\n    int ia[arraySiza] = { 0, 1, 2, 3, 4, 5, 6 };\n    vector<int> ivect(ia, ia+arraySiza);\n    //调用vector的iterator用于find()\n    vector<int>::iterator it1 = find(ivect.begin(), ivect.end(), 4);\n    if( it1 == ivect.end() )\n        cout << \"4 not found.\" << endl;\n    else\n        cout << \"4 found:\" << *it1 << endl;\n\n    it1 = find(ivect.begin(), ivect.end(), 8);\n    if( it1 == ivect.end() )\n        cout << \"8 not found.\" << endl;\n    else\n        cout << \"8 found\" << *it1 << endl;\n\n    return 0;\n}\n```\n运行结果：\n![迭代器](http://p3ax8ersb.bkt.clouddn.com/201802011511_588.png-960.jpg)\n\n### 3.2 迭代器(ierator)是一种smart pointer\n**迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-> 进行重载工作。**\n以下，简单模拟一个list的结构，然后设计对应的iterator。\n```c++\n//listnode\ntemplate <typename T>\nclass ListItem{\npublic:\n    T value() const{ return _value; }\n    ListItem* next() const{ return _next; }\n    //...\nprivate:\n    T _value;\n    ListItem* _next; //单向链表(single linked list)\n};\n\n//list\ntemplate <typename T>\nclass List{\npublic:\n    void insert_front(T value); //省略实现\n    void insert_end(T value);   //省略实现\n    voide display(std::ostream &os = std::cout) const;//省略实现\n    //...\nprivate:\n    ListItem<T>* _end;\n    ListItem<T>* _front;\n    long _size;\n};\n```\n当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：\n```c++\n//iterator\ntemplate <class Item>//Item可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的operator++只适用于链表。\nstruct ListIter{\n    Item* ptr;  //保持与容器之间的一个联系\n    ListIter( Item* p = 0 )\n        :ptr(p)\n        {}\n    //不必实现copy ctor，因为编译器提供的缺省行为已经足够\n    //不必实现operator=，因为编译器提供的缺省行为已经足够\n    Item& operator*() const { return *ptr; }\n    Item* operator->() const { return ptr; }\n    //operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator)\n    //pre-increament operator\n    ListIter& operator++(){\n        ptr = ptr->next();\n        return *this;\n    }\n    //post-incteament operator\n    LostIter operator++(int){\n        ListIter tmp = *this;\n        ++*this;\n        return tmp;\n    }\n    bool operator==(const LostIter& i)const{ return ptr == i.ptr; }\n    bool operator!=(const LostIter& i)const{ return ptr != i.ptr; }\n}\n```\n接下来，将List和find()由ListIter粘合起来：\n```c++\nint main(){\n    List<int> mylist;\n    for( int i=0; i<5; ++i ){\n        mylist.insert_front(i);\n        mylist.insert_end(i+2);\n    }\n    mylist.displau();   //10( 4 3 2 1 0 2 3 4 5 6)\n    ListIter<ListItem<int> > begin(mylist.front());\n    ListIter<ListItem<int> > end;\n    ListIter<ListItem<int> > iter;\n\n    iter = find(begin, end, 3);\n    if( iter == end )\n        cout << \"not found\" << endl;\n    else\n        cout << \"found.\" << iter->value() << endl;\n    //执行结果：found.3\n\n    return 0;\n}\n```\n由于find() 函数以`*iter != value`来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 `ListIterm<int>`,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和`ListIterm<int>`。如下：\n```c++\ntemplate <typename T>\nbool operator!=(const ListItem<T>& item, T n){ return item.value() != n; }\n```\n### 3.3 迭代器相应型别(associated types)\n当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：![function template的例子](http://p3ax8ersb.bkt.clouddn.com/201802011841_231.png-960.jpg)\n以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。\n### 3.4 Traits 编程技法——STL源代码门钥\n**value type：迭代器所指对象的型别。**上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的\"template参数推导机制\"推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：\n```c++\ntemplate <class T>\nstruct MyIter{\n    typedef T value_type;   //内嵌型别声明(nested type)\n    MyIter(T* p = 0)\n        :ptr(p)\n        {}\n    T& operator*() const { return *ptr; }\n    //...\n    T* ptr; //成员变量\n};\ntemplate <class I>\ntypename I::value_type func( I ite ){ return *ite; }    //typename I::value_type  这是func的返回值型别；\n//...\nMyIter<int> ite(new int(8));\ncout << func(ite);  //输出:8\n```\n`typename I::value_type`必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。**加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。**\n\n这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 **偏特化(template partial specialization)**。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：\n```c++\n//class template\ntemplate <typename T>\nclass C{    //这个泛化版本接受T为任何型别\n    //...\n};\n//prartial specialization\ntemplate <typename T>\nclass C<T*>{    //这个特化版本只适用于\"T 为原生指针\"的情况\n    //...\n};\n```\n下面这个例子，**专门用来萃取迭代器的特性，value type正是迭代器的特性之一**\n```c++\ntemplate <class I>\nstruct iterator_traits{ //traits意思为“特性”\n    typedef typename I::value_type value_type;\n};\n```\n这样，前面那个func函数可以修改成这样。\n```c++\ntemplate <class I>\n//typename iterator_traits<I>::value_type 是函数的返回型别\ntypename iterator_traits<I>::value_type func(I ite){ return *ite; }\n```\n跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：\n```c++\ntemplate <class T>\nstruct iterator_traits<T*>{ //偏特化版本--迭代器是一个原生指针\n    typedef T value_type;\n}\n```\n此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的`iterator_traits<const int*>::value_type`得到的是const int。所以我们另外设计一个特化版本，让`const T*`转变为T*：\n```c++\ntemplate <class T>\nstruct iterator_traits<const T*>{   //偏特化版本，当迭代器是一个const指针的时候，\n    typedef T value_type;           //萃取出来的是T，而不是const T\n};\n```\n到这里为止，**不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。**\n\n图解iterator_traits：![iterator_traits](http://p3ax8ersb.bkt.clouddn.com/201802012217_572.png-960.jpg)\n常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：\n```c++\ntemplate <class I>\nstruct iterator_traits{\n    typedef typename I::iterator_category iterator_category;\n    typedef typename I::value_type value_type;\n    typedef typename I::difference_type difference_type;\n    typedef typename I::pointer pointer;\n    typedef typename I::reference reference;\n};\n```\n**其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。**\n以上：\n\n#### 3.4.1 value type 如上\n#### 3.4.2 difference type\n#### 3.4.3 reference type\n#### 3.4.4 pointer type\n#### 3.4.5 iterator_catrgory","slug":"浅读《STL源码剖析》笔记-3章","published":1,"updated":"2018-03-06T08:44:24.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nr6j001h04d82reamiii","content":"<h2 id=\"3-迭代器-iterator-概念与traits编程技法\"><a href=\"#3-迭代器-iterator-概念与traits编程技法\" class=\"headerlink\" title=\"3 迭代器(iterator)概念与traits编程技法\"></a>3 迭代器(iterator)概念与traits编程技法</h2><p>迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式</p>\n<h3 id=\"3-1-迭代器设计思维\"><a href=\"#3-1-迭代器设计思维\" class=\"headerlink\" title=\"3.1 迭代器设计思维\"></a>3.1 迭代器设计思维</h3><p><strong>STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一</strong><br><a id=\"more\"></a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//3.1举例说明迭代器的使用</span></span><br><span class=\"line\"><span class=\"comment\">//find()的定义。</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator</span>, <span class=\"title\">chass</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">InputIterator</span> <span class=\"title\">find</span>( <span class=\"title\">InputIterator</span> <span class=\"title\">first</span>, <span class=\"title\">InputIterator</span> <span class=\"title\">last</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>&amp; <span class=\"title\">value</span> )&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( first != last &amp;&amp; *first != value )</span><br><span class=\"line\">        ++first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> arraySiza = <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ia[arraySiza] = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivect(ia, ia+arraySiza);</span><br><span class=\"line\">    <span class=\"comment\">//调用vector的iterator用于find()</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator it1 = find(ivect.begin(), ivect.end(), <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( it1 == ivect.end() )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"4 not found.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"4 found:\"</span> &lt;&lt; *it1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    it1 = find(ivect.begin(), ivect.end(), <span class=\"number\">8</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( it1 == ivect.end() )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"8 not found.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"8 found\"</span> &lt;&lt; *it1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011511_588.png-960.jpg\" alt=\"迭代器\"></p>\n<h3 id=\"3-2-迭代器-ierator-是一种smart-pointer\"><a href=\"#3-2-迭代器-ierator-是一种smart-pointer\" class=\"headerlink\" title=\"3.2 迭代器(ierator)是一种smart pointer\"></a>3.2 迭代器(ierator)是一种smart pointer</h3><p><strong>迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-&gt; 进行重载工作。</strong><br>以下，简单模拟一个list的结构，然后设计对应的iterator。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//listnode</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListItem</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123; <span class=\"keyword\">return</span> _value; &#125;</span><br><span class=\"line\">    <span class=\"function\">ListItem* <span class=\"title\">next</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123; <span class=\"keyword\">return</span> _next; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T _value;</span><br><span class=\"line\">    ListItem* _next; <span class=\"comment\">//单向链表(single linked list)</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//list</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_front</span><span class=\"params\">(T value)</span></span>; <span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_end</span><span class=\"params\">(T value)</span></span>;   <span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"function\">voide <span class=\"title\">display</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os = <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    ListItem&lt;T&gt;* _end;</span><br><span class=\"line\">    ListItem&lt;T&gt;* _front;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> _size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//iterator</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Item</span>&gt;//<span class=\"title\">Item</span>可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的<span class=\"title\">operator</span>++只适用于链表。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">ListIter</span>&#123;</span></span><br><span class=\"line\">    Item* ptr;  <span class=\"comment\">//保持与容器之间的一个联系</span></span><br><span class=\"line\">    ListIter( Item* p = <span class=\"number\">0</span> )</span><br><span class=\"line\">        :ptr(p)</span><br><span class=\"line\">        &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//不必实现copy ctor，因为编译器提供的缺省行为已经足够</span></span><br><span class=\"line\">    <span class=\"comment\">//不必实现operator=，因为编译器提供的缺省行为已经足够</span></span><br><span class=\"line\">    Item&amp; <span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> *ptr; &#125;</span><br><span class=\"line\">    Item* <span class=\"keyword\">operator</span>-&gt;() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> ptr; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator)</span></span><br><span class=\"line\">    <span class=\"comment\">//pre-increament operator</span></span><br><span class=\"line\">    ListIter&amp; <span class=\"keyword\">operator</span>++()&#123;</span><br><span class=\"line\">        ptr = ptr-&gt;next();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//post-incteament operator</span></span><br><span class=\"line\">    LostIter <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)&#123;</span><br><span class=\"line\">        ListIter tmp = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        ++*<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> LostIter&amp; i)<span class=\"keyword\">const</span>&#123; <span class=\"keyword\">return</span> ptr == i.ptr; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> LostIter&amp; i)<span class=\"keyword\">const</span>&#123; <span class=\"keyword\">return</span> ptr != i.ptr; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来，将List和find()由ListIter粘合起来：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>&gt; mylist;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i )&#123;</span><br><span class=\"line\">        mylist.insert_front(i);</span><br><span class=\"line\">        mylist.insert_end(i+<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mylist.displau();   <span class=\"comment\">//10( 4 3 2 1 0 2 3 4 5 6)</span></span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; begin(mylist.front());</span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; end;</span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; iter;</span><br><span class=\"line\"></span><br><span class=\"line\">    iter = find(begin, end, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( iter == end )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not found\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"found.\"</span> &lt;&lt; iter-&gt;value() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//执行结果：found.3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于find() 函数以<code>*iter != value</code>来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 <code>ListIterm&lt;int&gt;</code>,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和<code>ListIterm&lt;int&gt;</code>。如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> ListItem&lt;T&gt;&amp; item, T n)&#123; <span class=\"keyword\">return</span> item.value() != n; &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-3-迭代器相应型别-associated-types\"><a href=\"#3-3-迭代器相应型别-associated-types\" class=\"headerlink\" title=\"3.3 迭代器相应型别(associated types)\"></a>3.3 迭代器相应型别(associated types)</h3><p>当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011841_231.png-960.jpg\" alt=\"function template的例子\"><br>以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。</p>\n<h3 id=\"3-4-Traits-编程技法——STL源代码门钥\"><a href=\"#3-4-Traits-编程技法——STL源代码门钥\" class=\"headerlink\" title=\"3.4 Traits 编程技法——STL源代码门钥\"></a>3.4 Traits 编程技法——STL源代码门钥</h3><p><strong>value type：迭代器所指对象的型别。</strong>上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的”template参数推导机制”推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">MyIter</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;   <span class=\"comment\">//内嵌型别声明(nested type)</span></span><br><span class=\"line\">    MyIter(T* p = <span class=\"number\">0</span>)</span><br><span class=\"line\">        :ptr(p)</span><br><span class=\"line\">        &#123;&#125;</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> *ptr; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    T* ptr; <span class=\"comment\">//成员变量</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">typename</span> <span class=\"title\">I</span>:</span>:<span class=\"function\">value_type <span class=\"title\">func</span><span class=\"params\">( I ite )</span></span>&#123; <span class=\"keyword\">return</span> *ite; &#125;    <span class=\"comment\">//typename I::value_type  这是func的返回值型别；</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">MyIter&lt;<span class=\"keyword\">int</span>&gt; ite(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>));</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; func(ite);  <span class=\"comment\">//输出:8</span></span><br></pre></td></tr></table></figure></p>\n<p><code>typename I::value_type</code>必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。<strong>加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。</strong></p>\n<p>这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 <strong>偏特化(template partial specialization)</strong>。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//class template</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>&#123;</span>    <span class=\"comment\">//这个泛化版本接受T为任何型别</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//prartial specialization</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>&lt;T*&gt;&#123;</span>    <span class=\"comment\">//这个特化版本只适用于\"T 为原生指针\"的情况</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>下面这个例子，<strong>专门用来萃取迭代器的特性，value type正是迭代器的特性之一</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&#123;</span> <span class=\"comment\">//traits意思为“特性”</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::value_type value_type;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样，前面那个func函数可以修改成这样。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">//<span class=\"title\">typename</span> <span class=\"title\">iterator_traits</span>&lt;I&gt;:</span>:value_type 是函数的返回型别</span><br><span class=\"line\"><span class=\"keyword\">typename</span> iterator_traits&lt;I&gt;::<span class=\"function\">value_type <span class=\"title\">func</span><span class=\"params\">(I ite)</span></span>&#123; <span class=\"keyword\">return</span> *ite; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&lt;T*&gt;&#123;</span> <span class=\"comment\">//偏特化版本--迭代器是一个原生指针</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的<code>iterator_traits&lt;const int*&gt;::value_type</code>得到的是const int。所以我们另外设计一个特化版本，让<code>const T*</code>转变为T*：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&lt;const T*&gt;&#123;</span>   <span class=\"comment\">//偏特化版本，当迭代器是一个const指针的时候，</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;           <span class=\"comment\">//萃取出来的是T，而不是const T</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>到这里为止，<strong>不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。</strong></p>\n<p>图解iterator_traits：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802012217_572.png-960.jpg\" alt=\"iterator_traits\"><br>常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::iterator_category iterator_category;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::value_type value_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::difference_type difference_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::pointer pointer;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::reference reference;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。</strong><br>以上：</p>\n<h4 id=\"3-4-1-value-type-如上\"><a href=\"#3-4-1-value-type-如上\" class=\"headerlink\" title=\"3.4.1 value type 如上\"></a>3.4.1 value type 如上</h4><h4 id=\"3-4-2-difference-type\"><a href=\"#3-4-2-difference-type\" class=\"headerlink\" title=\"3.4.2 difference type\"></a>3.4.2 difference type</h4><h4 id=\"3-4-3-reference-type\"><a href=\"#3-4-3-reference-type\" class=\"headerlink\" title=\"3.4.3 reference type\"></a>3.4.3 reference type</h4><h4 id=\"3-4-4-pointer-type\"><a href=\"#3-4-4-pointer-type\" class=\"headerlink\" title=\"3.4.4 pointer type\"></a>3.4.4 pointer type</h4><h4 id=\"3-4-5-iterator-catrgory\"><a href=\"#3-4-5-iterator-catrgory\" class=\"headerlink\" title=\"3.4.5 iterator_catrgory\"></a>3.4.5 iterator_catrgory</h4>","site":{"data":{}},"excerpt":"<h2 id=\"3-迭代器-iterator-概念与traits编程技法\"><a href=\"#3-迭代器-iterator-概念与traits编程技法\" class=\"headerlink\" title=\"3 迭代器(iterator)概念与traits编程技法\"></a>3 迭代器(iterator)概念与traits编程技法</h2><p>迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式</p>\n<h3 id=\"3-1-迭代器设计思维\"><a href=\"#3-1-迭代器设计思维\" class=\"headerlink\" title=\"3.1 迭代器设计思维\"></a>3.1 迭代器设计思维</h3><p><strong>STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一</strong><br>","more":"</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//3.1举例说明迭代器的使用</span></span><br><span class=\"line\"><span class=\"comment\">//find()的定义。</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator</span>, <span class=\"title\">chass</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">InputIterator</span> <span class=\"title\">find</span>( <span class=\"title\">InputIterator</span> <span class=\"title\">first</span>, <span class=\"title\">InputIterator</span> <span class=\"title\">last</span>, <span class=\"title\">const</span> <span class=\"title\">T</span>&amp; <span class=\"title\">value</span> )&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( first != last &amp;&amp; *first != value )</span><br><span class=\"line\">        ++first;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> arraySiza = <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ia[arraySiza] = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ivect(ia, ia+arraySiza);</span><br><span class=\"line\">    <span class=\"comment\">//调用vector的iterator用于find()</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator it1 = find(ivect.begin(), ivect.end(), <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( it1 == ivect.end() )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"4 not found.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"4 found:\"</span> &lt;&lt; *it1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    it1 = find(ivect.begin(), ivect.end(), <span class=\"number\">8</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( it1 == ivect.end() )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"8 not found.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"8 found\"</span> &lt;&lt; *it1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011511_588.png-960.jpg\" alt=\"迭代器\"></p>\n<h3 id=\"3-2-迭代器-ierator-是一种smart-pointer\"><a href=\"#3-2-迭代器-ierator-是一种smart-pointer\" class=\"headerlink\" title=\"3.2 迭代器(ierator)是一种smart pointer\"></a>3.2 迭代器(ierator)是一种smart pointer</h3><p><strong>迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-&gt; 进行重载工作。</strong><br>以下，简单模拟一个list的结构，然后设计对应的iterator。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//listnode</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListItem</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123; <span class=\"keyword\">return</span> _value; &#125;</span><br><span class=\"line\">    <span class=\"function\">ListItem* <span class=\"title\">next</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>&#123; <span class=\"keyword\">return</span> _next; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T _value;</span><br><span class=\"line\">    ListItem* _next; <span class=\"comment\">//单向链表(single linked list)</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//list</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_front</span><span class=\"params\">(T value)</span></span>; <span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_end</span><span class=\"params\">(T value)</span></span>;   <span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"function\">voide <span class=\"title\">display</span><span class=\"params\">(<span class=\"built_in\">std</span>::ostream &amp;os = <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>)</span> <span class=\"keyword\">const</span></span>;<span class=\"comment\">//省略实现</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    ListItem&lt;T&gt;* _end;</span><br><span class=\"line\">    ListItem&lt;T&gt;* _front;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> _size;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//iterator</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Item</span>&gt;//<span class=\"title\">Item</span>可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的<span class=\"title\">operator</span>++只适用于链表。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">ListIter</span>&#123;</span></span><br><span class=\"line\">    Item* ptr;  <span class=\"comment\">//保持与容器之间的一个联系</span></span><br><span class=\"line\">    ListIter( Item* p = <span class=\"number\">0</span> )</span><br><span class=\"line\">        :ptr(p)</span><br><span class=\"line\">        &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//不必实现copy ctor，因为编译器提供的缺省行为已经足够</span></span><br><span class=\"line\">    <span class=\"comment\">//不必实现operator=，因为编译器提供的缺省行为已经足够</span></span><br><span class=\"line\">    Item&amp; <span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> *ptr; &#125;</span><br><span class=\"line\">    Item* <span class=\"keyword\">operator</span>-&gt;() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> ptr; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator)</span></span><br><span class=\"line\">    <span class=\"comment\">//pre-increament operator</span></span><br><span class=\"line\">    ListIter&amp; <span class=\"keyword\">operator</span>++()&#123;</span><br><span class=\"line\">        ptr = ptr-&gt;next();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//post-incteament operator</span></span><br><span class=\"line\">    LostIter <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)&#123;</span><br><span class=\"line\">        ListIter tmp = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        ++*<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> LostIter&amp; i)<span class=\"keyword\">const</span>&#123; <span class=\"keyword\">return</span> ptr == i.ptr; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> LostIter&amp; i)<span class=\"keyword\">const</span>&#123; <span class=\"keyword\">return</span> ptr != i.ptr; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来，将List和find()由ListIter粘合起来：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>&gt; mylist;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i )&#123;</span><br><span class=\"line\">        mylist.insert_front(i);</span><br><span class=\"line\">        mylist.insert_end(i+<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mylist.displau();   <span class=\"comment\">//10( 4 3 2 1 0 2 3 4 5 6)</span></span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; begin(mylist.front());</span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; end;</span><br><span class=\"line\">    ListIter&lt;ListItem&lt;<span class=\"keyword\">int</span>&gt; &gt; iter;</span><br><span class=\"line\"></span><br><span class=\"line\">    iter = find(begin, end, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( iter == end )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not found\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"found.\"</span> &lt;&lt; iter-&gt;value() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">//执行结果：found.3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于find() 函数以<code>*iter != value</code>来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 <code>ListIterm&lt;int&gt;</code>,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和<code>ListIterm&lt;int&gt;</code>。如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"keyword\">const</span> ListItem&lt;T&gt;&amp; item, T n)&#123; <span class=\"keyword\">return</span> item.value() != n; &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-3-迭代器相应型别-associated-types\"><a href=\"#3-3-迭代器相应型别-associated-types\" class=\"headerlink\" title=\"3.3 迭代器相应型别(associated types)\"></a>3.3 迭代器相应型别(associated types)</h3><p>当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802011841_231.png-960.jpg\" alt=\"function template的例子\"><br>以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。</p>\n<h3 id=\"3-4-Traits-编程技法——STL源代码门钥\"><a href=\"#3-4-Traits-编程技法——STL源代码门钥\" class=\"headerlink\" title=\"3.4 Traits 编程技法——STL源代码门钥\"></a>3.4 Traits 编程技法——STL源代码门钥</h3><p><strong>value type：迭代器所指对象的型别。</strong>上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的”template参数推导机制”推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">MyIter</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;   <span class=\"comment\">//内嵌型别声明(nested type)</span></span><br><span class=\"line\">    MyIter(T* p = <span class=\"number\">0</span>)</span><br><span class=\"line\">        :ptr(p)</span><br><span class=\"line\">        &#123;&#125;</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*() <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">return</span> *ptr; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    T* ptr; <span class=\"comment\">//成员变量</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">typename</span> <span class=\"title\">I</span>:</span>:<span class=\"function\">value_type <span class=\"title\">func</span><span class=\"params\">( I ite )</span></span>&#123; <span class=\"keyword\">return</span> *ite; &#125;    <span class=\"comment\">//typename I::value_type  这是func的返回值型别；</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">MyIter&lt;<span class=\"keyword\">int</span>&gt; ite(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>));</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; func(ite);  <span class=\"comment\">//输出:8</span></span><br></pre></td></tr></table></figure></p>\n<p><code>typename I::value_type</code>必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。<strong>加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。</strong></p>\n<p>这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 <strong>偏特化(template partial specialization)</strong>。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//class template</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>&#123;</span>    <span class=\"comment\">//这个泛化版本接受T为任何型别</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//prartial specialization</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span>&lt;T*&gt;&#123;</span>    <span class=\"comment\">//这个特化版本只适用于\"T 为原生指针\"的情况</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>下面这个例子，<strong>专门用来萃取迭代器的特性，value type正是迭代器的特性之一</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&#123;</span> <span class=\"comment\">//traits意思为“特性”</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::value_type value_type;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样，前面那个func函数可以修改成这样。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">//<span class=\"title\">typename</span> <span class=\"title\">iterator_traits</span>&lt;I&gt;:</span>:value_type 是函数的返回型别</span><br><span class=\"line\"><span class=\"keyword\">typename</span> iterator_traits&lt;I&gt;::<span class=\"function\">value_type <span class=\"title\">func</span><span class=\"params\">(I ite)</span></span>&#123; <span class=\"keyword\">return</span> *ite; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&lt;T*&gt;&#123;</span> <span class=\"comment\">//偏特化版本--迭代器是一个原生指针</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的<code>iterator_traits&lt;const int*&gt;::value_type</code>得到的是const int。所以我们另外设计一个特化版本，让<code>const T*</code>转变为T*：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&lt;const T*&gt;&#123;</span>   <span class=\"comment\">//偏特化版本，当迭代器是一个const指针的时候，</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> T value_type;           <span class=\"comment\">//萃取出来的是T，而不是const T</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>到这里为止，<strong>不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。</strong></p>\n<p>图解iterator_traits：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802012217_572.png-960.jpg\" alt=\"iterator_traits\"><br>常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">I</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> <span class=\"title\">iterator_traits</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::iterator_category iterator_category;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::value_type value_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::difference_type difference_type;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::pointer pointer;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> I::reference reference;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。</strong><br>以上：</p>\n<h4 id=\"3-4-1-value-type-如上\"><a href=\"#3-4-1-value-type-如上\" class=\"headerlink\" title=\"3.4.1 value type 如上\"></a>3.4.1 value type 如上</h4><h4 id=\"3-4-2-difference-type\"><a href=\"#3-4-2-difference-type\" class=\"headerlink\" title=\"3.4.2 difference type\"></a>3.4.2 difference type</h4><h4 id=\"3-4-3-reference-type\"><a href=\"#3-4-3-reference-type\" class=\"headerlink\" title=\"3.4.3 reference type\"></a>3.4.3 reference type</h4><h4 id=\"3-4-4-pointer-type\"><a href=\"#3-4-4-pointer-type\" class=\"headerlink\" title=\"3.4.4 pointer type\"></a>3.4.4 pointer type</h4><h4 id=\"3-4-5-iterator-catrgory\"><a href=\"#3-4-5-iterator-catrgory\" class=\"headerlink\" title=\"3.4.5 iterator_catrgory\"></a>3.4.5 iterator_catrgory</h4>"},{"title":"浅读《STL源码剖析》笔记 4章-vector和list","date":"2018-02-09T02:13:57.000Z","_content":"## 4 序列式容器\n### 4.1 容器的概观与分类\n![SGI STL的各个容器](http://p3ax8ersb.bkt.clouddn.com/201801311638_540.png-960.jpg)\n所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。\n<!--more-->\n### 4.2 vector\n#### 4.2.1 vector概述\narray是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。\n#### 4.2.3 vector的迭代器\n由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。`vector<int> :: iterator ivite;vector<Shape> :: iterator svite;`其中 `ivite`的类型就是`int*`，`svite`的类型就是`Shape*` 。\n#### 4.2.4 vector的数据结构\nvector的数据结构如下：\n```c++\ntemplate<class T, class Alloc = alloc>\nclass vecotr{\n    //...\n    protected:\n    //注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置\n        iterator start;             //表示目前使用空间的头部\n        iterator finish;            //表示目前使用空间的尾部\n        iterator end_of_storage;    //表示目前可用空间的尾部\n}\n```\n为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。\n运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。\n\n#### 4.2.5 vector的构造与内存管理：constructor，push_back\npush_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。**因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。**push_back源代码节选如下：\n```c++\nvoid push_back( const T& x){\n    if( finish != end_of_storage ){\n        construct( finish, x );\n        ++finish;\n    }\n    else    //无备用空间\n    insert_aux(end(), x);\n}\n\ntemplate <class T, class Alloc>\nvoid vector<T, Alloc>::insert_aux( iterator positon, const T& x ){\n    if( finish != end_of_storage ){ //为什么还要再次判断\n        construct( finish, *(finish - 1));\n        ++finish;\n        T x_copy = x;\n        //不懂\n        copy_backward(position, finish - 2, finish - 1);\n        *position = x_copy;\n    }\n    else{   //无备用空间\n        const size_type old_size = size();\n        const size_type len = old_size != 0 ? 2*old_size : 1;\n        iterator new_start = data_allocator::allocatr(len); //实际配置空间\n        iterator new_finish = new_start;\n        try{\n            //将原来vector内容拷贝到新的vector\n            new_finish = uninitialized_copy(start, position, new_start);\n            //为新元素设定初值x\n            construct(new_finish, x);\n            ++new_finish;\n            //将安插点的原内容也拷贝过来//不懂\n            new_finish = uninitialized_copy(posiition, finish, new_finish);\n        }\n        catch(...){\n            //开辟失败\n            destroy(new_start, new_finish);\n            data_allocator::deallocate(new_start, len);\n            throw;\n        }\n        //析构并释放原vector\n        destory(begin(), end());\n        deallocate();\n        //调整迭代器，指向新的vector\n        start = new_start;\n        finish = new_finish;\n        end_of_storage = new_start+len;\n    }\n}\n```\n\n#### 4.2.6 vector的元素操作：pop_back, erase, clear, insert\n```c++\n//清除[first, last)中的元素\niterator erase(iterator first, iterator last){\n    iterator ii = copy(last, finish, first);    //copy是全局函数，第六章\n    destory(i, finish);\n    finish = finish - (last - first);\n    return first;\n}\n//清除某个位置上的元素\niterator erase(iterator position){\n    if(position + 1 != end())\n        copy(position + 1, finish, position);\n    --finish;\n    destroy(finish);\n    return position;\n}\n\nvoid clear(){ erase(begin(), end()); }\n\n//从position开始，插入n个元素，元素初值为x\ntemplate <class T, class Alloc>\nvoid vector<T, Alloc>::insert(iterator position, size_type n ,const T& x){\n    if(n != 0){\n        //备用空间大于等于新增元素个数\n        if(size_type(end_of_storage - finish) >= 0){\n            T x_copy = x;\n            //计算插入点之后的现有元素个数\n            const size_type elems_after = finish - position;\n            iterator old_finish = finish;\n            if(elems_after > n){    //插入点之后的现有元素个数 > 新增元素个数\n                uninitialized_copy(finish - n, finish, finish);\n                finish += n;    //将vector 尾端标记后移\n                copy_backward(position, old_finish - n, old_finish);\n                fill(position, position+n, x_copy); //从插入点开始填入新值\n            }\n            else{\n                uninitialized_fill_n(finish, n-elems_affter, x_copy);\n                finish += n - elems_after;\n                uninitialized_copy(position, old_finish, finish);\n                finish += elems_after;\n                fill(position, old_finish, x_copy);\n            }\n        }\n        else{   //备用空间 < 新增元素个数\n            const size_type old_size = size();\n            //决定新的长度为旧长度+新增元素个数\n            const size_type len = old_size + max(old_size, n);\n            //配置新的vector空间\n            iterator new_start = data_allocaator::allocate(len);\n            iterator new_finish = new_start;\n            __STL_TRY{  //<-- 这个是什么\n                //将旧的vector在插入点之前的元素复制到新空间\n                new_finish = uninitialized_copy(start, position, new_start);\n                //将新增元素(初值为x)填入新空间\n                new_finish = uninitialized_fill_n(new_finish, n, x);\n                //将旧的vector在插入点之后的元素复制到新空间\n                nwe_finish = uninitialized_copy(position, finish, new_finish);\n            }\n            //异常处理\n            //...\n\n            //清除释放旧的空间\n            destroy(start，finish);\n            deallocate();\n            //调整迭代器指向新的空间\n            start = new_start;\n            finish = new_finish;\n            end_of_storage = new_start+len;\n        }\n    }\n}\n//插入操作完成之后，新增节点应位于position的后面。\n```\n图解如下：![insert](http://p3ax8ersb.bkt.clouddn.com/201802021439_772.png-960.jpg)\n### 4.3 list\n#### 4.3.1 list概述\nlist每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。\n#### 4.3.2 list的节点(node)\nlist的节点和list本身的设计是分开的。以下是STL list的节点结构：\n```c++\ntemplate <class T>\nstruct __list_node{\n    typedef void* void_pointer;\n    void_pointer prev;  //型别为void*，其实可以是__list_node<T>\n    void_pointer next;\n    T data;\n}\n//这是一个双向链表节点\n```\n#### 4.3.3 list的迭代器\n**list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效**\n#### 4.3.4 list的数据结构\nSGI list 是一个双向循环链表。list结构如下：\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list{\nprotected:\n    typedef __list_node<T> list_node;\npublic:\n    typedef list_node* link_type;\nprotected:\n    link_type node;\n}\n```\n**STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。**\n```c++\niterator begin() { return (link_type)((*node).next); }\niterator end() { return node; }\nbool empty() const { return node->next == node; }\nsize_type size() const {\n    size_type result = 0;\n    distance(begin(), end(), result);   //全局函数，第三章//计算两个迭代器之间的距离\n    return result;\n}\nreference front() { return *begin(); }\nreference back() { return *(--end()); }\n```\n图解如下：![list](http://p3ax8ersb.bkt.clouddn.com/201802021641_929.png-960.jpg)\n\n#### 4.3.5 list的构造与内存管理：constructor， push_back, insert\nlist缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。`list_node_alloctor(n)`表示配置n个节点空间。同时有四个函数，如下：\n```c++\n//配置一个节点并传回\nlink_type get_node();\n//释放一个节点\nvoid put_node(link_type p);\n//配置并构造一个节点，带有元素值\nlink_type create_node(const T& x);\n//析构并释放一个节点\nvoid destroy_node(link_type p);\n```\nlist众多构造函数中，有一个允许我们构造一个空list出来：\n```c++\npublic:\n    list(){ empty_initialize(); }\nprotected:\n    void empty_initialize(){\n        //next、prev指针都指向自己\n        node = get_node();\n        node->next = node;\n        node->prev = node;\n    }\n```\n空节点对象模型：![空节点](http://p3ax8ersb.bkt.clouddn.com/201802021656_767.png-960.jpg)\n当我们用push_back()插入新节点的时候，函数内部调用insert()`void push_back(const T& x) { inset( end(), x ); }`insert()有很多的重载函数，最简单的如下:\n```c++\n//在迭代器position所指位置插入一个节点，值为x\niterator insert(iterator position, const T& x){\n    link_type tmp = create_node(x);\n    //插入位置在position之前,这是STL规范。\n    tmp->next = position.node;\n    tmp->prev = position.node->prev;\n    (link_type(position.node->node->prev))->next = tmp;\n    position.node->prev = tmp;\n    return tmp;\n}\n```\n#### 4.3.6 list的元素操作：`push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort`\npush_front, push_back复用insert；pop_front, pop_back复用erase。\n```c++\n//移除迭代器position所指节点\niterator erase(iterator position){\n    link_type next_node = link_type(position.node->next);\n    link_type prev_node = link_type(position.node->prev);\n    prev_node->next = next_node;\n    next_node->prev = prev_node;\n    destroy_node(position.node);\n    return iterator(next_node);\n}\n//清除所有节点\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::clear(){\n    link_type cur = (link__type) node->next;    //begin();\n    while( cur != node ){\n        link_type tmp - cur;\n        cur = (link_type)cur->next;\n        destroy_node(tmp);\n    }\n    //恢复成空节点的初始结构\n    node->next = node;\n    node->prev = node;\n}\n//将数值为value的所有元素移除\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::remove(const T& value){\n    iterator first = begin();\n    iterator last = end();\n    while(first != last){\n        iterator next = first;\n        ++next;\n        if(*first == value) erase(first);\n        first = next;\n    }\n}\n//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个\n//很帅啊\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::unique(){\n    iterator first = begin();\n    iterator last = end();\n    if(first == last) return;   //判空\n    iterator next = first;\n    while(++next != last){\n        if(*first == *next)\n            erase(next);\n        else\n            first = next;\n        next = first;\n    }\n}\n```\nlist 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。\n```c++\nprotected:\n    //将[first, last)内的所有元素移动到position之前。\n    void transfer(iterator position, iterator first, iterator last){\n        if(position != last){\n            //先处理各节点的next\n            (*(link_type((*last.node).prev))).next = position.node;\n            (*(link_type((*first.node).prev))).next = last.node;\n            (*(link_type((*position.node).prev))).next = first.node;\n            //tmp为position的prev节点\n            link_type tmp = link_type((*position.node).prev);\n            //处理各节点的prev\n            (*position.node).prev = (*last.node).prev;\n            (*last.node).prev = (*first.node).prev;\n            (*first.node).prev = tmp;\n        }\n    }\n```\nsplice各个版本：\n```c++\npublic:\n    //将list x接合与position所指位置之前，x必须不同于*this\n    void splice(iterator position, list& x){\n        if(!x.empty())\n            transfer(position, x.begin(), x.end());\n    }\n    //将i 所指元素接合于position所指元素之前。position和i可指向同一个list\n    void splice(iterator position, list&, iterator i){\n        iterator j = i;\n        ++j;\n        if(position == i || position == j) return;\n        trasfer(position, i, j);\n    }\n    //将[first, last)内的所有元素接合于position所指位置之前，\n    //position和[first, last)可指向同一个list。\n    //但是position不能在[first, last)范围之内\n    void splice(iterator posiition, list&, iterator first, iterator last){\n        if(first != last)\n            transfer(position, first, last);\n    }\n```\nmerge(), reverse(), sort()源码：\n```c++\n//merge()将x合并到*this上，两个list必须是递增排序的\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::merge(list<T, Alloc>& x){\n    iterator first1 = begin();\n    iterator last1 = end();\n    iterator first2 = x.begin();\n    iterator last2 = x.end();\n    while(first1 != last1 && first2 != last2){\n        if(*first2 < *first1){\n            iterator next = first2;\n            transfer(first1, first2, ++next);\n            first2 = next;\n        }\n        else\n            ++first1;\n        if(first2 !=  last2) transfer(last1, first2,last2);\n    }\n}\n\n//reverse()将*this的内容逆置\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::reverse(){\n    //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢\n    if(node->next == node || link_type(node->next)->next == node)\n        return;\n    iterator first = begin();\n    ++first;\n    while(first != end()){\n        iterator old = first;\n        ++first;\n        transfer(begin(), old, first);\n    }\n}\n\n//list不能使用STL中的sort()算法，只能使用自己的sort()\n//因为STL的sort()只接受RamdonAccessIterator\n//本函数使用quick sort\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::sort(){\n     //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢\n    if(node->next == node || link_type(node->next)->next == node)\n        return;\n    //创建新的list空间，作为中介数据存放区\n    list<T, Alloc> carry;\n    list<T, Alloc> counter[64];\n    int fill = 0;\n    while(!empty()){\n        carry.splice(carry.begin(), *this, begin());\n        int i = 0;\n        while(i < fill && !counter[i].empty()){\n            counter[i].merge(carry);\n            carry.swap(counter[i++]);\n        }\n        carry.swap(counter[i]);\n        if(i == fill)\n            ++fill;\n    }\n    for(int i = 1; i < fill; ++i)\n        counter[i].merge(counter[i-1]);\n    swap(counter[fill-1]);\n}\n```","source":"_posts/浅读《STL源码剖析》笔记-4章-vector和list.md","raw":"---\ntitle: 浅读《STL源码剖析》笔记 4章-vector和list\ndate: 2018-02-09 10:13:57\ntags:\ncategories:\n    - \"learning\"\n---\n## 4 序列式容器\n### 4.1 容器的概观与分类\n![SGI STL的各个容器](http://p3ax8ersb.bkt.clouddn.com/201801311638_540.png-960.jpg)\n所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。\n<!--more-->\n### 4.2 vector\n#### 4.2.1 vector概述\narray是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。\n#### 4.2.3 vector的迭代器\n由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。`vector<int> :: iterator ivite;vector<Shape> :: iterator svite;`其中 `ivite`的类型就是`int*`，`svite`的类型就是`Shape*` 。\n#### 4.2.4 vector的数据结构\nvector的数据结构如下：\n```c++\ntemplate<class T, class Alloc = alloc>\nclass vecotr{\n    //...\n    protected:\n    //注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置\n        iterator start;             //表示目前使用空间的头部\n        iterator finish;            //表示目前使用空间的尾部\n        iterator end_of_storage;    //表示目前可用空间的尾部\n}\n```\n为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。\n运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。\n\n#### 4.2.5 vector的构造与内存管理：constructor，push_back\npush_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。**因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。**push_back源代码节选如下：\n```c++\nvoid push_back( const T& x){\n    if( finish != end_of_storage ){\n        construct( finish, x );\n        ++finish;\n    }\n    else    //无备用空间\n    insert_aux(end(), x);\n}\n\ntemplate <class T, class Alloc>\nvoid vector<T, Alloc>::insert_aux( iterator positon, const T& x ){\n    if( finish != end_of_storage ){ //为什么还要再次判断\n        construct( finish, *(finish - 1));\n        ++finish;\n        T x_copy = x;\n        //不懂\n        copy_backward(position, finish - 2, finish - 1);\n        *position = x_copy;\n    }\n    else{   //无备用空间\n        const size_type old_size = size();\n        const size_type len = old_size != 0 ? 2*old_size : 1;\n        iterator new_start = data_allocator::allocatr(len); //实际配置空间\n        iterator new_finish = new_start;\n        try{\n            //将原来vector内容拷贝到新的vector\n            new_finish = uninitialized_copy(start, position, new_start);\n            //为新元素设定初值x\n            construct(new_finish, x);\n            ++new_finish;\n            //将安插点的原内容也拷贝过来//不懂\n            new_finish = uninitialized_copy(posiition, finish, new_finish);\n        }\n        catch(...){\n            //开辟失败\n            destroy(new_start, new_finish);\n            data_allocator::deallocate(new_start, len);\n            throw;\n        }\n        //析构并释放原vector\n        destory(begin(), end());\n        deallocate();\n        //调整迭代器，指向新的vector\n        start = new_start;\n        finish = new_finish;\n        end_of_storage = new_start+len;\n    }\n}\n```\n\n#### 4.2.6 vector的元素操作：pop_back, erase, clear, insert\n```c++\n//清除[first, last)中的元素\niterator erase(iterator first, iterator last){\n    iterator ii = copy(last, finish, first);    //copy是全局函数，第六章\n    destory(i, finish);\n    finish = finish - (last - first);\n    return first;\n}\n//清除某个位置上的元素\niterator erase(iterator position){\n    if(position + 1 != end())\n        copy(position + 1, finish, position);\n    --finish;\n    destroy(finish);\n    return position;\n}\n\nvoid clear(){ erase(begin(), end()); }\n\n//从position开始，插入n个元素，元素初值为x\ntemplate <class T, class Alloc>\nvoid vector<T, Alloc>::insert(iterator position, size_type n ,const T& x){\n    if(n != 0){\n        //备用空间大于等于新增元素个数\n        if(size_type(end_of_storage - finish) >= 0){\n            T x_copy = x;\n            //计算插入点之后的现有元素个数\n            const size_type elems_after = finish - position;\n            iterator old_finish = finish;\n            if(elems_after > n){    //插入点之后的现有元素个数 > 新增元素个数\n                uninitialized_copy(finish - n, finish, finish);\n                finish += n;    //将vector 尾端标记后移\n                copy_backward(position, old_finish - n, old_finish);\n                fill(position, position+n, x_copy); //从插入点开始填入新值\n            }\n            else{\n                uninitialized_fill_n(finish, n-elems_affter, x_copy);\n                finish += n - elems_after;\n                uninitialized_copy(position, old_finish, finish);\n                finish += elems_after;\n                fill(position, old_finish, x_copy);\n            }\n        }\n        else{   //备用空间 < 新增元素个数\n            const size_type old_size = size();\n            //决定新的长度为旧长度+新增元素个数\n            const size_type len = old_size + max(old_size, n);\n            //配置新的vector空间\n            iterator new_start = data_allocaator::allocate(len);\n            iterator new_finish = new_start;\n            __STL_TRY{  //<-- 这个是什么\n                //将旧的vector在插入点之前的元素复制到新空间\n                new_finish = uninitialized_copy(start, position, new_start);\n                //将新增元素(初值为x)填入新空间\n                new_finish = uninitialized_fill_n(new_finish, n, x);\n                //将旧的vector在插入点之后的元素复制到新空间\n                nwe_finish = uninitialized_copy(position, finish, new_finish);\n            }\n            //异常处理\n            //...\n\n            //清除释放旧的空间\n            destroy(start，finish);\n            deallocate();\n            //调整迭代器指向新的空间\n            start = new_start;\n            finish = new_finish;\n            end_of_storage = new_start+len;\n        }\n    }\n}\n//插入操作完成之后，新增节点应位于position的后面。\n```\n图解如下：![insert](http://p3ax8ersb.bkt.clouddn.com/201802021439_772.png-960.jpg)\n### 4.3 list\n#### 4.3.1 list概述\nlist每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。\n#### 4.3.2 list的节点(node)\nlist的节点和list本身的设计是分开的。以下是STL list的节点结构：\n```c++\ntemplate <class T>\nstruct __list_node{\n    typedef void* void_pointer;\n    void_pointer prev;  //型别为void*，其实可以是__list_node<T>\n    void_pointer next;\n    T data;\n}\n//这是一个双向链表节点\n```\n#### 4.3.3 list的迭代器\n**list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效**\n#### 4.3.4 list的数据结构\nSGI list 是一个双向循环链表。list结构如下：\n```c++\ntemplate <class T, class Alloc = alloc>\nclass list{\nprotected:\n    typedef __list_node<T> list_node;\npublic:\n    typedef list_node* link_type;\nprotected:\n    link_type node;\n}\n```\n**STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。**\n```c++\niterator begin() { return (link_type)((*node).next); }\niterator end() { return node; }\nbool empty() const { return node->next == node; }\nsize_type size() const {\n    size_type result = 0;\n    distance(begin(), end(), result);   //全局函数，第三章//计算两个迭代器之间的距离\n    return result;\n}\nreference front() { return *begin(); }\nreference back() { return *(--end()); }\n```\n图解如下：![list](http://p3ax8ersb.bkt.clouddn.com/201802021641_929.png-960.jpg)\n\n#### 4.3.5 list的构造与内存管理：constructor， push_back, insert\nlist缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。`list_node_alloctor(n)`表示配置n个节点空间。同时有四个函数，如下：\n```c++\n//配置一个节点并传回\nlink_type get_node();\n//释放一个节点\nvoid put_node(link_type p);\n//配置并构造一个节点，带有元素值\nlink_type create_node(const T& x);\n//析构并释放一个节点\nvoid destroy_node(link_type p);\n```\nlist众多构造函数中，有一个允许我们构造一个空list出来：\n```c++\npublic:\n    list(){ empty_initialize(); }\nprotected:\n    void empty_initialize(){\n        //next、prev指针都指向自己\n        node = get_node();\n        node->next = node;\n        node->prev = node;\n    }\n```\n空节点对象模型：![空节点](http://p3ax8ersb.bkt.clouddn.com/201802021656_767.png-960.jpg)\n当我们用push_back()插入新节点的时候，函数内部调用insert()`void push_back(const T& x) { inset( end(), x ); }`insert()有很多的重载函数，最简单的如下:\n```c++\n//在迭代器position所指位置插入一个节点，值为x\niterator insert(iterator position, const T& x){\n    link_type tmp = create_node(x);\n    //插入位置在position之前,这是STL规范。\n    tmp->next = position.node;\n    tmp->prev = position.node->prev;\n    (link_type(position.node->node->prev))->next = tmp;\n    position.node->prev = tmp;\n    return tmp;\n}\n```\n#### 4.3.6 list的元素操作：`push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort`\npush_front, push_back复用insert；pop_front, pop_back复用erase。\n```c++\n//移除迭代器position所指节点\niterator erase(iterator position){\n    link_type next_node = link_type(position.node->next);\n    link_type prev_node = link_type(position.node->prev);\n    prev_node->next = next_node;\n    next_node->prev = prev_node;\n    destroy_node(position.node);\n    return iterator(next_node);\n}\n//清除所有节点\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::clear(){\n    link_type cur = (link__type) node->next;    //begin();\n    while( cur != node ){\n        link_type tmp - cur;\n        cur = (link_type)cur->next;\n        destroy_node(tmp);\n    }\n    //恢复成空节点的初始结构\n    node->next = node;\n    node->prev = node;\n}\n//将数值为value的所有元素移除\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::remove(const T& value){\n    iterator first = begin();\n    iterator last = end();\n    while(first != last){\n        iterator next = first;\n        ++next;\n        if(*first == value) erase(first);\n        first = next;\n    }\n}\n//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个\n//很帅啊\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::unique(){\n    iterator first = begin();\n    iterator last = end();\n    if(first == last) return;   //判空\n    iterator next = first;\n    while(++next != last){\n        if(*first == *next)\n            erase(next);\n        else\n            first = next;\n        next = first;\n    }\n}\n```\nlist 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。\n```c++\nprotected:\n    //将[first, last)内的所有元素移动到position之前。\n    void transfer(iterator position, iterator first, iterator last){\n        if(position != last){\n            //先处理各节点的next\n            (*(link_type((*last.node).prev))).next = position.node;\n            (*(link_type((*first.node).prev))).next = last.node;\n            (*(link_type((*position.node).prev))).next = first.node;\n            //tmp为position的prev节点\n            link_type tmp = link_type((*position.node).prev);\n            //处理各节点的prev\n            (*position.node).prev = (*last.node).prev;\n            (*last.node).prev = (*first.node).prev;\n            (*first.node).prev = tmp;\n        }\n    }\n```\nsplice各个版本：\n```c++\npublic:\n    //将list x接合与position所指位置之前，x必须不同于*this\n    void splice(iterator position, list& x){\n        if(!x.empty())\n            transfer(position, x.begin(), x.end());\n    }\n    //将i 所指元素接合于position所指元素之前。position和i可指向同一个list\n    void splice(iterator position, list&, iterator i){\n        iterator j = i;\n        ++j;\n        if(position == i || position == j) return;\n        trasfer(position, i, j);\n    }\n    //将[first, last)内的所有元素接合于position所指位置之前，\n    //position和[first, last)可指向同一个list。\n    //但是position不能在[first, last)范围之内\n    void splice(iterator posiition, list&, iterator first, iterator last){\n        if(first != last)\n            transfer(position, first, last);\n    }\n```\nmerge(), reverse(), sort()源码：\n```c++\n//merge()将x合并到*this上，两个list必须是递增排序的\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::merge(list<T, Alloc>& x){\n    iterator first1 = begin();\n    iterator last1 = end();\n    iterator first2 = x.begin();\n    iterator last2 = x.end();\n    while(first1 != last1 && first2 != last2){\n        if(*first2 < *first1){\n            iterator next = first2;\n            transfer(first1, first2, ++next);\n            first2 = next;\n        }\n        else\n            ++first1;\n        if(first2 !=  last2) transfer(last1, first2,last2);\n    }\n}\n\n//reverse()将*this的内容逆置\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::reverse(){\n    //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢\n    if(node->next == node || link_type(node->next)->next == node)\n        return;\n    iterator first = begin();\n    ++first;\n    while(first != end()){\n        iterator old = first;\n        ++first;\n        transfer(begin(), old, first);\n    }\n}\n\n//list不能使用STL中的sort()算法，只能使用自己的sort()\n//因为STL的sort()只接受RamdonAccessIterator\n//本函数使用quick sort\ntemplate <class T, class Alloc>\nvoid list<T, Alloc>::sort(){\n     //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢\n    if(node->next == node || link_type(node->next)->next == node)\n        return;\n    //创建新的list空间，作为中介数据存放区\n    list<T, Alloc> carry;\n    list<T, Alloc> counter[64];\n    int fill = 0;\n    while(!empty()){\n        carry.splice(carry.begin(), *this, begin());\n        int i = 0;\n        while(i < fill && !counter[i].empty()){\n            counter[i].merge(carry);\n            carry.swap(counter[i++]);\n        }\n        carry.swap(counter[i]);\n        if(i == fill)\n            ++fill;\n    }\n    for(int i = 1; i < fill; ++i)\n        counter[i].merge(counter[i-1]);\n    swap(counter[fill-1]);\n}\n```","slug":"浅读《STL源码剖析》笔记-4章-vector和list","published":1,"updated":"2018-03-06T08:42:21.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjep2nr6l001j04d86yvzdhak","content":"<h2 id=\"4-序列式容器\"><a href=\"#4-序列式容器\" class=\"headerlink\" title=\"4 序列式容器\"></a>4 序列式容器</h2><h3 id=\"4-1-容器的概观与分类\"><a href=\"#4-1-容器的概观与分类\" class=\"headerlink\" title=\"4.1 容器的概观与分类\"></a>4.1 容器的概观与分类</h3><p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801311638_540.png-960.jpg\" alt=\"SGI STL的各个容器\"><br>所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。<br><a id=\"more\"></a></p>\n<h3 id=\"4-2-vector\"><a href=\"#4-2-vector\" class=\"headerlink\" title=\"4.2 vector\"></a>4.2 vector</h3><h4 id=\"4-2-1-vector概述\"><a href=\"#4-2-1-vector概述\" class=\"headerlink\" title=\"4.2.1 vector概述\"></a>4.2.1 vector概述</h4><p>array是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。</p>\n<h4 id=\"4-2-3-vector的迭代器\"><a href=\"#4-2-3-vector的迭代器\" class=\"headerlink\" title=\"4.2.3 vector的迭代器\"></a>4.2.3 vector的迭代器</h4><p>由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。<code>vector&lt;int&gt; :: iterator ivite;vector&lt;Shape&gt; :: iterator svite;</code>其中 <code>ivite</code>的类型就是<code>int*</code>，<code>svite</code>的类型就是<code>Shape*</code> 。</p>\n<h4 id=\"4-2-4-vector的数据结构\"><a href=\"#4-2-4-vector的数据结构\" class=\"headerlink\" title=\"4.2.4 vector的数据结构\"></a>4.2.4 vector的数据结构</h4><p>vector的数据结构如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span> = <span class=\"title\">alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">vecotr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置</span></span><br><span class=\"line\">        iterator start;             <span class=\"comment\">//表示目前使用空间的头部</span></span><br><span class=\"line\">        iterator finish;            <span class=\"comment\">//表示目前使用空间的尾部</span></span><br><span class=\"line\">        iterator end_of_storage;    <span class=\"comment\">//表示目前可用空间的尾部</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。<br>运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。</p>\n<h4 id=\"4-2-5-vector的构造与内存管理：constructor，push-back\"><a href=\"#4-2-5-vector的构造与内存管理：constructor，push-back\" class=\"headerlink\" title=\"4.2.5 vector的构造与内存管理：constructor，push_back\"></a>4.2.5 vector的构造与内存管理：constructor，push_back</h4><p>push_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。<strong>因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。</strong>push_back源代码节选如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">( <span class=\"keyword\">const</span> T&amp; x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( finish != end_of_storage )&#123;</span><br><span class=\"line\">        construct( finish, x );</span><br><span class=\"line\">        ++finish;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>    <span class=\"comment\">//无备用空间</span></span><br><span class=\"line\">    insert_aux(end(), x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">vector</span>&lt;T, Alloc&gt;:</span>:insert_aux( iterator positon, <span class=\"keyword\">const</span> T&amp; x )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( finish != end_of_storage )&#123; <span class=\"comment\">//为什么还要再次判断</span></span><br><span class=\"line\">        construct( finish, *(finish - <span class=\"number\">1</span>));</span><br><span class=\"line\">        ++finish;</span><br><span class=\"line\">        T x_copy = x;</span><br><span class=\"line\">        <span class=\"comment\">//不懂</span></span><br><span class=\"line\">        copy_backward(position, finish - <span class=\"number\">2</span>, finish - <span class=\"number\">1</span>);</span><br><span class=\"line\">        *position = x_copy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//无备用空间</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> size_type old_size = size();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> size_type len = old_size != <span class=\"number\">0</span> ? <span class=\"number\">2</span>*old_size : <span class=\"number\">1</span>;</span><br><span class=\"line\">        iterator new_start = data_allocator::allocatr(len); <span class=\"comment\">//实际配置空间</span></span><br><span class=\"line\">        iterator new_finish = new_start;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//将原来vector内容拷贝到新的vector</span></span><br><span class=\"line\">            new_finish = uninitialized_copy(start, position, new_start);</span><br><span class=\"line\">            <span class=\"comment\">//为新元素设定初值x</span></span><br><span class=\"line\">            construct(new_finish, x);</span><br><span class=\"line\">            ++new_finish;</span><br><span class=\"line\">            <span class=\"comment\">//将安插点的原内容也拷贝过来//不懂</span></span><br><span class=\"line\">            new_finish = uninitialized_copy(posiition, finish, new_finish);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span>(...)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//开辟失败</span></span><br><span class=\"line\">            destroy(new_start, new_finish);</span><br><span class=\"line\">            data_allocator::deallocate(new_start, len);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//析构并释放原vector</span></span><br><span class=\"line\">        destory(begin(), end());</span><br><span class=\"line\">        deallocate();</span><br><span class=\"line\">        <span class=\"comment\">//调整迭代器，指向新的vector</span></span><br><span class=\"line\">        start = new_start;</span><br><span class=\"line\">        finish = new_finish;</span><br><span class=\"line\">        end_of_storage = new_start+len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-2-6-vector的元素操作：pop-back-erase-clear-insert\"><a href=\"#4-2-6-vector的元素操作：pop-back-erase-clear-insert\" class=\"headerlink\" title=\"4.2.6 vector的元素操作：pop_back, erase, clear, insert\"></a>4.2.6 vector的元素操作：pop_back, erase, clear, insert</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//清除[first, last)中的元素</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">    iterator ii = copy(last, finish, first);    <span class=\"comment\">//copy是全局函数，第六章</span></span><br><span class=\"line\">    destory(i, finish);</span><br><span class=\"line\">    finish = finish - (last - first);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//清除某个位置上的元素</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator position)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(position + <span class=\"number\">1</span> != end())</span><br><span class=\"line\">        copy(position + <span class=\"number\">1</span>, finish, position);</span><br><span class=\"line\">    --finish;</span><br><span class=\"line\">    destroy(finish);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>&#123; erase(begin(), end()); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从position开始，插入n个元素，元素初值为x</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">vector</span>&lt;T, Alloc&gt;:</span>:insert(iterator position, size_type n ,<span class=\"keyword\">const</span> T&amp; x)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//备用空间大于等于新增元素个数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(size_type(end_of_storage - finish) &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            T x_copy = x;</span><br><span class=\"line\">            <span class=\"comment\">//计算插入点之后的现有元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type elems_after = finish - position;</span><br><span class=\"line\">            iterator old_finish = finish;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(elems_after &gt; n)&#123;    <span class=\"comment\">//插入点之后的现有元素个数 &gt; 新增元素个数</span></span><br><span class=\"line\">                uninitialized_copy(finish - n, finish, finish);</span><br><span class=\"line\">                finish += n;    <span class=\"comment\">//将vector 尾端标记后移</span></span><br><span class=\"line\">                copy_backward(position, old_finish - n, old_finish);</span><br><span class=\"line\">                fill(position, position+n, x_copy); <span class=\"comment\">//从插入点开始填入新值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                uninitialized_fill_n(finish, n-elems_affter, x_copy);</span><br><span class=\"line\">                finish += n - elems_after;</span><br><span class=\"line\">                uninitialized_copy(position, old_finish, finish);</span><br><span class=\"line\">                finish += elems_after;</span><br><span class=\"line\">                fill(position, old_finish, x_copy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//备用空间 &lt; 新增元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type old_size = size();</span><br><span class=\"line\">            <span class=\"comment\">//决定新的长度为旧长度+新增元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type len = old_size + max(old_size, n);</span><br><span class=\"line\">            <span class=\"comment\">//配置新的vector空间</span></span><br><span class=\"line\">            iterator new_start = data_allocaator::allocate(len);</span><br><span class=\"line\">            iterator new_finish = new_start;</span><br><span class=\"line\">            __STL_TRY&#123;  <span class=\"comment\">//&lt;-- 这个是什么</span></span><br><span class=\"line\">                <span class=\"comment\">//将旧的vector在插入点之前的元素复制到新空间</span></span><br><span class=\"line\">                new_finish = uninitialized_copy(start, position, new_start);</span><br><span class=\"line\">                <span class=\"comment\">//将新增元素(初值为x)填入新空间</span></span><br><span class=\"line\">                new_finish = uninitialized_fill_n(new_finish, n, x);</span><br><span class=\"line\">                <span class=\"comment\">//将旧的vector在插入点之后的元素复制到新空间</span></span><br><span class=\"line\">                nwe_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//异常处理</span></span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//清除释放旧的空间</span></span><br><span class=\"line\">            destroy(start，finish);</span><br><span class=\"line\">            deallocate();</span><br><span class=\"line\">            <span class=\"comment\">//调整迭代器指向新的空间</span></span><br><span class=\"line\">            start = new_start;</span><br><span class=\"line\">            finish = new_finish;</span><br><span class=\"line\">            end_of_storage = new_start+len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//插入操作完成之后，新增节点应位于position的后面。</span></span><br></pre></td></tr></table></figure>\n<p>图解如下：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021439_772.png-960.jpg\" alt=\"insert\"></p>\n<h3 id=\"4-3-list\"><a href=\"#4-3-list\" class=\"headerlink\" title=\"4.3 list\"></a>4.3 list</h3><h4 id=\"4-3-1-list概述\"><a href=\"#4-3-1-list概述\" class=\"headerlink\" title=\"4.3.1 list概述\"></a>4.3.1 list概述</h4><p>list每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。</p>\n<h4 id=\"4-3-2-list的节点-node\"><a href=\"#4-3-2-list的节点-node\" class=\"headerlink\" title=\"4.3.2 list的节点(node)\"></a>4.3.2 list的节点(node)</h4><p>list的节点和list本身的设计是分开的。以下是STL list的节点结构：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> __<span class=\"title\">list_node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* void_pointer;</span><br><span class=\"line\">    void_pointer prev;  <span class=\"comment\">//型别为void*，其实可以是__list_node&lt;T&gt;</span></span><br><span class=\"line\">    void_pointer next;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//这是一个双向链表节点</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-3-3-list的迭代器\"><a href=\"#4-3-3-list的迭代器\" class=\"headerlink\" title=\"4.3.3 list的迭代器\"></a>4.3.3 list的迭代器</h4><p><strong>list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效</strong></p>\n<h4 id=\"4-3-4-list的数据结构\"><a href=\"#4-3-4-list的数据结构\" class=\"headerlink\" title=\"4.3.4 list的数据结构\"></a>4.3.4 list的数据结构</h4><p>SGI list 是一个双向循环链表。list结构如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span> = <span class=\"title\">alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">list</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> list_node* link_type;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    link_type node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> (link_type)((*node).next); &#125;</span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> node; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> node-&gt;next == node; &#125;</span><br><span class=\"line\"><span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    size_type result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    distance(begin(), end(), result);   <span class=\"comment\">//全局函数，第三章//计算两个迭代器之间的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">reference <span class=\"title\">front</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> *begin(); &#125;</span><br><span class=\"line\"><span class=\"function\">reference <span class=\"title\">back</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> *(--end()); &#125;</span><br></pre></td></tr></table></figure></p>\n<p>图解如下：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021641_929.png-960.jpg\" alt=\"list\"></p>\n<h4 id=\"4-3-5-list的构造与内存管理：constructor，-push-back-insert\"><a href=\"#4-3-5-list的构造与内存管理：constructor，-push-back-insert\" class=\"headerlink\" title=\"4.3.5 list的构造与内存管理：constructor， push_back, insert\"></a>4.3.5 list的构造与内存管理：constructor， push_back, insert</h4><p>list缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。<code>list_node_alloctor(n)</code>表示配置n个节点空间。同时有四个函数，如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//配置一个节点并传回</span></span><br><span class=\"line\"><span class=\"function\">link_type <span class=\"title\">get_node</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//释放一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put_node</span><span class=\"params\">(link_type p)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//配置并构造一个节点，带有元素值</span></span><br><span class=\"line\"><span class=\"function\">link_type <span class=\"title\">create_node</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; x)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//析构并释放一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy_node</span><span class=\"params\">(link_type p)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>list众多构造函数中，有一个允许我们构造一个空list出来：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">list</span>()&#123; empty_initialize(); &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">empty_initialize</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//next、prev指针都指向自己</span></span><br><span class=\"line\">        node = get_node();</span><br><span class=\"line\">        node-&gt;next = node;</span><br><span class=\"line\">        node-&gt;prev = node;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>空节点对象模型：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021656_767.png-960.jpg\" alt=\"空节点\"><br>当我们用push_back()插入新节点的时候，函数内部调用insert()<code>void push_back(const T&amp; x) { inset( end(), x ); }</code>insert()有很多的重载函数，最简单的如下:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在迭代器position所指位置插入一个节点，值为x</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">insert</span><span class=\"params\">(iterator position, <span class=\"keyword\">const</span> T&amp; x)</span></span>&#123;</span><br><span class=\"line\">    link_type tmp = create_node(x);</span><br><span class=\"line\">    <span class=\"comment\">//插入位置在position之前,这是STL规范。</span></span><br><span class=\"line\">    tmp-&gt;next = position.node;</span><br><span class=\"line\">    tmp-&gt;prev = position.node-&gt;prev;</span><br><span class=\"line\">    (link_type(position.node-&gt;node-&gt;prev))-&gt;next = tmp;</span><br><span class=\"line\">    position.node-&gt;prev = tmp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-3-6-list的元素操作：push-front-push-back-erase-pop-front-pop-back-clear-remove-unique-splice-merge-reverse-sort\"><a href=\"#4-3-6-list的元素操作：push-front-push-back-erase-pop-front-pop-back-clear-remove-unique-splice-merge-reverse-sort\" class=\"headerlink\" title=\"4.3.6 list的元素操作：push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort\"></a>4.3.6 list的元素操作：<code>push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort</code></h4><p>push_front, push_back复用insert；pop_front, pop_back复用erase。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//移除迭代器position所指节点</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator position)</span></span>&#123;</span><br><span class=\"line\">    link_type next_node = link_type(position.node-&gt;next);</span><br><span class=\"line\">    link_type prev_node = link_type(position.node-&gt;prev);</span><br><span class=\"line\">    prev_node-&gt;next = next_node;</span><br><span class=\"line\">    next_node-&gt;prev = prev_node;</span><br><span class=\"line\">    destroy_node(position.node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> iterator(next_node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//清除所有节点</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:clear()&#123;</span><br><span class=\"line\">    link_type cur = (link__type) node-&gt;next;    <span class=\"comment\">//begin();</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur != node )&#123;</span><br><span class=\"line\">        link_type tmp - cur;</span><br><span class=\"line\">        cur = (link_type)cur-&gt;next;</span><br><span class=\"line\">        destroy_node(tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//恢复成空节点的初始结构</span></span><br><span class=\"line\">    node-&gt;next = node;</span><br><span class=\"line\">    node-&gt;prev = node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//将数值为value的所有元素移除</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:remove(<span class=\"keyword\">const</span> T&amp; value)&#123;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    iterator last = end();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first != last)&#123;</span><br><span class=\"line\">        iterator next = first;</span><br><span class=\"line\">        ++next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first == value) erase(first);</span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个</span></span><br><span class=\"line\"><span class=\"comment\">//很帅啊</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:unique()&#123;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    iterator last = end();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(first == last) <span class=\"keyword\">return</span>;   <span class=\"comment\">//判空</span></span><br><span class=\"line\">    iterator next = first;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(++next != last)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first == *next)</span><br><span class=\"line\">            erase(next);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            first = next;</span><br><span class=\"line\">        next = first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>list 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//将[first, last)内的所有元素移动到position之前。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(iterator position, iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(position != last)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//先处理各节点的next</span></span><br><span class=\"line\">            (*(link_type((*last.node).prev))).next = position.node;</span><br><span class=\"line\">            (*(link_type((*first.node).prev))).next = last.node;</span><br><span class=\"line\">            (*(link_type((*position.node).prev))).next = first.node;</span><br><span class=\"line\">            <span class=\"comment\">//tmp为position的prev节点</span></span><br><span class=\"line\">            link_type tmp = link_type((*position.node).prev);</span><br><span class=\"line\">            <span class=\"comment\">//处理各节点的prev</span></span><br><span class=\"line\">            (*position.node).prev = (*last.node).prev;</span><br><span class=\"line\">            (*last.node).prev = (*first.node).prev;</span><br><span class=\"line\">            (*first.node).prev = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>splice各个版本：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//将list x接合与position所指位置之前，x必须不同于*this</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator position, <span class=\"built_in\">list</span>&amp; x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x.empty())</span><br><span class=\"line\">            transfer(position, x.begin(), x.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将i 所指元素接合于position所指元素之前。position和i可指向同一个list</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator position, <span class=\"built_in\">list</span>&amp;, iterator i)</span></span>&#123;</span><br><span class=\"line\">        iterator j = i;</span><br><span class=\"line\">        ++j;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(position == i || position == j) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        trasfer(position, i, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将[first, last)内的所有元素接合于position所指位置之前，</span></span><br><span class=\"line\">    <span class=\"comment\">//position和[first, last)可指向同一个list。</span></span><br><span class=\"line\">    <span class=\"comment\">//但是position不能在[first, last)范围之内</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator posiition, <span class=\"built_in\">list</span>&amp;, iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first != last)</span><br><span class=\"line\">            transfer(position, first, last);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>merge(), reverse(), sort()源码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//merge()将x合并到*this上，两个list必须是递增排序的</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:merge(<span class=\"built_in\">list</span>&lt;T, Alloc&gt;&amp; x)&#123;</span><br><span class=\"line\">    iterator first1 = begin();</span><br><span class=\"line\">    iterator last1 = end();</span><br><span class=\"line\">    iterator first2 = x.begin();</span><br><span class=\"line\">    iterator last2 = x.end();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first1 != last1 &amp;&amp; first2 != last2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first2 &lt; *first1)&#123;</span><br><span class=\"line\">            iterator next = first2;</span><br><span class=\"line\">            transfer(first1, first2, ++next);</span><br><span class=\"line\">            first2 = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            ++first1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first2 !=  last2) transfer(last1, first2,last2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//reverse()将*this的内容逆置</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:reverse()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判空或只有一个节点，用size() == 0 || size() == 1速度比较慢</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    ++first;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first != end())&#123;</span><br><span class=\"line\">        iterator old = first;</span><br><span class=\"line\">        ++first;</span><br><span class=\"line\">        transfer(begin(), old, first);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//list不能使用STL中的sort()算法，只能使用自己的sort()</span></span><br><span class=\"line\"><span class=\"comment\">//因为STL的sort()只接受RamdonAccessIterator</span></span><br><span class=\"line\"><span class=\"comment\">//本函数使用quick sort</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:sort()&#123;</span><br><span class=\"line\">     <span class=\"comment\">//判空或只有一个节点，用size() == 0 || size() == 1速度比较慢</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建新的list空间，作为中介数据存放区</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;T, Alloc&gt; carry;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;T, Alloc&gt; counter[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fill = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!empty())&#123;</span><br><span class=\"line\">        carry.splice(carry.begin(), *<span class=\"keyword\">this</span>, begin());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; fill &amp;&amp; !counter[i].empty())&#123;</span><br><span class=\"line\">            counter[i].merge(carry);</span><br><span class=\"line\">            carry.swap(counter[i++]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        carry.swap(counter[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == fill)</span><br><span class=\"line\">            ++fill;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; fill; ++i)</span><br><span class=\"line\">        counter[i].merge(counter[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    swap(counter[fill<span class=\"number\">-1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"4-序列式容器\"><a href=\"#4-序列式容器\" class=\"headerlink\" title=\"4 序列式容器\"></a>4 序列式容器</h2><h3 id=\"4-1-容器的概观与分类\"><a href=\"#4-1-容器的概观与分类\" class=\"headerlink\" title=\"4.1 容器的概观与分类\"></a>4.1 容器的概观与分类</h3><p><img src=\"http://p3ax8ersb.bkt.clouddn.com/201801311638_540.png-960.jpg\" alt=\"SGI STL的各个容器\"><br>所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。<br>","more":"</p>\n<h3 id=\"4-2-vector\"><a href=\"#4-2-vector\" class=\"headerlink\" title=\"4.2 vector\"></a>4.2 vector</h3><h4 id=\"4-2-1-vector概述\"><a href=\"#4-2-1-vector概述\" class=\"headerlink\" title=\"4.2.1 vector概述\"></a>4.2.1 vector概述</h4><p>array是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。</p>\n<h4 id=\"4-2-3-vector的迭代器\"><a href=\"#4-2-3-vector的迭代器\" class=\"headerlink\" title=\"4.2.3 vector的迭代器\"></a>4.2.3 vector的迭代器</h4><p>由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。<code>vector&lt;int&gt; :: iterator ivite;vector&lt;Shape&gt; :: iterator svite;</code>其中 <code>ivite</code>的类型就是<code>int*</code>，<code>svite</code>的类型就是<code>Shape*</code> 。</p>\n<h4 id=\"4-2-4-vector的数据结构\"><a href=\"#4-2-4-vector的数据结构\" class=\"headerlink\" title=\"4.2.4 vector的数据结构\"></a>4.2.4 vector的数据结构</h4><p>vector的数据结构如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span> = <span class=\"title\">alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">vecotr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置</span></span><br><span class=\"line\">        iterator start;             <span class=\"comment\">//表示目前使用空间的头部</span></span><br><span class=\"line\">        iterator finish;            <span class=\"comment\">//表示目前使用空间的尾部</span></span><br><span class=\"line\">        iterator end_of_storage;    <span class=\"comment\">//表示目前可用空间的尾部</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。<br>运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。</p>\n<h4 id=\"4-2-5-vector的构造与内存管理：constructor，push-back\"><a href=\"#4-2-5-vector的构造与内存管理：constructor，push-back\" class=\"headerlink\" title=\"4.2.5 vector的构造与内存管理：constructor，push_back\"></a>4.2.5 vector的构造与内存管理：constructor，push_back</h4><p>push_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。<strong>因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。</strong>push_back源代码节选如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">( <span class=\"keyword\">const</span> T&amp; x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( finish != end_of_storage )&#123;</span><br><span class=\"line\">        construct( finish, x );</span><br><span class=\"line\">        ++finish;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>    <span class=\"comment\">//无备用空间</span></span><br><span class=\"line\">    insert_aux(end(), x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">vector</span>&lt;T, Alloc&gt;:</span>:insert_aux( iterator positon, <span class=\"keyword\">const</span> T&amp; x )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( finish != end_of_storage )&#123; <span class=\"comment\">//为什么还要再次判断</span></span><br><span class=\"line\">        construct( finish, *(finish - <span class=\"number\">1</span>));</span><br><span class=\"line\">        ++finish;</span><br><span class=\"line\">        T x_copy = x;</span><br><span class=\"line\">        <span class=\"comment\">//不懂</span></span><br><span class=\"line\">        copy_backward(position, finish - <span class=\"number\">2</span>, finish - <span class=\"number\">1</span>);</span><br><span class=\"line\">        *position = x_copy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//无备用空间</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> size_type old_size = size();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> size_type len = old_size != <span class=\"number\">0</span> ? <span class=\"number\">2</span>*old_size : <span class=\"number\">1</span>;</span><br><span class=\"line\">        iterator new_start = data_allocator::allocatr(len); <span class=\"comment\">//实际配置空间</span></span><br><span class=\"line\">        iterator new_finish = new_start;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//将原来vector内容拷贝到新的vector</span></span><br><span class=\"line\">            new_finish = uninitialized_copy(start, position, new_start);</span><br><span class=\"line\">            <span class=\"comment\">//为新元素设定初值x</span></span><br><span class=\"line\">            construct(new_finish, x);</span><br><span class=\"line\">            ++new_finish;</span><br><span class=\"line\">            <span class=\"comment\">//将安插点的原内容也拷贝过来//不懂</span></span><br><span class=\"line\">            new_finish = uninitialized_copy(posiition, finish, new_finish);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span>(...)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//开辟失败</span></span><br><span class=\"line\">            destroy(new_start, new_finish);</span><br><span class=\"line\">            data_allocator::deallocate(new_start, len);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//析构并释放原vector</span></span><br><span class=\"line\">        destory(begin(), end());</span><br><span class=\"line\">        deallocate();</span><br><span class=\"line\">        <span class=\"comment\">//调整迭代器，指向新的vector</span></span><br><span class=\"line\">        start = new_start;</span><br><span class=\"line\">        finish = new_finish;</span><br><span class=\"line\">        end_of_storage = new_start+len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-2-6-vector的元素操作：pop-back-erase-clear-insert\"><a href=\"#4-2-6-vector的元素操作：pop-back-erase-clear-insert\" class=\"headerlink\" title=\"4.2.6 vector的元素操作：pop_back, erase, clear, insert\"></a>4.2.6 vector的元素操作：pop_back, erase, clear, insert</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//清除[first, last)中的元素</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">    iterator ii = copy(last, finish, first);    <span class=\"comment\">//copy是全局函数，第六章</span></span><br><span class=\"line\">    destory(i, finish);</span><br><span class=\"line\">    finish = finish - (last - first);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//清除某个位置上的元素</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator position)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(position + <span class=\"number\">1</span> != end())</span><br><span class=\"line\">        copy(position + <span class=\"number\">1</span>, finish, position);</span><br><span class=\"line\">    --finish;</span><br><span class=\"line\">    destroy(finish);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> position;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>&#123; erase(begin(), end()); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从position开始，插入n个元素，元素初值为x</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">vector</span>&lt;T, Alloc&gt;:</span>:insert(iterator position, size_type n ,<span class=\"keyword\">const</span> T&amp; x)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//备用空间大于等于新增元素个数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(size_type(end_of_storage - finish) &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            T x_copy = x;</span><br><span class=\"line\">            <span class=\"comment\">//计算插入点之后的现有元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type elems_after = finish - position;</span><br><span class=\"line\">            iterator old_finish = finish;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(elems_after &gt; n)&#123;    <span class=\"comment\">//插入点之后的现有元素个数 &gt; 新增元素个数</span></span><br><span class=\"line\">                uninitialized_copy(finish - n, finish, finish);</span><br><span class=\"line\">                finish += n;    <span class=\"comment\">//将vector 尾端标记后移</span></span><br><span class=\"line\">                copy_backward(position, old_finish - n, old_finish);</span><br><span class=\"line\">                fill(position, position+n, x_copy); <span class=\"comment\">//从插入点开始填入新值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                uninitialized_fill_n(finish, n-elems_affter, x_copy);</span><br><span class=\"line\">                finish += n - elems_after;</span><br><span class=\"line\">                uninitialized_copy(position, old_finish, finish);</span><br><span class=\"line\">                finish += elems_after;</span><br><span class=\"line\">                fill(position, old_finish, x_copy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//备用空间 &lt; 新增元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type old_size = size();</span><br><span class=\"line\">            <span class=\"comment\">//决定新的长度为旧长度+新增元素个数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> size_type len = old_size + max(old_size, n);</span><br><span class=\"line\">            <span class=\"comment\">//配置新的vector空间</span></span><br><span class=\"line\">            iterator new_start = data_allocaator::allocate(len);</span><br><span class=\"line\">            iterator new_finish = new_start;</span><br><span class=\"line\">            __STL_TRY&#123;  <span class=\"comment\">//&lt;-- 这个是什么</span></span><br><span class=\"line\">                <span class=\"comment\">//将旧的vector在插入点之前的元素复制到新空间</span></span><br><span class=\"line\">                new_finish = uninitialized_copy(start, position, new_start);</span><br><span class=\"line\">                <span class=\"comment\">//将新增元素(初值为x)填入新空间</span></span><br><span class=\"line\">                new_finish = uninitialized_fill_n(new_finish, n, x);</span><br><span class=\"line\">                <span class=\"comment\">//将旧的vector在插入点之后的元素复制到新空间</span></span><br><span class=\"line\">                nwe_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//异常处理</span></span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//清除释放旧的空间</span></span><br><span class=\"line\">            destroy(start，finish);</span><br><span class=\"line\">            deallocate();</span><br><span class=\"line\">            <span class=\"comment\">//调整迭代器指向新的空间</span></span><br><span class=\"line\">            start = new_start;</span><br><span class=\"line\">            finish = new_finish;</span><br><span class=\"line\">            end_of_storage = new_start+len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//插入操作完成之后，新增节点应位于position的后面。</span></span><br></pre></td></tr></table></figure>\n<p>图解如下：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021439_772.png-960.jpg\" alt=\"insert\"></p>\n<h3 id=\"4-3-list\"><a href=\"#4-3-list\" class=\"headerlink\" title=\"4.3 list\"></a>4.3 list</h3><h4 id=\"4-3-1-list概述\"><a href=\"#4-3-1-list概述\" class=\"headerlink\" title=\"4.3.1 list概述\"></a>4.3.1 list概述</h4><p>list每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。</p>\n<h4 id=\"4-3-2-list的节点-node\"><a href=\"#4-3-2-list的节点-node\" class=\"headerlink\" title=\"4.3.2 list的节点(node)\"></a>4.3.2 list的节点(node)</h4><p>list的节点和list本身的设计是分开的。以下是STL list的节点结构：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">struct</span> __<span class=\"title\">list_node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>* void_pointer;</span><br><span class=\"line\">    void_pointer prev;  <span class=\"comment\">//型别为void*，其实可以是__list_node&lt;T&gt;</span></span><br><span class=\"line\">    void_pointer next;</span><br><span class=\"line\">    T data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//这是一个双向链表节点</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-3-3-list的迭代器\"><a href=\"#4-3-3-list的迭代器\" class=\"headerlink\" title=\"4.3.3 list的迭代器\"></a>4.3.3 list的迭代器</h4><p><strong>list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效</strong></p>\n<h4 id=\"4-3-4-list的数据结构\"><a href=\"#4-3-4-list的数据结构\" class=\"headerlink\" title=\"4.3.4 list的数据结构\"></a>4.3.4 list的数据结构</h4><p>SGI list 是一个双向循环链表。list结构如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span> = <span class=\"title\">alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">list</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> list_node* link_type;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    link_type node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> (link_type)((*node).next); &#125;</span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> node; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> node-&gt;next == node; &#125;</span><br><span class=\"line\"><span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    size_type result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    distance(begin(), end(), result);   <span class=\"comment\">//全局函数，第三章//计算两个迭代器之间的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">reference <span class=\"title\">front</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> *begin(); &#125;</span><br><span class=\"line\"><span class=\"function\">reference <span class=\"title\">back</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> *(--end()); &#125;</span><br></pre></td></tr></table></figure></p>\n<p>图解如下：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021641_929.png-960.jpg\" alt=\"list\"></p>\n<h4 id=\"4-3-5-list的构造与内存管理：constructor，-push-back-insert\"><a href=\"#4-3-5-list的构造与内存管理：constructor，-push-back-insert\" class=\"headerlink\" title=\"4.3.5 list的构造与内存管理：constructor， push_back, insert\"></a>4.3.5 list的构造与内存管理：constructor， push_back, insert</h4><p>list缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。<code>list_node_alloctor(n)</code>表示配置n个节点空间。同时有四个函数，如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//配置一个节点并传回</span></span><br><span class=\"line\"><span class=\"function\">link_type <span class=\"title\">get_node</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//释放一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put_node</span><span class=\"params\">(link_type p)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//配置并构造一个节点，带有元素值</span></span><br><span class=\"line\"><span class=\"function\">link_type <span class=\"title\">create_node</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; x)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//析构并释放一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy_node</span><span class=\"params\">(link_type p)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>list众多构造函数中，有一个允许我们构造一个空list出来：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">list</span>()&#123; empty_initialize(); &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">empty_initialize</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//next、prev指针都指向自己</span></span><br><span class=\"line\">        node = get_node();</span><br><span class=\"line\">        node-&gt;next = node;</span><br><span class=\"line\">        node-&gt;prev = node;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>空节点对象模型：<img src=\"http://p3ax8ersb.bkt.clouddn.com/201802021656_767.png-960.jpg\" alt=\"空节点\"><br>当我们用push_back()插入新节点的时候，函数内部调用insert()<code>void push_back(const T&amp; x) { inset( end(), x ); }</code>insert()有很多的重载函数，最简单的如下:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在迭代器position所指位置插入一个节点，值为x</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">insert</span><span class=\"params\">(iterator position, <span class=\"keyword\">const</span> T&amp; x)</span></span>&#123;</span><br><span class=\"line\">    link_type tmp = create_node(x);</span><br><span class=\"line\">    <span class=\"comment\">//插入位置在position之前,这是STL规范。</span></span><br><span class=\"line\">    tmp-&gt;next = position.node;</span><br><span class=\"line\">    tmp-&gt;prev = position.node-&gt;prev;</span><br><span class=\"line\">    (link_type(position.node-&gt;node-&gt;prev))-&gt;next = tmp;</span><br><span class=\"line\">    position.node-&gt;prev = tmp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-3-6-list的元素操作：push-front-push-back-erase-pop-front-pop-back-clear-remove-unique-splice-merge-reverse-sort\"><a href=\"#4-3-6-list的元素操作：push-front-push-back-erase-pop-front-pop-back-clear-remove-unique-splice-merge-reverse-sort\" class=\"headerlink\" title=\"4.3.6 list的元素操作：push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort\"></a>4.3.6 list的元素操作：<code>push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort</code></h4><p>push_front, push_back复用insert；pop_front, pop_back复用erase。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//移除迭代器position所指节点</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(iterator position)</span></span>&#123;</span><br><span class=\"line\">    link_type next_node = link_type(position.node-&gt;next);</span><br><span class=\"line\">    link_type prev_node = link_type(position.node-&gt;prev);</span><br><span class=\"line\">    prev_node-&gt;next = next_node;</span><br><span class=\"line\">    next_node-&gt;prev = prev_node;</span><br><span class=\"line\">    destroy_node(position.node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> iterator(next_node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//清除所有节点</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:clear()&#123;</span><br><span class=\"line\">    link_type cur = (link__type) node-&gt;next;    <span class=\"comment\">//begin();</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>( cur != node )&#123;</span><br><span class=\"line\">        link_type tmp - cur;</span><br><span class=\"line\">        cur = (link_type)cur-&gt;next;</span><br><span class=\"line\">        destroy_node(tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//恢复成空节点的初始结构</span></span><br><span class=\"line\">    node-&gt;next = node;</span><br><span class=\"line\">    node-&gt;prev = node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//将数值为value的所有元素移除</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:remove(<span class=\"keyword\">const</span> T&amp; value)&#123;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    iterator last = end();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first != last)&#123;</span><br><span class=\"line\">        iterator next = first;</span><br><span class=\"line\">        ++next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first == value) erase(first);</span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个</span></span><br><span class=\"line\"><span class=\"comment\">//很帅啊</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:unique()&#123;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    iterator last = end();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(first == last) <span class=\"keyword\">return</span>;   <span class=\"comment\">//判空</span></span><br><span class=\"line\">    iterator next = first;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(++next != last)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first == *next)</span><br><span class=\"line\">            erase(next);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            first = next;</span><br><span class=\"line\">        next = first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>list 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//将[first, last)内的所有元素移动到position之前。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(iterator position, iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(position != last)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//先处理各节点的next</span></span><br><span class=\"line\">            (*(link_type((*last.node).prev))).next = position.node;</span><br><span class=\"line\">            (*(link_type((*first.node).prev))).next = last.node;</span><br><span class=\"line\">            (*(link_type((*position.node).prev))).next = first.node;</span><br><span class=\"line\">            <span class=\"comment\">//tmp为position的prev节点</span></span><br><span class=\"line\">            link_type tmp = link_type((*position.node).prev);</span><br><span class=\"line\">            <span class=\"comment\">//处理各节点的prev</span></span><br><span class=\"line\">            (*position.node).prev = (*last.node).prev;</span><br><span class=\"line\">            (*last.node).prev = (*first.node).prev;</span><br><span class=\"line\">            (*first.node).prev = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>splice各个版本：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//将list x接合与position所指位置之前，x必须不同于*this</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator position, <span class=\"built_in\">list</span>&amp; x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x.empty())</span><br><span class=\"line\">            transfer(position, x.begin(), x.end());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将i 所指元素接合于position所指元素之前。position和i可指向同一个list</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator position, <span class=\"built_in\">list</span>&amp;, iterator i)</span></span>&#123;</span><br><span class=\"line\">        iterator j = i;</span><br><span class=\"line\">        ++j;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(position == i || position == j) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        trasfer(position, i, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将[first, last)内的所有元素接合于position所指位置之前，</span></span><br><span class=\"line\">    <span class=\"comment\">//position和[first, last)可指向同一个list。</span></span><br><span class=\"line\">    <span class=\"comment\">//但是position不能在[first, last)范围之内</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splice</span><span class=\"params\">(iterator posiition, <span class=\"built_in\">list</span>&amp;, iterator first, iterator last)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first != last)</span><br><span class=\"line\">            transfer(position, first, last);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>merge(), reverse(), sort()源码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//merge()将x合并到*this上，两个list必须是递增排序的</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:merge(<span class=\"built_in\">list</span>&lt;T, Alloc&gt;&amp; x)&#123;</span><br><span class=\"line\">    iterator first1 = begin();</span><br><span class=\"line\">    iterator last1 = end();</span><br><span class=\"line\">    iterator first2 = x.begin();</span><br><span class=\"line\">    iterator last2 = x.end();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first1 != last1 &amp;&amp; first2 != last2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*first2 &lt; *first1)&#123;</span><br><span class=\"line\">            iterator next = first2;</span><br><span class=\"line\">            transfer(first1, first2, ++next);</span><br><span class=\"line\">            first2 = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            ++first1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(first2 !=  last2) transfer(last1, first2,last2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//reverse()将*this的内容逆置</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:reverse()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判空或只有一个节点，用size() == 0 || size() == 1速度比较慢</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    iterator first = begin();</span><br><span class=\"line\">    ++first;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(first != end())&#123;</span><br><span class=\"line\">        iterator old = first;</span><br><span class=\"line\">        ++first;</span><br><span class=\"line\">        transfer(begin(), old, first);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//list不能使用STL中的sort()算法，只能使用自己的sort()</span></span><br><span class=\"line\"><span class=\"comment\">//因为STL的sort()只接受RamdonAccessIterator</span></span><br><span class=\"line\"><span class=\"comment\">//本函数使用quick sort</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Alloc</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">list</span>&lt;T, Alloc&gt;:</span>:sort()&#123;</span><br><span class=\"line\">     <span class=\"comment\">//判空或只有一个节点，用size() == 0 || size() == 1速度比较慢</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建新的list空间，作为中介数据存放区</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;T, Alloc&gt; carry;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>&lt;T, Alloc&gt; counter[<span class=\"number\">64</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fill = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!empty())&#123;</span><br><span class=\"line\">        carry.splice(carry.begin(), *<span class=\"keyword\">this</span>, begin());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; fill &amp;&amp; !counter[i].empty())&#123;</span><br><span class=\"line\">            counter[i].merge(carry);</span><br><span class=\"line\">            carry.swap(counter[i++]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        carry.swap(counter[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == fill)</span><br><span class=\"line\">            ++fill;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; fill; ++i)</span><br><span class=\"line\">        counter[i].merge(counter[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    swap(counter[fill<span class=\"number\">-1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjep2nqyc000104d87h90nbre","category_id":"cjep2nqym000304d8496neorb","_id":"cjep2nqz1000a04d8zlgg8mbh"},{"post_id":"cjep2nqyj000204d88k0hf42v","category_id":"cjep2nqyx000704d8i5tn7euz","_id":"cjep2nqz6000e04d8egycvvs9"},{"post_id":"cjep2nqz3000c04d8grpfybv5","category_id":"cjep2nqz2000b04d8ajvwvdxi","_id":"cjep2nqzg000m04d8me52k98e"},{"post_id":"cjep2nqz3000c04d8grpfybv5","category_id":"cjep2nqzd000j04d87uyz9k6p","_id":"cjep2nqzg000n04d8l8rqv3qz"},{"post_id":"cjep2nqyo000404d84l1ffc2o","category_id":"cjep2nqz2000b04d8ajvwvdxi","_id":"cjep2nqzi000p04d80bpg8vsc"},{"post_id":"cjep2nqyo000404d84l1ffc2o","category_id":"cjep2nqzd000j04d87uyz9k6p","_id":"cjep2nqzj000q04d8hoai620z"},{"post_id":"cjep2nqyr000504d8fsryf793","category_id":"cjep2nqz7000f04d87b70d5pr","_id":"cjep2nqzk000s04d892qpm5t6"},{"post_id":"cjep2nqyr000504d8fsryf793","category_id":"cjep2nqzh000o04d8riqwjz3t","_id":"cjep2nqzn000u04d8qxyuk19d"},{"post_id":"cjep2nqyv000604d8l0r84dxr","category_id":"cjep2nqz8000g04d8urjaqpfr","_id":"cjep2nqzp000w04d884eyaydw"},{"post_id":"cjep2nqyv000604d8l0r84dxr","category_id":"cjep2nqzj000r04d8v7s7dykx","_id":"cjep2nqzp000x04d8ypweqm4g"},{"post_id":"cjep2nqyy000804d8a7nvkwa0","category_id":"cjep2nqz2000b04d8ajvwvdxi","_id":"cjep2nqzq000z04d8m4073dk5"},{"post_id":"cjep2nqyy000804d8a7nvkwa0","category_id":"cjep2nqzd000j04d87uyz9k6p","_id":"cjep2nqzr001004d8ab8kbeli"},{"post_id":"cjep2nqz0000904d8mvj1zljp","category_id":"cjep2nqz2000b04d8ajvwvdxi","_id":"cjep2nqzr001104d86awfk5n7"},{"post_id":"cjep2nqz0000904d8mvj1zljp","category_id":"cjep2nqzd000j04d87uyz9k6p","_id":"cjep2nqzs001204d8oqho4t2o"},{"post_id":"cjep2nqz5000d04d88qoqxezl","category_id":"cjep2nqz8000g04d8urjaqpfr","_id":"cjep2nqzt001304d8o4cjmjjy"},{"post_id":"cjep2nqz5000d04d88qoqxezl","category_id":"cjep2nqzj000r04d8v7s7dykx","_id":"cjep2nqzu001404d8wd98wkcn"},{"post_id":"cjep2nr62001504d81ahbscve","category_id":"cjep2nqz2000b04d8ajvwvdxi","_id":"cjep2nr6b001a04d8nz59oj5m"},{"post_id":"cjep2nr62001504d81ahbscve","category_id":"cjep2nqzd000j04d87uyz9k6p","_id":"cjep2nr6e001c04d8q8gwutfd"},{"post_id":"cjep2nr65001704d8nf66ss4n","category_id":"cjep2nqz8000g04d8urjaqpfr","_id":"cjep2nr6g001e04d819ywv2nm"},{"post_id":"cjep2nr65001704d8nf66ss4n","category_id":"cjep2nqzj000r04d8v7s7dykx","_id":"cjep2nr6i001g04d8onox7vrw"},{"post_id":"cjep2nr67001804d8dk701zbf","category_id":"cjep2nqz7000f04d87b70d5pr","_id":"cjep2nr6l001i04d8d6a3nmu2"},{"post_id":"cjep2nr67001804d8dk701zbf","category_id":"cjep2nqzh000o04d8riqwjz3t","_id":"cjep2nr6n001k04d872pn9ain"},{"post_id":"cjep2nr69001904d82bs90axi","category_id":"cjep2nqz8000g04d8urjaqpfr","_id":"cjep2nr6o001l04d8rgzo8hvq"},{"post_id":"cjep2nr69001904d82bs90axi","category_id":"cjep2nqzj000r04d8v7s7dykx","_id":"cjep2nr6p001m04d82zh2wa61"},{"post_id":"cjep2nr6c001b04d8kbfjkst5","category_id":"cjep2nqz8000g04d8urjaqpfr","_id":"cjep2nr6q001n04d85um2qcwv"},{"post_id":"cjep2nr6c001b04d8kbfjkst5","category_id":"cjep2nqzj000r04d8v7s7dykx","_id":"cjep2nr6q001o04d84tjmh08u"},{"post_id":"cjep2nr6f001d04d81eqqjwk3","category_id":"cjep2nqym000304d8496neorb","_id":"cjep2nr6r001p04d8jaup9pco"},{"post_id":"cjep2nr6h001f04d8xkd1w7lc","category_id":"cjep2nqym000304d8496neorb","_id":"cjep2nr6r001q04d8xdg19fpc"},{"post_id":"cjep2nr6j001h04d82reamiii","category_id":"cjep2nqym000304d8496neorb","_id":"cjep2nr6s001r04d8o05nmvan"},{"post_id":"cjep2nr6l001j04d86yvzdhak","category_id":"cjep2nqym000304d8496neorb","_id":"cjep2nr6s001s04d84k127skt"}],"PostTag":[],"Tag":[]}}