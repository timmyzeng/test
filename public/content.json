{"meta":{"title":"青匆","subtitle":"","description":"为即将来临的精彩。","author":"timmy","url":"http://www.jingxxn.cn"},"pages":[{"title":"","date":"2018-02-17T02:37:02.037Z","updated":"2018-02-17T02:37:02.037Z","comments":true,"path":"baidu_verify_aF8IqoDm9Z.html","permalink":"http://www.jingxxn.cn/baidu_verify_aF8IqoDm9Z.html","excerpt":"","text":"aF8IqoDm9Z"},{"title":"categories","date":"2018-01-27T09:16:23.000Z","updated":"2018-01-27T11:01:04.502Z","comments":false,"path":"categories/index.html","permalink":"http://www.jingxxn.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"查看Linux系统版本信息","slug":"查看Linux系统版本信息","date":"2018-03-08T03:44:55.000Z","updated":"2018-03-08T08:32:20.222Z","comments":true,"path":"查看Linux系统版本信息.html","link":"","permalink":"http://www.jingxxn.cn/查看Linux系统版本信息.html","excerpt":"查看内核版本 cat /proc/version uname -a","text":"查看内核版本 cat /proc/version uname -a 查看系统版本 cat /etc/redhat-release lsb_release -a 这个命令需要安装，安装命令： yum install lsb -y cat /etc/issue 都说可以，这个我的查出来很奇怪 rpm -q centos-release 查看cpu相关信息，包括型号、主频、内核等信息 cat /proc/cpuinfo 参考地址1参考地址2","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.jingxxn.cn/categories/Linux/"},{"name":"method","slug":"Linux/method","permalink":"http://www.jingxxn.cn/categories/Linux/method/"}],"tags":[]},{"title":"Linux中时间的设置","slug":"Linux中时间的设置","date":"2018-03-08T03:36:45.000Z","updated":"2018-03-08T12:17:29.692Z","comments":true,"path":"Linux中时间的设置.html","link":"","permalink":"http://www.jingxxn.cn/Linux中时间的设置.html","excerpt":"test: CentOS Linux release 7.4.1708 (Core) 查看时区 data -R +0800 表示在东八区其中：CST：中国标准时间（China Standard Time），这个解释可能是针对RedHat Linux。UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。UTC较于GMT更准确。GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。 修改时区 tzselect","text":"test: CentOS Linux release 7.4.1708 (Core) 查看时区 data -R +0800 表示在东八区其中：CST：中国标准时间（China Standard Time），这个解释可能是针对RedHat Linux。UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。UTC较于GMT更准确。GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。 修改时区 tzselect 这个命令并不是用来修改时区的，这个命令可以通过你自己的选择然后清楚的知道每个时区的样式。然后你通过修改.progile、.bash_profile或者/etc/profile文件，设置正确的TZ环境变量并导出，可以成功改变时区。 tip：这些修改应该出现用户家目录下下面例子，我将时区由东八区改变为波兰的时区，东一区：先通过tzselect查询波兰的时区书写格式：然后通过修改文件.bash_profile并应用得以修改。 通过替换系统时区文件，或者创建链接文件 1、在目录/usr/share/zoneinfo中有所有的时区文件，通过复制替换到/etc/locatime即可但是有的时候会出现没有效果的情况，比如上例子。这是因为修改了在profile或.bash_profile中设置了TZ。这个时候就需要重新修改TZ。 2、创建链接文件这里如果出现修改失败，同上。 查看和修改时间和日期 datedate用于查看和设置 系统时间 如果不输入命令”hwclock -w”将时间写入硬件时间，电脑重启之后将会返回原样。 hwclockhwclock用来查看设置 硬件时间。 hwclock –hctosyshc代表硬件时间，sys代表系统时间，即用硬件时钟同步系统时钟 hwclock –systohc即用系统时钟同步硬件时钟,等于 hwclock -w 执行完这两个命令系统没有任何反馈。 解释一下硬件时钟和系统时钟的区别：硬件时钟指的是主板上由电池供电的那个时间，可以在BIOS中设置。Linux可以通过hwclock设置。当Linux启动的时候，硬件时钟会赋值给系统时钟。然后系统时钟会独立于硬件时钟工作。系统时钟指的是当前Linux Kernel中的时钟。Linux中的所有命令包括函数都是采用系统时钟设置的。这就是为什么当我们用date修改了时间，没有同步到硬件时钟的时候，这个修改是无效的。 时间自动同步 yum install -y ntpdate首先安装ntpdate软件，用来同步Linux时间服务。 ntpdate time.nist.gov 上面表示同步成功，调整时间为服务器129.6.15.29的时间，时间相差0.136318 sec hwclock -w调整硬件时间 crontab -e设定crontab计划任务自动校时，并添加下列内容0 1 * ntpdate time.nist.gov这样设定一个小时自动进行网络校时。 通过cat /etc/crontab 查看crontab的设置解释，如下：参考文章1参考文章2","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.jingxxn.cn/categories/Linux/"},{"name":"method","slug":"Linux/method","permalink":"http://www.jingxxn.cn/categories/Linux/method/"}],"tags":[]},{"title":"判断元素的入栈和出栈顺序是否合法","slug":"判断元素的入栈和出栈顺序是否一致","date":"2018-03-07T06:46:00.000Z","updated":"2018-03-07T07:48:17.619Z","comments":true,"path":"判断元素的入栈和出栈顺序是否一致.html","link":"","permalink":"http://www.jingxxn.cn/判断元素的入栈和出栈顺序是否一致.html","excerpt":"题目提供两个元素的集合，一个是元素入栈的顺序，另一个是元素出栈的顺序。设计一个函数，判断两个元素集合是否满足入栈出栈的规则。如：入栈顺序：“12345”，出栈顺序是：“54321”，这样就是符合要求的。如果出栈顺序是：“51234”，这样不符合要求。","text":"题目提供两个元素的集合，一个是元素入栈的顺序，另一个是元素出栈的顺序。设计一个函数，判断两个元素集合是否满足入栈出栈的规则。如：入栈顺序：“12345”，出栈顺序是：“54321”，这样就是符合要求的。如果出栈顺序是：“51234”，这样不符合要求。 思路根据题目的要求，就是判断两数组是否满足出栈入栈的顺序。可以这样做：1、先按照入栈顺序的集合进行入栈。2、在入栈的同时，跟出栈顺序的元素进行比较。如果相同就将入栈的元素pop出来。3、结束的时候，如果栈为空，说明两者的入栈顺序和出栈顺序可以匹配，那么就是符合要求的；如果栈不为空，那就是不符合要求。还有一点：如果两元素的个数不一样或者同时为空，直接判定不符合要求。 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;bool stack_io_right(char* src, char* dst)&#123; int src_len = sizeof(src); int dst_len = sizeof(dst); int i = 0; int j = 0; if(src_len == 0 || src_len != dst_len) return false; for(; i &lt; src_len; ++i)&#123; s.push(*(src+i)); while(s.size() &amp;&amp; s.top() == *(dst+j))&#123; ++j; s.pop(); &#125; &#125; if(s.empty()) return true; else return false;&#125;int main()&#123; system(\"clear\"); char src[] = \"12345\"; char dst[] = \"32145\"; char dst1[] = \"51243\"; cout &lt;&lt; stack_io_right(src, dst) &lt;&lt; endl; cout &lt;&lt; stack_io_right(src, dst1) &lt;&lt; endl; return 0;&#125; 运行结果","categories":[{"name":"practice","slug":"practice","permalink":"http://www.jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://www.jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"二叉树的基本实现","slug":"二叉树的基本实现","date":"2018-03-06T07:47:19.000Z","updated":"2018-03-06T09:16:54.673Z","comments":true,"path":"二叉树的基本实现.html","link":"","permalink":"http://www.jingxxn.cn/二叉树的基本实现.html","excerpt":"二叉树本文将使用c++实现模板类的二叉树，内容包括创建、递归遍历、非递归遍历、结点个数、深度、叶子结点的个数、第K层结点个数等函数。 结点、二叉树结构二叉树的结点是一个结构体，包括值_data，指向左子树的指针和指向右子树的指针_left和_right。还有构造函数，用于创建结点。","text":"二叉树本文将使用c++实现模板类的二叉树，内容包括创建、递归遍历、非递归遍历、结点个数、深度、叶子结点的个数、第K层结点个数等函数。 结点、二叉树结构二叉树的结点是一个结构体，包括值_data，指向左子树的指针和指向右子树的指针_left和_right。还有构造函数，用于创建结点。将BinaryTreeNode&lt;T&gt;typedef为Node,很多时候我会遗漏模板的类型名需要加上&lt;T&gt;，这样就会出错。为了减少这种错误，索性用typedef换名。&lt;12345678910111213141516171819202122template &lt;class T&gt;struct BinaryTreeNode&#123; BinaryTreeNode* _left; BinaryTreeNode* _right; T _data; BinaryTreeNode(const T&amp; data = T())&#123; _data = data; _left = NULL; _right = NULL; &#125;&#125;;template &lt;class T&gt;class BinaryTree&#123;typedef BinaryTreeNode&lt;T&gt; Node;public: //...protected: Node* _root;&#125;; 默认成员函数构造函数设置了两个构造函数，一个为空，用于创建一个空的二叉树；另一个参数为两个。const T* a 数组名const T&amp; invalid 非法值解释一下，这里我用一个数组创建二叉树，同时用’#’表示这个空。如这个例子： int a1[] = {1,2,3,&apos;#&apos;,&apos;#&apos;,4,&apos;#&apos;,&apos;#&apos;,5,6,&apos;#&apos;,&apos;#&apos;,&apos;#&apos;}; 如果a1[i] != &#39;#&#39;那么就创建，反之，表示这个位置没有结点。1234567891011121314151617//constructorBinaryTree()&#123; _root = NULL;&#125;BinaryTree(const T* a, const T&amp; invalid)&#123; size_t index = 0; _root = _CreateTree(a, invalid, index);&#125;Node* _CreateTree(const T* a, const T&amp; invalid, size_t&amp; index)&#123; Node* root = NULL; if(a[index] != invalid)&#123; root = new Node(a[index]); root-&gt;_left = _CreateTree(a, invalid, ++index); root-&gt;_right = _CreateTree(a, invalid, ++index); &#125; return root;&#125; 构造函数利用递归的思想，先跟的次序创建二叉树。由于要利用到递归，就没有办法直接用构造函数来实现，因为在class之外是没有办法访问到_root的。所以通过一个函数，利用这个函数来实现递归的过程。构造出来的二叉树关系图： 拷贝构造拷贝构造利用了一个_CopyTree函数。123456789101112BinaryTree(const BinaryTree&amp; tree)&#123; _root = _CopyTree(tree._root);&#125;Node* _CopyTree(Node* root)&#123; Node* node = root; if(node)&#123; node = new Node(root-&gt;_data); node-&gt;_left = _CopyTree(root-&gt;_left); node-&gt;_right = _CopyTree(root-&gt;_right); &#125; return node;&#125; 析构函数析构函数利用了一个Destroy函数1234567891011//destructor~BinaryTree()&#123; Destroy(_root);&#125;void Destroy(Node* root)&#123; if(root == NULL) return; Destroy(root-&gt;_left); Destroy(root-&gt;_right); delete root;&#125; operator=(赋值运算符的重载)先调用析构函数的Destroy销毁当前二叉树，然后调用_CopyTree重新构造当前二叉树。123456789101112131415//operator=BinaryTree&lt;T&gt;&amp; operator=(const BinaryTree&lt;T&gt;&amp; tree)&#123; if(this != &amp;tree)&#123; Destroy(_root); _root = _CopyTree(tree._root); return *this; &#125;&#125;//BinaryTree&lt;T&gt;&amp; operator=(BinaryTree&lt;T&gt; tree)&#123; //if(this != &amp;tree)&#123; //swap(_root, tree._root); //return *this; //&#125;//&#125; 赋值运算符的重载有两种实现方式，第一种是传统写法，第二种是现代写法。传统写法就是销毁原来的空间，然后重新开辟新的空间。对内存的操作比较多。现代写法是利用拷贝构造的方式，在传值进来的时候，生成一份临时拷贝，然后交换当前二叉树和临时拷贝的根节点，返回根节点，同时利用临时拷贝的作用域，交换后的二叉树在出了当前函数之后被销毁。相当于借用了系统的拷贝机制和自动析构机制来实现赋值的过程。 递归遍历先序遍历先序遍历：root left right12345678910111213//PrevOrdervoid PrevOrder()&#123; _PrevOrder(_root); cout &lt;&lt; endl;&#125;void _PrevOrder(Node* root)&#123; if(root)&#123; cout &lt;&lt; root-&gt;_data &lt;&lt; \" \"; _PrevOrder(root-&gt;_left); _PrevOrder(root-&gt;_right); &#125; return;&#125; 中序遍历中序遍历：left root right12345678910111213//InOrdervoid InOrder()&#123; _InOreder(_root); cout &lt;&lt; endl;&#125;void _InOreder(Node* root)&#123; if(root)&#123; _InOreder(root-&gt;_left); cout &lt;&lt; root-&gt;_data &lt;&lt; \" \"; _InOreder(root-&gt;_right); &#125; return;&#125; 后序遍历后序遍历：left root right12345678910111213//PostOrdervoid PostOrder()&#123; _PostOrder(_root); cout &lt;&lt; endl;&#125;void _PostOrder(Node* root)&#123; if(root)&#123; _PostOrder(root-&gt;_left); _PostOrder(root-&gt;_right); cout &lt;&lt; root-&gt;_data &lt;&lt; \" \"; &#125; return;&#125; 非递归遍历之所以要出现非递归遍历，是因为递归遍历有一定的缺陷。比如：当二叉树是一颗父节点只有一个子节点的树，那么对堆栈的使用就很大，有可能出现堆栈使用太深而栈溢出的情况。为了避免这种情况的出现，有必要使用非递归遍历。非递归遍历利用栈来实现对之前的结点的存储，因为每一颗二叉树都有可能有左右子树，所以需要在访问单边的子树的时候，将结点保存下来，这样是为了之后可以返回去访问结点的另一边的子树。 层次遍历层次遍历是一层一层的遍历结点的。它与之前三个的遍历方式都不一样。他利用的是队列，通过队列让父节点带动子节点。123456789101112131415161718192021//LevelOrdervoid LevelOrder()&#123; //不能是T，要用到root-&gt;_left; root-&gt;_right; //不好是Node，结构体太大; queue&lt;Node*&gt; q; if(_root)&#123; q.push(_root); while(!q.empty())&#123; Node* top = q.front(); //获取到队头之后，将当前结点pop q.pop(); cout &lt;&lt; top-&gt;_data &lt;&lt; \" \"; //如果左右子树存在，就入队列 if(top-&gt;_left) q.push(top-&gt;_left); if(top-&gt;_right) q.push(top-&gt;_right); &#125; &#125; cout &lt;&lt; endl;&#125; 先序遍历非递归根据先序遍历的特点，先输出当前结点，然后一路向左，访问完左边再返回访问上一个结点的右子树，这个就是子问题，利用上面一样的方法。1234567891011121314151617181920//PrevOrderNonRvoid PrevOrderNonR()&#123; //利用栈得以记录访问过的根，用来以后访问右子树 stack&lt;Node*&gt; s; Node* cur = _root; while(cur || !s.empty())&#123; //根据先根的次序，访问当前节点，并一路向左访问 while(cur)&#123; cout &lt;&lt; cur-&gt;_data &lt;&lt; \" \"; s.push(cur); cur = cur-&gt;_left; &#125; Node* top = s.top(); //pop表示左子树已经访问完，接下来访问右子树 s.pop(); //右子树的访问是子问题 cur = top-&gt;_right; &#125; cout &lt;&lt; endl;&#125; 中序遍历非递归中序遍历和先序遍历唯一的不同就是先序遍历是访问当前结点就打印当前结点，中序遍历就是先走完左边，再回来获取结点，这个时候再输出。12345678910111213141516//InOrderNonRvoid InOrderNonR()&#123; stack&lt;Node*&gt; s; Node* cur = _root; while(cur || !s.empty())&#123; while(cur)&#123; s.push(cur); cur = cur-&gt;_left; &#125; Node* top = s.top(); s.pop(); cout &lt;&lt; top-&gt;_data &lt;&lt; \" \"; cur = top-&gt;_right; &#125; cout &lt;&lt; endl;&#125; 后序遍历非递归后序遍历相比于之前的有一个转弯，看下图：所以为了区分这个点，先设立一个prev，prev指向当前结点cur的上一个结点。如果prev == cur-&gt;_right表示当前结点的右子树已经访问完成，那么就可以输出cur了。12345678910111213141516171819202122232425262728//PostOrderNonRvoid PostOrderNonR()&#123; stack&lt;Node*&gt; s; Node* cur = _root; Node* prev = NULL; while(cur || !s.empty())&#123; //一路向左走到底 while(cur)&#123; s.push(cur); cur = cur-&gt;_left; &#125; Node* top = s.top(); //访问当前结点的两个条件 //1、没有右子树 //2、右子树已经访问完成 if(top-&gt;_right == NULL || prev == top-&gt;_right)&#123; s.pop(); //此时的top成为过去式，将top设置为prev prev = top; cout &lt;&lt; top-&gt;_data &lt;&lt; \" \"; &#125; //此时表示右子树还没有访问 else&#123; cur = top-&gt;_right; &#125; &#125; cout &lt;&lt; endl;&#125; 结点个数函数以下函数都利用了递归的思想。 统计结点个数函数Size123456789//Sizesize_t Size()&#123; return _Size(_root);&#125;size_t _Size(Node* root)&#123; if(root == NULL) return 0; return _Size(root-&gt;_left) + _Size(root-&gt;_right) + 1;&#125; 统计深度函数Depth统计深度的时候，因为二叉树有左右子树，所以需要区分是左子树结点多还是右子树结点多。通过两个变量来记录，分别统计大小，然后再比较大小，大的是深度。这里默认根节点是第一层12345678910111213141516//Depthsize_t Depth()&#123; return _Depth(_root);&#125;size_t _Depth(Node* root)&#123; size_t leftnum = 0; size_t rightnum = 0; if(root == NULL) return 0; //如果存在就接着往下递归 if(root-&gt;_left) leftnum += _Depth(root-&gt;_left); if(root-&gt;_right) rightnum += _Depth(root-&gt;_right); return (leftnum &gt; rightnum ? leftnum : rightnum) + 1;&#125; 统计叶子结点个数的函数LeafSize叶子结点的统计是在当前结点都没有左右子树的时候返回个数1。1234567891011//LeafSizesize_t LeafSize()&#123; return _LeafSize(_root);&#125;size_t _LeafSize(Node* root)&#123; if(root == NULL) return 0; if(root-&gt;_left == NULL &amp;&amp; root-&gt;_right == NULL) return 1; return _LeafSize(root-&gt;_left) + _LeafSize(root-&gt;_right);&#125; 计算第K层的结点个数函数GetKLevel这个函数可以通过子问题的思想来解决。比如：我要计算第三层，当指针在第一层的时候，是计算K=3；当指针在第二层的时候，是计算K=2；当指针在第三层的时候，是计算K=1的结点个数。所以只要当K=1的时候返回计算值1就好了。12345678910111213//GetKLevelsize_t GetKLevel(size_t K)&#123; return _GetKLevel(_root, K);&#125;size_t _GetKLevel(Node* root, size_t K)&#123; if(K == 0 || root == NULL) return 0; if(K == 1) return 1; //不能使用--K，应该用K-1。 //不能返回除了K=1的其他情况。 return _GetKLevel(root-&gt;_left, K - 1) + _GetKLevel(root-&gt;_right, K - 1);&#125; 测试代码1234567891011121314151617181920212223242526272829303132int a1[] = &#123;1,2,3,'#','#',4,'#','#',5,6,'#','#','#'&#125;;int a2[] = &#123;1,2,'#',3,'#','#',4,5,'#',6,'#',7,'#','#',8,'#','#'&#125;;BinaryTree&lt;int&gt; tree(a1,'#');BinaryTree&lt;int&gt; tree1(a2, '#');BinaryTree&lt;int&gt; tree2(tree);tree2 = tree1;cout &lt;&lt; \"tree.PrevOrder\" &lt;&lt; endl;tree.PrevOrder();cout &lt;&lt; \"tree1.InOrder\" &lt;&lt; endl;tree1.InOrder();cout &lt;&lt; \"tree2.PostOrder\" &lt;&lt; endl;tree2.PostOrder();cout &lt;&lt; \"tree.LevelOrder\" &lt;&lt; endl;tree.LevelOrder();cout &lt;&lt; \"tree.PrevOrderNonR\" &lt;&lt; endl;tree.PrevOrderNonR();cout &lt;&lt; \"tree1.InOrderNonR\" &lt;&lt; endl;tree1.InOrderNonR();cout &lt;&lt; \"tree2.PostOrderNonR\" &lt;&lt; endl;tree2.PostOrderNonR();cout &lt;&lt; \"tree.Size:\" &lt;&lt; tree.Size() &lt;&lt; endl;cout &lt;&lt; \"tree.Depth:\" &lt;&lt; tree.Depth() &lt;&lt; endl;cout &lt;&lt; \"tree.LeafSize:\" &lt;&lt; tree.LeafSize() &lt;&lt; endl;cout &lt;&lt; \"tree.GetKLevel(K=2):\" &lt;&lt; tree.GetKLevel(2) &lt;&lt; endl;cout &lt;&lt; \"tree1.Size:\" &lt;&lt; tree1.Size() &lt;&lt; endl;cout &lt;&lt; \"tree1.Depth:\" &lt;&lt; tree1.Depth() &lt;&lt; endl;cout &lt;&lt; \"tree1.LeafSize:\" &lt;&lt; tree1.LeafSize() &lt;&lt; endl;cout &lt;&lt; \"tree1.GetKLevel(K=3):\" &lt;&lt; tree1.GetKLevel(3) &lt;&lt; endl; 截图如下：二叉树的实现，最重要的是要掌握子问题的思想，通过子问题的思想来解决左右子树，只需要一个递归就好了。","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"智能指针","slug":"智能指针","date":"2018-02-25T01:28:08.000Z","updated":"2018-02-26T07:50:16.314Z","comments":true,"path":"智能指针.html","link":"","permalink":"http://www.jingxxn.cn/智能指针.html","excerpt":"智能指针是C++中一个编程技巧。它保证内存的正确释放，解决了内存泄漏的问题。有一个思想叫做RAII，RAII指的是资源分配即初始化。我们通常会定义一个类来封装资源的分配和释放，在构造函数中完成资源的分配和初始化，在析构函数中完成资源的清理。在C++中，我们一般是使用new和delete来实现内存的初始化和释放。正确的配对使用可以处理绝大部分问题，但是如果出现了执行流的跳转，比如：语句中间出现了return，break，continue，goto，等关键字，我们的delete可能没有执行，这样就导致了内存没有被释放。又或者我们的语句出现了错误，抛出异常导致程序结束，也有可能没有执行delete语句。这 些问题都导致了内存泄漏。智能指针的出现就是为了解决这些问题的。智能指针其实是一个类，它可以自动的处理指针指向的动态资源的释放。 发展历程","text":"智能指针是C++中一个编程技巧。它保证内存的正确释放，解决了内存泄漏的问题。有一个思想叫做RAII，RAII指的是资源分配即初始化。我们通常会定义一个类来封装资源的分配和释放，在构造函数中完成资源的分配和初始化，在析构函数中完成资源的清理。在C++中，我们一般是使用new和delete来实现内存的初始化和释放。正确的配对使用可以处理绝大部分问题，但是如果出现了执行流的跳转，比如：语句中间出现了return，break，continue，goto，等关键字，我们的delete可能没有执行，这样就导致了内存没有被释放。又或者我们的语句出现了错误，抛出异常导致程序结束，也有可能没有执行delete语句。这 些问题都导致了内存泄漏。智能指针的出现就是为了解决这些问题的。智能指针其实是一个类，它可以自动的处理指针指向的动态资源的释放。 发展历程 早期C++98：auto_ptr，最早出现的智能指针，拷贝机制是管理权转移，致命缺陷，不使用。 boost(非官方)： scoped_ptr/scoped_array：守卫指针，拷贝机制是不拷贝，简单粗暴 shared_ptr/shared_array：共享指针，拷贝机制是引用计数，比较复杂，会出现循环引用的问题。 weak_ptr：弱指针，不单独使用，辅助共享指针解决循环引用的问题 C++11：unique_ptr对应boost的scoped_ptr；shared_ptr对应boost的shared_ptr；weak_ptr对应boost的weak_ptr。 本文主要实现shared_ptr和weak_ptr的模拟，auto_ptr和scoped_ptr模拟拷贝相关的函数。 auto_ptr123456789101112131415161718192021222324252627282930313233343536//模拟主要函数：template &lt;class T&gt;class AutoPtr&#123;private: T* _ptr;public: AutoPtr(T* ptr)&#123; _ptr = ptr; &#125; ~AutoPtr()&#123; delete _ptr; &#125; T&amp; operator*()&#123; return *_ptr; &#125; T* operator-&gt;()&#123; return _ptr; &#125; AutoPtr(AutoPtr&lt;T&gt;&amp; ap)&#123; //管理权转移 _ptr = ap._ptr; ap._ptr = NULL; &#125; AutoPtr&lt;T&gt;&amp; operator=(AutoPtr&lt;T&gt;&amp; ap)&#123; //自己给自己赋值不作处理 if(this != &amp;ap)&#123; if(_ptr) delete _ptr; //管理权转移 _ptr = ap._ptr; ap_ptr = NULL; &#125; return *this; &#125;&#125;;int main()&#123; AutoPtr&lt;int&gt; ap1(new int(10)); AutoPtr&lt;int&gt;ap2 = ap1; //崩溃，因为ap1已经指向NULL *ap1 = 20; return 0;&#125; 图解如下：任何时候我们都不使用auto_ptr，因为管理权的转移是不符合我们正常指针的使用的，而且会引起程序崩溃，这个是不允许的。最后，解释一下，operator-&gt;()返回T*的原因：12345//设定一个类struct student&#123; int num; &#125;//调用AutoPtr&lt;student&gt; sp = new student;sp-&gt;num = 20; sp-&gt;num等价于sp.operator-&gt;()。sp.operaotr-&gt;()返回T*指针之后，编译器自动将原式优化为_ptr-&gt;num,从而实现对元素的访问。 scoped_ptr防拷贝的智能指针，boost版本相当于C++11的unique_ptr12345678//模拟拷贝的主要函数：template &lt;class T&gt;class ScopedPtr&#123;private: //与AutoPtr不同的就是这两个函数 ScopedPtr(const ScopedPtr&lt;T&gt;&amp; sp); ScopedPtr&lt;T&gt;&amp; operator= (const ScopedPtr&lt;T&gt;&amp; sp);&#125;; scoped_ptr通过将拷贝构造函数和赋值运算符重载定义为私有，同时只声明不定义，这样可以保证该类不能被拷贝。这就简单的解决了auto_ptr因为拷贝导致的管理权转移问题。 shared_ptr引用计数的智能指针，这个类除了有指针之外，再多开辟了一个内存空间，用于存放计数。这种智能指针是实现的最好的，在boost库中，实现起来很复杂，因为要考虑多线程等情况。12345678910111213141516171819202122232425262728293031323334353637383940414243//模拟主要函数template &lt;class T&gt;class SharedPtr&#123;private: T* _ptr; int* _refcount;public: //构造 SharedPtr(const T&amp; ptr)&#123; _ptr = ptr; _refcount = new int(1); &#125; //析构 ~SharedPtr()&#123; if(--_refcount == 0)&#123; delete _ptr; delete _refcount; &#125; &#125; //拷贝构造 SharedPtr(SharedPtr&lt;T&gt;&amp; sp)&#123; _ptr = sp._ptr; _refcount = sp._refcount; ++_refcount; &#125; //赋值运算符重载 SharedPtr&lt;T&gt;&amp; operator=(const SharedPtr&lt;T&gt;&amp; sp)&#123; if(*this != &amp;sp)&#123; if(--(*_refcount) == 0)&#123; delete _ptr; delete _refcount; &#125; _ptr = sp._ptr; _refcount = sp._refcount; (*_refcount)++; &#125; return *this; &#125; //*重载 T&amp; operator*()&#123; return *_ptr; &#125; //-&gt;重载 T* operator-&gt;()&#123; return _ptr; &#125;&#125;; 这个实现，将是比较实用的。但是依然有一个场景下，会出现问题。这个问题叫做循环引用，问题的根源是引用计数被循环使用，不能减为0，导致死循环。下面以双向链表作为例子：1234567891011121314151617//定义一个链表节点如下struct ListNode&#123; //构造函数... //为了方便调用，设为public int _data; SharedPtr&lt;ListNode&gt; _next; SharedPtr&lt;ListNode&gt; _prev;&#125;;//调用这个节点，设定这样一个场景int main()&#123; SharedPtr&lt;ListNode&gt; cur(new ListNode); SharedPtr&lt;ListNode&gt; next(new ListNode); cur-&gt;_next = next; next-&gt;_prev = cur;&#125; 创建模型如下：根据上面例子，_next和next都指向后面节点这个空间，next._refcount = 2。_prev和cur指向前面那个节点的空间，cur._refcount = 2。当程序结束的时候，next先被析构。若需要析构next就需要析构next._prev;要析构next._prev就需要析构cur;要析构cur就需要析构cur._next;要析构cur._next就需要析构next……这样就造成了死循环。为了解决这个循环引用的问题，引入了弱指针weak_ptr。 weak_ptr弱指针不单独使用，它的存在就是为了解决使用shared_ptr造成的循环引用问题。12345678910111213141516171819202122232425262728293031323334template &lt;class T&gt;class WeakPtr&#123;private: T* _ptr;public: WeakPtr()&#123; _ptr = NULL; &#125; WeakPtr(const SharedPtr&lt;T&gt;&amp; sp)&#123; _ptr = sp._ptr; &#125; T&amp; operator*()&#123; return *_ptr; &#125; T* operator-&gt;()&#123; return _ptr; &#125; WeakPtr&lt;T&gt;&amp; operator=(const SharedPtr&lt;T&gt;&amp; sp)&#123; _ptr = sp._ptr; return *this; &#125;&#125;;//还需要修改一下两处：//1、修改ListNode的结构struct ListNode&#123; int _data; WeakPtr&lt;ListNode&gt; _next; WeakPtr&lt;ListNode&gt; _prev;&#125;;//2、将WeakPtr定义为SharedPtr的友元，因为WeakPtr中需要访问SharedPtr的私有成员template &lt;class T&gt;class SharedPtr&#123; friend class WeakPtr; //...&#125;; 这样，上面那个例子中，next._refcount = 1，cur._refcount = 1,就不会出现循环引用的问题了。","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"模板的类型萃取","slug":"模板的类型萃取","date":"2018-02-24T06:56:38.000Z","updated":"2018-02-24T09:30:16.478Z","comments":true,"path":"模板的类型萃取.html","link":"","permalink":"http://www.jingxxn.cn/模板的类型萃取.html","excerpt":"类型萃取，是C++中的一种编程技术。当我们希望对模板传递的不同类型进行不同的操作的时候，同时我们又不希望改变该模板的封装方式。我们可以通过这种技术，对传入的不同类型进行不同的原理操作。 特化要明白类型萃取，首先要知道模板中的特化。一般来说，我们的模板是通用类型的，但是如果有一些类型，我们希望有不同的操作方式，我们就可以通过特化的方式。例子如下：","text":"类型萃取，是C++中的一种编程技术。当我们希望对模板传递的不同类型进行不同的操作的时候，同时我们又不希望改变该模板的封装方式。我们可以通过这种技术，对传入的不同类型进行不同的原理操作。 特化要明白类型萃取，首先要知道模板中的特化。一般来说，我们的模板是通用类型的，但是如果有一些类型，我们希望有不同的操作方式，我们就可以通过特化的方式。例子如下：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;//模板的一般版本template &lt;class T&gt;class number&#123;public: void show()&#123; cout &lt;&lt; \"number\" &lt;&lt; endl; &#125;&#125;;//模板的int类型特化版本template &lt;&gt;class number&lt;int&gt;&#123;public: void show()&#123; cout &lt;&lt; \"int\" &lt;&lt; endl; &#125;&#125;;int main()&#123; system(\"clear\"); number&lt;int&gt; numint; numint.show(); number&lt;float&gt; numfloat; numfloat.show(); number&lt;char&gt; numchar; numchar.show(); return 0;&#125; 只有int类型才会输出int，其它的就像是float和char类型输出的都是number特化的方式，其实是十分冗余的。如果我的number类有很多的封装，那么实现它的特化，就需要将这些封装重新实现一遍。这样的复用性就十分低。 类型萃取TypeTraits关于类型萃取的知识，可以看看我的这篇读书笔记中的3.3和3.4我的个人博客文章地址我的CSDN博客文章地址这里我进行一个对于自创类SeqList类(对STL中vector的模拟)的类型萃取举例，情景说明：这里我想要对模板类SeqList进行拷贝，涉及到一个问题。如果我的元素类型是string的话，我必须进行深拷贝，否则就会出现奔溃的情况，这是对内存的使用出现问题。当我的元素类型是int、float、char等平凡类型(即POD:plain old data，基本类型，这些类型的拷贝不会涉及到内存的使用异常)，我就可以使用浅拷贝，这样比起深拷贝提高了效率。这个时候，我通过在SeqList类中进行类型萃取，就可以实现两种不同的拷贝方式：12345678910111213141516171819202122232425262728293031323334353637383940414243//定义两个空类struct __TrueType&#123;&#125;;struct __FalseType&#123;&#125;;//一般类型及特化(内嵌重定义IsPODType)template&lt;class T&gt;struct __TypeTraits&#123; typedef __FalseType IsPODType; &#125;;template&lt;&gt;struct __TypeTraits&lt;int&gt;&#123; typedef __TrueType IsPODType; &#125;;//实现功能函数(用__TrueType/__FalseType实现重载)template &lt;class T&gt;T* __TypeCopy(T* dst, const T* src, size_t n, __TrueType)&#123; //浅拷贝，调用memcpy return (T*)memcpy(dst, src, n*sizeof(T));&#125;template &lt;class T&gt;T* __TypeCopy(T* dst, const T* src, size_t n, __FalseType)&#123; //深拷贝，进行了 operator= 调用 for(size_t i = 0; i&lt;n; ++i)&#123; dst[i] = src[i]; &#125; return dst;&#125;//对外接口(实现IsPODType的__TrueType和__FalseType的转换)template &lt;class T&gt;T* TypeCopy(T* dst, const T* src, size_t n)&#123; return __TypeCopy(dst, src, n, __TypeTraits&lt;T&gt;::IsPODType);&#125;//调用int main()&#123; int a1[3] = &#123;1, 2, 3&#125;; int a2[2] = &#123;0, 0, 0&#125;; string s1[3] = &#123;\"1\", \"2\", \"3\"&#125;; string s2[3] = &#123;\"0\", \"0\", \"0\"&#125;; TypeCopy(a1, a2, 3); TypeCopy(s1, s2, 3); return 0;&#125; 这样，当传入的参数是s1,s2的时候，__TypeTraits调用的是一般版本，IsPODType为__FalseType,这样__TypeCopy调用的是__FalseType的重载版本，进行深拷贝。当传入的参数是a1，a2的时候，调用的是__TrueType的重载版本，进行浅拷贝。这里只对int进行了特化，所以只有int可以调用__TrueType的版本。但是我们可以对float、double等PODType进行特化，这样就大大提高了代码的复用性。","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"模板与分离编译","slug":"模板与分离编译","date":"2018-02-24T06:56:19.000Z","updated":"2018-02-24T14:58:30.756Z","comments":true,"path":"模板与分离编译.html","link":"","permalink":"http://www.jingxxn.cn/模板与分离编译.html","excerpt":"分离编译模式一个项目如果有多个源文件组成，每个源文件单独编译，形成目标文件。最后通过链接器将所有的目标文件链接起来，形成一个可执行的文件。这个过程就叫做分离编译。 模板不能分离编译有一个项目，其中函数声明放在”test.h”中，函数实现放在”test.cpp”中，函数调用放在”main.cpp”中。如果没用使用模板，将不会有任何问题。而且这样是被推荐使用的。","text":"分离编译模式一个项目如果有多个源文件组成，每个源文件单独编译，形成目标文件。最后通过链接器将所有的目标文件链接起来，形成一个可执行的文件。这个过程就叫做分离编译。 模板不能分离编译有一个项目，其中函数声明放在”test.h”中，函数实现放在”test.cpp”中，函数调用放在”main.cpp”中。如果没用使用模板，将不会有任何问题。而且这样是被推荐使用的。但是如果有函数的实现是模板函数或有模板类，将会出现链接错误。代码如下:1234567891011121314151617181920//test.h#pragma oncetemplate &lt;class T&gt;void print(T num);//test.cpptemplate &lt;class T&gt;void print(T num)&#123; cout &lt;&lt; num &lt;&lt; endl; &#125;//main.cpp#include &lt;iostream&gt;#include \"test.h\"using namespace std;int main()&#123; int number = 10; print(number); return 0;&#125; 这样的代码看起来是没有问题的。执行的时候并不会出现编译错误，但是会出现链接错误。这是因为采取了分离编译之后，我们的.cpp文件是独立编译的。test.cpp中的模板函数，由于没有被调用，所以它的T并没有被实例化相应的类型，比如例子中的int类型。main.cpp中调用了函数print，他需要实例print(int num)。在链接的时候，找不到需要的实例化函数，这样就产生了错误。 解决办法1-显示实例化在函数定义的时候，指定我们需要实例化的类型。在头文件定义中添加指定类型的定义：123456#pragma oncetemplate &lt;class T&gt;void print(T num);//添加int定义template void print&lt;int&gt;(int num); 这种方式是最简单，但是这样却是最麻烦的。如果我有多个不同类型，就需要有相应个数的特化。 解决办法2-不使用分离编译既然不能使用，那么我们不使用分离编译就是了。将我们的函数声明和函数定义放在test.h中。这样我们编译的时候，需要将头文件展开，这样就可以将模板函数在编译的时候实例化。123456//test.h//不需要test.cpp#pragma oncetemplate &lt;class T&gt;void print(T num)&#123; cout &lt;&lt; num &lt;&lt; endl; &#125; 这样解决了模板的分离编译的问题，但是这样也就暴露了我们的函数定义。","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"浅读《STL源码剖析》笔记 4章-vector和list","slug":"浅读《STL源码剖析》笔记-4章-vector和list","date":"2018-02-09T02:13:57.000Z","updated":"2018-03-06T08:42:21.511Z","comments":true,"path":"浅读《STL源码剖析》笔记-4章-vector和list.html","link":"","permalink":"http://www.jingxxn.cn/浅读《STL源码剖析》笔记-4章-vector和list.html","excerpt":"4 序列式容器4.1 容器的概观与分类所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。","text":"4 序列式容器4.1 容器的概观与分类所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。 4.2 vector4.2.1 vector概述array是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。 4.2.3 vector的迭代器由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。vector&lt;int&gt; :: iterator ivite;vector&lt;Shape&gt; :: iterator svite;其中 ivite的类型就是int*，svite的类型就是Shape* 。 4.2.4 vector的数据结构vector的数据结构如下：123456789template&lt;class T, class Alloc = alloc&gt;class vecotr&#123; //... protected: //注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置 iterator start; //表示目前使用空间的头部 iterator finish; //表示目前使用空间的尾部 iterator end_of_storage; //表示目前可用空间的尾部&#125; 为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。 4.2.5 vector的构造与内存管理：constructor，push_backpush_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。push_back源代码节选如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void push_back( const T&amp; x)&#123; if( finish != end_of_storage )&#123; construct( finish, x ); ++finish; &#125; else //无备用空间 insert_aux(end(), x);&#125;template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux( iterator positon, const T&amp; x )&#123; if( finish != end_of_storage )&#123; //为什么还要再次判断 construct( finish, *(finish - 1)); ++finish; T x_copy = x; //不懂 copy_backward(position, finish - 2, finish - 1); *position = x_copy; &#125; else&#123; //无备用空间 const size_type old_size = size(); const size_type len = old_size != 0 ? 2*old_size : 1; iterator new_start = data_allocator::allocatr(len); //实际配置空间 iterator new_finish = new_start; try&#123; //将原来vector内容拷贝到新的vector new_finish = uninitialized_copy(start, position, new_start); //为新元素设定初值x construct(new_finish, x); ++new_finish; //将安插点的原内容也拷贝过来//不懂 new_finish = uninitialized_copy(posiition, finish, new_finish); &#125; catch(...)&#123; //开辟失败 destroy(new_start, new_finish); data_allocator::deallocate(new_start, len); throw; &#125; //析构并释放原vector destory(begin(), end()); deallocate(); //调整迭代器，指向新的vector start = new_start; finish = new_finish; end_of_storage = new_start+len; &#125;&#125; 4.2.6 vector的元素操作：pop_back, erase, clear, insert1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//清除[first, last)中的元素iterator erase(iterator first, iterator last)&#123; iterator ii = copy(last, finish, first); //copy是全局函数，第六章 destory(i, finish); finish = finish - (last - first); return first;&#125;//清除某个位置上的元素iterator erase(iterator position)&#123; if(position + 1 != end()) copy(position + 1, finish, position); --finish; destroy(finish); return position;&#125;void clear()&#123; erase(begin(), end()); &#125;//从position开始，插入n个元素，元素初值为xtemplate &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert(iterator position, size_type n ,const T&amp; x)&#123; if(n != 0)&#123; //备用空间大于等于新增元素个数 if(size_type(end_of_storage - finish) &gt;= 0)&#123; T x_copy = x; //计算插入点之后的现有元素个数 const size_type elems_after = finish - position; iterator old_finish = finish; if(elems_after &gt; n)&#123; //插入点之后的现有元素个数 &gt; 新增元素个数 uninitialized_copy(finish - n, finish, finish); finish += n; //将vector 尾端标记后移 copy_backward(position, old_finish - n, old_finish); fill(position, position+n, x_copy); //从插入点开始填入新值 &#125; else&#123; uninitialized_fill_n(finish, n-elems_affter, x_copy); finish += n - elems_after; uninitialized_copy(position, old_finish, finish); finish += elems_after; fill(position, old_finish, x_copy); &#125; &#125; else&#123; //备用空间 &lt; 新增元素个数 const size_type old_size = size(); //决定新的长度为旧长度+新增元素个数 const size_type len = old_size + max(old_size, n); //配置新的vector空间 iterator new_start = data_allocaator::allocate(len); iterator new_finish = new_start; __STL_TRY&#123; //&lt;-- 这个是什么 //将旧的vector在插入点之前的元素复制到新空间 new_finish = uninitialized_copy(start, position, new_start); //将新增元素(初值为x)填入新空间 new_finish = uninitialized_fill_n(new_finish, n, x); //将旧的vector在插入点之后的元素复制到新空间 nwe_finish = uninitialized_copy(position, finish, new_finish); &#125; //异常处理 //... //清除释放旧的空间 destroy(start，finish); deallocate(); //调整迭代器指向新的空间 start = new_start; finish = new_finish; end_of_storage = new_start+len; &#125; &#125;&#125;//插入操作完成之后，新增节点应位于position的后面。 图解如下： 4.3 list4.3.1 list概述list每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。 4.3.2 list的节点(node)list的节点和list本身的设计是分开的。以下是STL list的节点结构：12345678template &lt;class T&gt;struct __list_node&#123; typedef void* void_pointer; void_pointer prev; //型别为void*，其实可以是__list_node&lt;T&gt; void_pointer next; T data;&#125;//这是一个双向链表节点 4.3.3 list的迭代器list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效 4.3.4 list的数据结构SGI list 是一个双向循环链表。list结构如下：123456789template &lt;class T, class Alloc = alloc&gt;class list&#123;protected: typedef __list_node&lt;T&gt; list_node;public: typedef list_node* link_type;protected: link_type node;&#125; STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。12345678910iterator begin() &#123; return (link_type)((*node).next); &#125;iterator end() &#123; return node; &#125;bool empty() const &#123; return node-&gt;next == node; &#125;size_type size() const &#123; size_type result = 0; distance(begin(), end(), result); //全局函数，第三章//计算两个迭代器之间的距离 return result;&#125;reference front() &#123; return *begin(); &#125;reference back() &#123; return *(--end()); &#125; 图解如下： 4.3.5 list的构造与内存管理：constructor， push_back, insertlist缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。list_node_alloctor(n)表示配置n个节点空间。同时有四个函数，如下：12345678//配置一个节点并传回link_type get_node();//释放一个节点void put_node(link_type p);//配置并构造一个节点，带有元素值link_type create_node(const T&amp; x);//析构并释放一个节点void destroy_node(link_type p); list众多构造函数中，有一个允许我们构造一个空list出来：123456789public: list()&#123; empty_initialize(); &#125;protected: void empty_initialize()&#123; //next、prev指针都指向自己 node = get_node(); node-&gt;next = node; node-&gt;prev = node; &#125; 空节点对象模型：当我们用push_back()插入新节点的时候，函数内部调用insert()void push_back(const T&amp; x) { inset( end(), x ); }insert()有很多的重载函数，最简单的如下:12345678910//在迭代器position所指位置插入一个节点，值为xiterator insert(iterator position, const T&amp; x)&#123; link_type tmp = create_node(x); //插入位置在position之前,这是STL规范。 tmp-&gt;next = position.node; tmp-&gt;prev = position.node-&gt;prev; (link_type(position.node-&gt;node-&gt;prev))-&gt;next = tmp; position.node-&gt;prev = tmp; return tmp;&#125; 4.3.6 list的元素操作：push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sortpush_front, push_back复用insert；pop_front, pop_back复用erase。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//移除迭代器position所指节点iterator erase(iterator position)&#123; link_type next_node = link_type(position.node-&gt;next); link_type prev_node = link_type(position.node-&gt;prev); prev_node-&gt;next = next_node; next_node-&gt;prev = prev_node; destroy_node(position.node); return iterator(next_node);&#125;//清除所有节点template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::clear()&#123; link_type cur = (link__type) node-&gt;next; //begin(); while( cur != node )&#123; link_type tmp - cur; cur = (link_type)cur-&gt;next; destroy_node(tmp); &#125; //恢复成空节点的初始结构 node-&gt;next = node; node-&gt;prev = node;&#125;//将数值为value的所有元素移除template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::remove(const T&amp; value)&#123; iterator first = begin(); iterator last = end(); while(first != last)&#123; iterator next = first; ++next; if(*first == value) erase(first); first = next; &#125;&#125;//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个//很帅啊template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::unique()&#123; iterator first = begin(); iterator last = end(); if(first == last) return; //判空 iterator next = first; while(++next != last)&#123; if(*first == *next) erase(next); else first = next; next = first; &#125;&#125; list 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。12345678910111213141516protected: //将[first, last)内的所有元素移动到position之前。 void transfer(iterator position, iterator first, iterator last)&#123; if(position != last)&#123; //先处理各节点的next (*(link_type((*last.node).prev))).next = position.node; (*(link_type((*first.node).prev))).next = last.node; (*(link_type((*position.node).prev))).next = first.node; //tmp为position的prev节点 link_type tmp = link_type((*position.node).prev); //处理各节点的prev (*position.node).prev = (*last.node).prev; (*last.node).prev = (*first.node).prev; (*first.node).prev = tmp; &#125; &#125; splice各个版本：1234567891011121314151617181920public: //将list x接合与position所指位置之前，x必须不同于*this void splice(iterator position, list&amp; x)&#123; if(!x.empty()) transfer(position, x.begin(), x.end()); &#125; //将i 所指元素接合于position所指元素之前。position和i可指向同一个list void splice(iterator position, list&amp;, iterator i)&#123; iterator j = i; ++j; if(position == i || position == j) return; trasfer(position, i, j); &#125; //将[first, last)内的所有元素接合于position所指位置之前， //position和[first, last)可指向同一个list。 //但是position不能在[first, last)范围之内 void splice(iterator posiition, list&amp;, iterator first, iterator last)&#123; if(first != last) transfer(position, first, last); &#125; merge(), reverse(), sort()源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//merge()将x合并到*this上，两个list必须是递增排序的template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::merge(list&lt;T, Alloc&gt;&amp; x)&#123; iterator first1 = begin(); iterator last1 = end(); iterator first2 = x.begin(); iterator last2 = x.end(); while(first1 != last1 &amp;&amp; first2 != last2)&#123; if(*first2 &lt; *first1)&#123; iterator next = first2; transfer(first1, first2, ++next); first2 = next; &#125; else ++first1; if(first2 != last2) transfer(last1, first2,last2); &#125;&#125;//reverse()将*this的内容逆置template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::reverse()&#123; //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢 if(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; iterator first = begin(); ++first; while(first != end())&#123; iterator old = first; ++first; transfer(begin(), old, first); &#125;&#125;//list不能使用STL中的sort()算法，只能使用自己的sort()//因为STL的sort()只接受RamdonAccessIterator//本函数使用quick sorttemplate &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::sort()&#123; //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢 if(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; //创建新的list空间，作为中介数据存放区 list&lt;T, Alloc&gt; carry; list&lt;T, Alloc&gt; counter[64]; int fill = 0; while(!empty())&#123; carry.splice(carry.begin(), *this, begin()); int i = 0; while(i &lt; fill &amp;&amp; !counter[i].empty())&#123; counter[i].merge(carry); carry.swap(counter[i++]); &#125; carry.swap(counter[i]); if(i == fill) ++fill; &#125; for(int i = 1; i &lt; fill; ++i) counter[i].merge(counter[i-1]); swap(counter[fill-1]);&#125;","categories":[{"name":"learning","slug":"learning","permalink":"http://www.jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"浅读《STL源码剖析》笔记 3章","slug":"浅读《STL源码剖析》笔记-3章","date":"2018-02-08T09:07:30.000Z","updated":"2018-03-06T08:44:24.742Z","comments":true,"path":"浅读《STL源码剖析》笔记-3章.html","link":"","permalink":"http://www.jingxxn.cn/浅读《STL源码剖析》笔记-3章.html","excerpt":"3 迭代器(iterator)概念与traits编程技法迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式 3.1 迭代器设计思维STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一","text":"3 迭代器(iterator)概念与traits编程技法迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式 3.1 迭代器设计思维STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一 12345678910111213141516171819202122232425262728293031323334//3.1举例说明迭代器的使用//find()的定义。template &lt;class InputIterator, chass T&gt;InputIterator find( InputIterator first, InputIterator last, const T&amp; value )&#123; while ( first != last &amp;&amp; *first != value ) ++first; return first;&#125;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; const int arraySiza = 7; int ia[arraySiza] = &#123; 0, 1, 2, 3, 4, 5, 6 &#125;; vector&lt;int&gt; ivect(ia, ia+arraySiza); //调用vector的iterator用于find() vector&lt;int&gt;::iterator it1 = find(ivect.begin(), ivect.end(), 4); if( it1 == ivect.end() ) cout &lt;&lt; \"4 not found.\" &lt;&lt; endl; else cout &lt;&lt; \"4 found:\" &lt;&lt; *it1 &lt;&lt; endl; it1 = find(ivect.begin(), ivect.end(), 8); if( it1 == ivect.end() ) cout &lt;&lt; \"8 not found.\" &lt;&lt; endl; else cout &lt;&lt; \"8 found\" &lt;&lt; *it1 &lt;&lt; endl; return 0;&#125; 运行结果： 3.2 迭代器(ierator)是一种smart pointer迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-&gt; 进行重载工作。以下，简单模拟一个list的结构，然后设计对应的iterator。12345678910111213141516171819202122232425//listnodetemplate &lt;typename T&gt;class ListItem&#123;public: T value() const&#123; return _value; &#125; ListItem* next() const&#123; return _next; &#125; //...private: T _value; ListItem* _next; //单向链表(single linked list)&#125;;//listtemplate &lt;typename T&gt;class List&#123;public: void insert_front(T value); //省略实现 void insert_end(T value); //省略实现 voide display(std::ostream &amp;os = std::cout) const;//省略实现 //...private: ListItem&lt;T&gt;* _end; ListItem&lt;T&gt;* _front; long _size;&#125;; 当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：1234567891011121314151617181920212223242526//iteratortemplate &lt;class Item&gt;//Item可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的operator++只适用于链表。struct ListIter&#123; Item* ptr; //保持与容器之间的一个联系 ListIter( Item* p = 0 ) :ptr(p) &#123;&#125; //不必实现copy ctor，因为编译器提供的缺省行为已经足够 //不必实现operator=，因为编译器提供的缺省行为已经足够 Item&amp; operator*() const &#123; return *ptr; &#125; Item* operator-&gt;() const &#123; return ptr; &#125; //operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator) //pre-increament operator ListIter&amp; operator++()&#123; ptr = ptr-&gt;next(); return *this; &#125; //post-incteament operator LostIter operator++(int)&#123; ListIter tmp = *this; ++*this; return tmp; &#125; bool operator==(const LostIter&amp; i)const&#123; return ptr == i.ptr; &#125; bool operator!=(const LostIter&amp; i)const&#123; return ptr != i.ptr; &#125;&#125; 接下来，将List和find()由ListIter粘合起来：1234567891011121314151617181920int main()&#123; List&lt;int&gt; mylist; for( int i=0; i&lt;5; ++i )&#123; mylist.insert_front(i); mylist.insert_end(i+2); &#125; mylist.displau(); //10( 4 3 2 1 0 2 3 4 5 6) ListIter&lt;ListItem&lt;int&gt; &gt; begin(mylist.front()); ListIter&lt;ListItem&lt;int&gt; &gt; end; ListIter&lt;ListItem&lt;int&gt; &gt; iter; iter = find(begin, end, 3); if( iter == end ) cout &lt;&lt; \"not found\" &lt;&lt; endl; else cout &lt;&lt; \"found.\" &lt;&lt; iter-&gt;value() &lt;&lt; endl; //执行结果：found.3 return 0;&#125; 由于find() 函数以*iter != value来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 ListIterm&lt;int&gt;,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和ListIterm&lt;int&gt;。如下：12template &lt;typename T&gt;bool operator!=(const ListItem&lt;T&gt;&amp; item, T n)&#123; return item.value() != n; &#125; 3.3 迭代器相应型别(associated types)当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。 3.4 Traits 编程技法——STL源代码门钥value type：迭代器所指对象的型别。上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的”template参数推导机制”推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：123456789101112131415template &lt;class T&gt;struct MyIter&#123; typedef T value_type; //内嵌型别声明(nested type) MyIter(T* p = 0) :ptr(p) &#123;&#125; T&amp; operator*() const &#123; return *ptr; &#125; //... T* ptr; //成员变量&#125;;template &lt;class I&gt;typename I::value_type func( I ite )&#123; return *ite; &#125; //typename I::value_type 这是func的返回值型别；//...MyIter&lt;int&gt; ite(new int(8));cout &lt;&lt; func(ite); //输出:8 typename I::value_type必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。 这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 偏特化(template partial specialization)。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：12345678910//class templatetemplate &lt;typename T&gt;class C&#123; //这个泛化版本接受T为任何型别 //...&#125;;//prartial specializationtemplate &lt;typename T&gt;class C&lt;T*&gt;&#123; //这个特化版本只适用于\"T 为原生指针\"的情况 //...&#125;; 下面这个例子，专门用来萃取迭代器的特性，value type正是迭代器的特性之一1234template &lt;class I&gt;struct iterator_traits&#123; //traits意思为“特性” typedef typename I::value_type value_type;&#125;; 这样，前面那个func函数可以修改成这样。123template &lt;class I&gt;//typename iterator_traits&lt;I&gt;::value_type 是函数的返回型别typename iterator_traits&lt;I&gt;::value_type func(I ite)&#123; return *ite; &#125; 跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：1234template &lt;class T&gt;struct iterator_traits&lt;T*&gt;&#123; //偏特化版本--迭代器是一个原生指针 typedef T value_type;&#125; 此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的iterator_traits&lt;const int*&gt;::value_type得到的是const int。所以我们另外设计一个特化版本，让const T*转变为T*：1234template &lt;class T&gt;struct iterator_traits&lt;const T*&gt;&#123; //偏特化版本，当迭代器是一个const指针的时候， typedef T value_type; //萃取出来的是T，而不是const T&#125;; 到这里为止，不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。 图解iterator_traits：常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：12345678template &lt;class I&gt;struct iterator_traits&#123; typedef typename I::iterator_category iterator_category; typedef typename I::value_type value_type; typedef typename I::difference_type difference_type; typedef typename I::pointer pointer; typedef typename I::reference reference;&#125;; 其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。以上： 3.4.1 value type 如上3.4.2 difference type3.4.3 reference type3.4.4 pointer type3.4.5 iterator_catrgory","categories":[{"name":"learning","slug":"learning","permalink":"http://www.jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"浅读《STL源码剖析》笔记 1、2章","slug":"浅读《STL源码剖析》笔记-1、2章","date":"2018-02-03T03:15:06.000Z","updated":"2018-03-06T08:44:54.368Z","comments":true,"path":"浅读《STL源码剖析》笔记-1、2章.html","link":"","permalink":"http://www.jingxxn.cn/浅读《STL源码剖析》笔记-1、2章.html","excerpt":"1 STL概论与版本简介1.2 STL六大组件 容器(containers):vector,list,deque,set,map,用来存放数据 算法(algorithms):sort,search,copy,erase 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，","text":"1 STL概论与版本简介1.2 STL六大组件 容器(containers):vector,list,deque,set,map,用来存放数据 算法(algorithms):sort,search,copy,erase 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，迭代器器将operator*,operator++,operator--,operator-&gt;等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。 仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。 配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。 配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。 1.5~1.8 STL版本之二 P.J.Plauger (Microsoft Visual C++) SGI STL (Linux GCC) C++标准规范下的C头文件: cstdio,cstdlib,cstring C++标准程序库中不属于STL范畴: stream,string STL标准头文件: vector,deque,list,map,algorithm,functional C++Standard定案前，HP所规范的STL头文件: vector.h,deque.h,list.h,algo.h,function.h SGI STL内部文件(STL真正实现于此): stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h 1.9 可能令你困惑的C++语法1.9.2 临时对象的产生与运用临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。STL中最常将此技巧用在仿函数(functor)中。临时对象的生命周期只有这一行指令。 1.9.3 静态常量整数成员在class内部直接初始化class内含有const static integral data member，我们可以直接给予初值。123456789101112131415//1.9.3测试代码如下template &lt;typename T&gt;class testclass&#123;public: static const int datai = 5; static const long datal = 3L; static const char datac = 'c';&#125;;int main()&#123; cout &lt;&lt; testclass&lt;int&gt;::datai &lt;&lt; endl; cout &lt;&lt; testclass&lt;int&gt;::datal &lt;&lt; endl; cout &lt;&lt; testclass&lt;int&gt;::datac &lt;&lt; endl; return 0;&#125; 运行结果： 1.9.5 前闭后开区间表示法[)STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。 1.9.6 function call操作符(operator())function call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。如果你针对某个class进行operator()重载，它就成为一个仿函数。1234567891011121314151617//1.9.6测试代码如下template &lt;class T&gt;struct Add&#123; //重载了operator() T operator()(const T&amp;x, const T&amp;y) const&#123; return x+y; &#125;&#125;;int main()&#123; Add&lt;int&gt; addxy; system( \"clear\" ); //调用重载函数 cout &lt;&lt; addxy(3,5) &lt;&lt; endl; //调用匿名对象 cout &lt;&lt; Add&lt;int&gt;()(5,5) &lt;&lt; endl; return 0;&#125; 运行结果： 2 空间配置器(allocator)空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。 2.2 具备此配置力的SGI空间配置器2.2.1 SGI标准的空间配置器,std::allocatorSGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：vector&lt;int,std::allocator&lt;int&gt;&gt;;SGI STL写法如下：vector&lt;int, std::aloc&gt;绝大多数情况下，我们都是使用缺省的空间配置器。 2.2.2 SGI特殊的空间配置器，std::allocSGI同时也配备了标准空间配置器std::allocator，但是这只是对C++的operator new和operator delete做了一层封装，效率低下，SGI并不使用，只是为了向前兼容语法。 SGI自身使用的空间配置器是std::alloc一般来说，我们习惯的C++内存操作和释放操作是这样的：123class Foo&#123;&#125;;Foo* pf = new Foo;delete pf; 这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。STL的配置器(allocator)定于于&lt;memory&gt;，其中包含两个文件,一个是负责内存空间的配置与释放&lt;stl_alloc.h&gt;,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构&lt;stl_construct.h&gt;，定义了全局函数construct()和destroy()。 2.2.3 构造和析构基本工具:construct()和destroy()construct()的实现如下：12345#include &lt;new.h&gt; //使用placement new 需要这个头文件template &lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value)&#123; new (p) T1(value); //使用了placement new;调用T1:T1(value);&#125; 代码解释：construct()接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，通过placement new实现。destroy()有两个版本，实现如下:123456789101112131415161718192021222324252627282930//第一个版本，接受一个指针template &lt;class T&gt;inline void destroy(T* pointer)&#123; pointer-&gt;~T();&#125;//第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits&lt;&gt;求取最适当的措施。template &lt;class ForwardIterator&gt;inline void destroy(ForwardIterator first, ForwardIterator last)&#123; __destroy(first, last, value_type(first));&#125;//判断元素的数值型别(value type)是否有 trivial destructortemplate &lt;class ForwardIterator, class T&gt;inline void __destroy(ForwardIterator first, ForwardIterator last, T*)&#123; typedef typename __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor; __destroy_aux(first, last, trivial_destructor());&#125;//如果元素的数值型别(value type)有non-truvial destructor，循环释放template &lt;class ForwardIterator&gt;inline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type)&#123; for( ; first &lt; last; ++first) //调用第一个版本的destroy() destroy(&amp;* first);&#125;//如果元素的数值型别(value type)有trivial destructor,函数什么也不做template &lt;class ForwardIterator, ForwardIterator, __true_type&gt;&#123; inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type)&#123;&#125;&#125;//destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做inline void desroy(char*, char*)&#123;&#125;inline void destroy(wchar_t*,wchar_t*)&#123;&#125; 代码解释：destroy()有两个版本，第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可。第二个版本接收first和last两个迭代器，准备将[firat, last)范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓trivial destructor),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，这里首先利用value_type()获得迭代器所指对象的型别，再利用__type_traits&lt;T&gt;判断该型别的析构函数是否无关痛痒。若是(__true_type)，则什么都不做结束；若不是(__false_type),这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的destroy()。 construct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits&lt;&gt;在3.7节。 2.2.4 空间的配置与释放，std::alloc对象构造前的空间配置和对象析构后的空间释放，由&lt;stl_alloc.h&gt;负责。 向 system heap 要求空间 考虑多线程(multi-threads)状态(这里不考虑多线程的情况) 考虑内存不足时的应变措施 考虑过多“小型区域”可能造成的内存碎片(fragment)问题 C++内存配置的基本操作是::operator new()，内存释放的基本操作是::operator delete()。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。 为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，第一级配置器(__malloc_alloc_template)用malloc()和free()，第二级配置器(__default_alloc_template)看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池memory bool整理方式。其中具体是开放了第一级配置器还是两级配置器都开放了由USE_MEALLOC是否定义决定，定义了USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。 无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口simple_alloc，使其能够符合STL的接口规格。1234567891011121314151617template &lt;class T,class Alloc&gt;class simple_alloc&#123;public: static T* allocate(size_t n)&#123; return 0 == n?0 : (T*) Alloc::allocate(n* sizeof (T)); &#125; static T* allocate(void)&#123; return (T*) Alloc::allocatte(sizeof (T)); &#125; static void dallocate(T* p, size_t n)&#123; if(0 != n) Alloc::deallocate(p, n*sizeof (T)); &#125; static void deallocat(T* p)&#123; Alloc::deallocate(p, sizeof (T)); &#125;&#125;; 内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。 图解如下： 第一级配置器和第二级配置器： 包装接口和运用： 更新时间：2018.02.17 2.2.5 第一级配置器 __malloc_alloc_template 剖析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172template &lt;int inst&gt; //inst 没有用到class __malloc_alloc_template&#123;private: //处理内存不够的情况 //oom: out of memory static void *oom_malloc(size_t); static void *oom_realloc(void*, size_t); static void (* __malloc_alloc_oom_handler)();public: //直接调用malloc，free，realloc，只是多了一层封装，使之可以处理内存不够的情况 static void* allocate(size_t n)&#123; void *result = malloc(n); if(0 == result) result = oom_malloc(n); &#125; static void deallocate(void* p, size_t)&#123; free(p); &#125; static void* reallocate(void* p, size_t, size_t new_sz)&#123; void* result = realloc(p, new_sz); if(0 = result) result = oom_realloc(p, new_sz); return result; &#125; //仿真c++的set_new_handdler() static void(* set_malloc_handler(void(*f)()))()&#123; //被调用的函数__malloc_alloc_oom_handler void(* old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = f; return (old); &#125; //__malloc_alloc_oom_handler函数初始值是0，该值由客端自己设定 template &lt;int inst&gt; void (* __malloc_alloc_template&lt;inst&gt; :: __malloc_alloc_oom_handler)() = 0; //oom_malloc template &lt;int inst&gt; void* __malloc_alloc_template&lt;inst&gt; :: oom_malloc(size_t n)&#123; void (* my_malloc_handler)(); void* result; for(; ;)&#123; //不停的尝试，释放，配置，释放，配置…… my_malloc_handler = __malloc_alloc_oom_handler; //如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常 if(0 == my_malloc_handler)&#123; __THROW_BAD_ALLOC; &#125; (*my_malloc_handler)(); //调用处理例程，企图释放内存 result = malloc(n); //再次配置 if(result) return (result); &#125; &#125; //oom_realloc template &lt;int inst&gt; void* __malloc_alloc_template&lt;inst&gt; :: oom_realloc(void* p, size_t n)&#123; void (* my_malloc_handler)(); void* result; for(; ;)&#123; //不停的尝试，释放，配置，释放，配置…… my_malloc_handler = __malloc_alloc_oom_handler; //如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常 if(0 == my_malloc_handler)&#123; __THROW_BAD_ALLOC; &#125; (*my_malloc_handler)(); //调用处理例程，企图释放内存 result = malloc(n); //再次配置 if(result) return (result); &#125; &#125;&#125; 第一级配置器以malloc()、free()、realloc()等C函数执行实际的内存的配置、释放、重配置操作，同时实现出类似C++ new-handler的机制。所谓new-handler就是在系统内存配置需求无法被满足的情况下，调用一个指定的函数。 2.2.6 第二级配置器__default_alloc_template 剖析第二级配置器__default_alloc_template多了些机制，避免太多小额区块造成内存的碎片。 当区块超过128bytes，则用内存池管理，此做法又称为次层配置(sub-allocation)：每次配置一大块内存，并维护对应自由链表(free-lists)。下次如果再有相同大小的内存需求，就直接从free-lists中取出。如果客端释放返还小额区块，就有配置器会受到free-lists中。二级配置器会自动将内存调整为8的倍数，并维护16个free-lists，各自管理8的倍数的小额区块。12345//free-list的节点union obj&#123; union obj *free_list_link; char client_data[1];&#125; 其中，obj是一个obj指针，指向下一个相同大小的区块。同时obj是一个指针，指向实际中区块。结合2.2.7的图理解。如图： 2.2.7 空间配置函数allocate()allocate()是二级配置器__default_alloc_template的一个标准接口函数。这个函数首先判断区块大小，大于128bytes调用的第一级配置器，小于128bytes的查询对应free-list有可以用的区块，就直接拿来用，如果没有，就将区块大小调至8倍数边界，然后调用refill()，为free list重新填充空间。123456789101112131415161718192021//n &gt; 0static void* allocate(size_t n)&#123; //二级指针，但是volatile的用法不详 obj* volatile *my_free_list; obj* result; if(n&gt;(size_t) __MAX_BYTES)&#123; return (malloc_alloc::allocate(n)); &#125; //寻找16个free list中适合的一个 my_free_list = free_list + FREELIST_INDEX(n); result = *my_free_list; if(result == 0)&#123; //准备填充free list void* r = refill(ROUND_UP(n)); return r; &#125; //调整free list *my_free_list = result -&gt; free_list_link; return (result);&#125; 图解如下： 2.2.8 空间释放函数 deallocate()deallocate()是配置器__default_alloc_template的一个标准接口函数。大于128bytes调用第一级配置器，小于128bytes找到对应的free list将区块回收。12345678910111213141516// p不可以是 0static void deallocate(void *p, size_t n)&#123; obj* q = (obj* )p; //二级指针，但是volatile的用法不详 obj* volatile *my_free_list; if(n&gt;(size_t) __MAX_BYTES)&#123; malloc_alloc::deallocate(p, n); return; &#125; //寻找对应的free list my_free_list = free_list + FREELIST_INDEX(n); //调整free list，回收区域 q-&gt;free_list_link = *my_free_list(); *my_free_list = q;&#125; 图解如下： 2.2.9 重新填充 free listsallocate()中，当它发现free list中没有可用区块的时候，调用refill()，为free list重新填充空间。新的空间将取自内存池(chunk_alloc()完成)。缺省获得20个新节点。12345678910111213141516171819202122232425262728293031323334//返回一个大小为n的对象，并且有时候会为适当的free list增加节点//假设n已经适当上调至8的倍数template &lt;bool threads, int inst&gt;void* __default_alloc_template&lt;threads, inst&gt; :: refill(size_t n)&#123; int nobjs = 20; //缺省值 //调用chunk_alloc()，尝试获得nobjs个区块作为free list的新节点 char* chunk = chunk_alloc(n, nobjs); obj* volatile* my_free_list; obj* result; obj* current_obj, *next_obj; int i; //如果只获得一个区块，这个区块就分配给调用者使用，free list无新节点 if(1 == nobjs) return (chunk); //否则调整free list纳入新的节点 my_free_list = free_list + FREELIST_INDEX(n)； //以下在chunk空间创建free list result = (obj *)chumk; //以下导引free list 指向新配置的空间(取自内存池) *my_free_list = next_obj = (obj*)(chunk + n); //以下将free list 的各个节点串联起来 for(i = 1; ; i++)&#123; //从n == 1开始，因为0号要返回给客端 current_obj = next_obj; next_obj = (obj*)((char *)next_obj + n); if(nobjs - 1 == i)&#123; current_obj -&gt; free_list_link = 0; break; &#125; else&#123; current_obj-&gt;free_list_link = next_obj; &#125; &#125; return (result);&#125; 内存池暂时先按下…… 2.2.10 内存池(memory pool)2.3 内存基本处理工具STL定义了五个全局函数，作用于未初始化化空间上：用于构造的construct()和析构的destroy(),另外三个是：uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()(定于于&lt;memory&gt;),分别对应于高层次函数copy(),fill(),fill_n(),这些都是STL的算法。 2.3.1 uninitialized_copy2.3.2 uninitialized_fill2.3.3 uninitialized_fill_n","categories":[{"name":"learning","slug":"learning","permalink":"http://www.jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"复杂单链表的复制","slug":"复杂单链表的复制","date":"2018-01-31T06:54:57.000Z","updated":"2018-02-08T06:19:39.885Z","comments":true,"path":"复杂单链表的复制.html","link":"","permalink":"http://www.jingxxn.cn/复杂单链表的复制.html","excerpt":"题目:有一个单链表，该链表节点有两个指针，一个_next指向下一个节点，另一个_random指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。 思路： 单链表的复制比较简单，但是_random不好处理，如果_random指向前面的节点，我们该如何处理。_random还有可能是指向NULL，这种情况也需要单独处理。","text":"题目:有一个单链表，该链表节点有两个指针，一个_next指向下一个节点，另一个_random指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。 思路： 单链表的复制比较简单，但是_random不好处理，如果_random指向前面的节点，我们该如何处理。_random还有可能是指向NULL，这种情况也需要单独处理。 为了解决这个问题，我们可以用一个比较巧妙的方法，对每一个节点都复制，同时插入到当前节点的后面。这样我们就得到了一个重复的链表，此时有一个优势，新_random就是原来_random的后一个。我们就不需要在考虑往前寻找的问题了。只需要找到当前节点的_random的_next就行。 这样处理之后，我们就得到了一个新的链表，接着只需要进行拆分就好了。 看图如下：创建了一个复杂链表 进行对每一个节点的复制同时插入到原链表中 给出节点的结构如下：123456789101112#define datatype inttypedef struct complexnode&#123; complexnode(datatype val)&#123; _data = val; _next = NULL; _random = NULL; &#125; datatype _data; complexnode* _next; complexnode* _random;&#125;comnode; 实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//主函数comnode* copy_complex_list( comnode* head )&#123; comnode* cur = head; comnode* next = cur-&gt;_next; if( cur == NULL ) return NULL; //将每一个节点复制到当前节点的后面，并链入链表 while( cur )&#123; comnode* tmp = new comnode(cur-&gt;_data); cur-&gt;_next = tmp; tmp-&gt;_next = next; cur = next; //防止对NULL访问 if( cur ) next = cur-&gt;_next; &#125; //将指针重置指向头结点 cur = head; next = cur-&gt;_next; //给新链入的节点置random while( cur )&#123; //分类处理_random为NULL的情况 if( cur-&gt;_random ) next-&gt;_random = cur-&gt;_random-&gt;_next; else next-&gt;_random = NULL; cur = next-&gt;_next; if( cur ) next = cur-&gt;_next; &#125; cur = head; next = cur-&gt;_next; comnode* result = next; //拆分两个链表 while( cur )&#123; cur-&gt;_next = next-&gt;_next; cur = cur-&gt;_next; if( cur )&#123; next-&gt;_next = cur-&gt;_next; next = next-&gt;_next; &#125; &#125; return result;&#125;//打印函数void print_random( comnode* head )&#123; comnode* cur = head; cout &lt;&lt; \"list:\"; while( cur )&#123; cout &lt;&lt; cur-&gt;_data &lt;&lt; \"-&gt;\"; cur = cur-&gt;_next; &#125; cout &lt;&lt; \"NULL\" &lt;&lt; endl &lt;&lt; \"random:\"; cur = head; while( cur )&#123; if( cur-&gt;_random ) cout &lt;&lt; cur-&gt;_random-&gt;_data &lt;&lt; \" \"; else cout &lt;&lt; \"NULL\" &lt;&lt; \" \"; cur = cur-&gt;_next; &#125; cout &lt;&lt; endl;&#125;int main()&#123; comnode* head = new comnode(1); comnode* n1 = new comnode(2); comnode* n2 = new comnode(4); comnode* n3 = new comnode(5); comnode* n4 = new comnode(9); head-&gt;_next = n1; n1-&gt;_next = n2; n2-&gt;_next = n3; n3-&gt;_next = n4; n4-&gt;_next = NULL; head-&gt;_random = n2; n1-&gt;_random = head; n2-&gt;_random = n3; n3-&gt;_random = NULL; n4-&gt;_random = n4; system( \"clear\" ); comnode* copy_list = copy_complex_list( head ); print_random(head); cout &lt;&lt; \"copy_list:\" &lt;&lt; endl; print_random(copy_list); return 0;&#125; 运行结果如下：同时打印了原来的链表和复制的链表 CSDN上用C写的，同时也将各个部分功能进行了函数封装","categories":[{"name":"practice","slug":"practice","permalink":"http://www.jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://www.jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"浅读《More Effective C++》笔记","slug":"浅读《More-Effective-C-》笔记","date":"2018-01-30T06:27:03.000Z","updated":"2018-03-06T13:52:36.574Z","comments":true,"path":"浅读《More-Effective-C-》笔记.html","link":"","permalink":"http://www.jingxxn.cn/浅读《More-Effective-C-》笔记.html","excerpt":"第一章 基础议题条款1：区分指针和引用不存在空引用，引用必须要指向某个对象。当确定某个对象不允许有空值，就需要定义为引用，而不是指针。123//这种做法语法上没有错误，出现了引用为空的情况。但是不同的编译器会有不同的报错。不允许出现这样的代码。char* pc = 0;char &amp;rc = *pc; 因为不存在空引用这种情况，所以使引用会比指针更高效。","text":"第一章 基础议题条款1：区分指针和引用不存在空引用，引用必须要指向某个对象。当确定某个对象不允许有空值，就需要定义为引用，而不是指针。123//这种做法语法上没有错误，出现了引用为空的情况。但是不同的编译器会有不同的报错。不允许出现这样的代码。char* pc = 0;char &amp;rc = *pc; 因为不存在空引用这种情况，所以使引用会比指针更高效。12345678//引用不用判空void print_double(const double&amp; rd)&#123; cout &lt;&lt; rd;&#125;//指针要判空void print_double1(const double *pd)&#123; if(pd)&#123; cout &lt;&lt; *pd; &#125;&#125; 指针可以被重新赋值用以指向另外一个不同的对象，而引用则总是指向初始化时它指向的对象。12345678string s1(\"nancy\");string s2(\"clancy\");string&amp; rs = s1;string *ps = &amp;s1;//rs依然是s1的引用，此时rs = s1 = s2 = \"clancy\"rs = s2;//ps指向了s2,不再指向s1ps = &amp;s2; 实现某些操作符的时候，最常见的是[]操作符，绝大多数应该返回引用。12345vector&lt;int&gt; v(10);//一般情况下的返回值，此时是引用v[5] = 10;//如果返回的是指针就需要这样解引用，看起来v就像是一个指针vector一样。*v[5] = 10; 条款2：优先考虑C++风格的类型转换四个类型转换操作符：static_cast,const_cast,dynamic_cast,reinterpret_cast static_cast：作用类似于C中的隐式类型转换，只能转换相近类型的变量。比如struct到int的转换就不能实现。而且在C++中，static_cast并不能将const属性转换为非const属性。 const_cast：专门用来去除const属性和volatile属性。const_cast被用来用作其他的类型转换会被拒绝。 dynamic_cast：它是用来针对一个继承体系做向下或者横向的安全转换的。也就是说，用dynamic_cast把指向基类的指针或引用转换成指向派生类或者基类的兄弟类的指针或引用，同时可以知道是否成功。出现空指针(转换指针的时候)或者出现异常(转换引用的时候)意味着失败。他不能用于哪些没有虚函数的类型，也不能去除const属性。 reinterpret_const：这个操作符，转换结果往往是编译器定义的。因此它几乎是不可以移植的。最常见的用法是在函数指针之间进行类型转换。但是一般我们不使用这种转换，因为c++没有规定这种做法，有可能出现未知的错误，除非万不得已，不然不使用。 使用格式举例：static_cast&lt;double&gt; (first); const_cast&lt;special*&gt;(first); dynamic_cast&lt;special *&gt;(&amp;first); reinterpret_cast&lt;funcptr&gt; (&amp;dosomething) 条款3：绝不要把多态应用于数组继承的一大特性，它允许你通过指向基类的指针和引用来操纵派生类对象。这种指针和引用的行为具有多态性。同时C++也允许你通过基类指针和引用来操纵派生类数组，但是这个应该不被允许。见下面这个例子：12345678910111213//一个BST类，有一个BalancedBST的类，它继承与BSTclass BST&#123; //...&#125;;class BalancedBST&#123; //...&#125;;//一个用于打印BST数组中BST元素的函数void printBSTArray(ostream&amp;s, const BST array[], int numElements)&#123; for( int i = 0; i &lt; numElements; ++i )&#123; s &lt;&lt; array[i]; &#125;&#125; 第一种情况，传递的数组是BST数组，程序没有问题；第二种情况，传递的数组是BalancedBST数组(继承于BST),编译器并不会报错，但是会出现问题，关键在于对array[i]的使用。array[i]=*(array+i)，我们知道array是指向数组的首地址的指针，其中array+i偏移的地址是根据元素的大小而定的。因为上例子中，array的类型是BST，所以array[i]的偏移是array+i*sizeof(SBT)。但我们传递了BST的子类BalancedBST给array，这样array的访问就会出现问题。 同时，如果打算通过一个基类指针删除一个包含派生类对象的数组，一样会出现问题。1234567void deleteArray(ostream&amp; logStream, BST array[])&#123; logStream &lt;&lt; static_cast&lt;void*&gt;(array) &lt;&lt; endl; delete[] array;&#125;BalancedBST *balTreeArray = new BalancedBST[50];//...deleteArray(cout, balTreeArray); 明面上这里并没有调用指针，但是当删除数组的时候，数组元素的析构函数必须被调用。 条款4 避免不必要的默认构造函数更新时间：2018.02.19默认构造函数指的是在C++语言中，不需要传参数就可以调用的构造函数，用于对象的初始化。但有的时候，我们要求这个对象，必须包含一些特定的值。比如下面例子：12345class EquipmentPiece&#123;public: EquipmentPiece( int IDNumber )&#123;&#125; //...&#125;; 此时EquipmentPiece类没有默认的构造函数，有三种情况，对它的应用会出现问题。第一种情况，如下：12EquipmentPiece bestPieces[10]; //没法调用构造函数EquipmentPiece *bestPieces = new EquipmentPiece[10]; //没法调用构造函数 这里有三种方法可以避开这个限制。第一种，对于不在堆上分配内存的数组，在定义数组的时候，提供必要参数。第二种，不使用对象数组，使用一个指针数组，如下：1234567typedef EquipmentPiece* PEP;PEP bestPieces[10];PEP *bestPieces = new PEP[10];//这样，数值的每一个指针都可以被重新赋值以指向不同的EquipmentPiece对象。for( int i = 0; i &lt; 10; ++i )&#123; bestPieces[i] = new EquipmentPiece( ID Number );&#125; 但是这两种方法有两个缺点，第一个是，你必须记住删除数组指针所指向的所有对象，不然会出现内存泄漏。第二，这样的方法所需要的内存需求总量会增加，需要额外的空间去存储指针。 第三种方法，为数组分配原始内存，可以避免额外的内存消耗，利用placement new技术，如下：12345void * rawMemory = operator new[](10*sizeof(EquipmentPiece));EquipmentPiece* bestPieces = static_cast&lt;EquipmentPiece*&gt;(rawMemory);for( int i = 0; i &lt; 10; ++i )&#123; new(bestPieces+i) EquipmentPiece( ID Number );&#125; 这个方法的缺点是，删除的时候，先要手工调用析构函数，然后再手工调用delete[]函数，这样才能够释放原始内存。1234for( int i = 9; i &gt;= 0; --i )&#123; bestPieces[i].~EquipmentPiece();&#125;operator delete[](rawMemory); 没有默认构造函数所造成的第二个问题是，他们没有办法作为许多基于模板的容器类的类型参数使用。因为通常用于实例化模板的那些类型需要提供默认构造函数。这个要求大多数时候来自模板内部需要创建关于模板参数类型的数组。例子如下：1234567891011template&lt;class T&gt;class Array&#123;public: Array( int size );private: T* data;&#125;;template &lt;class T&gt;Array&lt;T&gt;::Array(int size)&#123; date = new T[size];&#125; 在大多数情况下，可以通过谨慎的设计排除对默认构造函数的需要。标准的vector模板就不要求。没有默认构造函数的第三个问题是。在有虚基类的时候，到底要不要提供默认构造函数。没有默认构造函数的虚基类使用起来十分痛苦。这是因为虚基类的构造函数所要求的参数必须由被创建对象所属的最远的派生类提供。这样就导致了，没有默认构造函数的虚基类会要求所有由它继承下来的派生类都必须知道、理解虚基类构造函数的参数的含义并提供这些参数。 第二章 运算符条款5：小心用户自定义的转换函数C++允许编译器在两种数据类型之间进行隐式转换，char到int、short到double。甚至会出现数据丢失的也可以，int到char、double到short的转换。接下来介绍两种类型函数可以让编译器实施这种隐式转换：单个参数的构造函数和隐式的类型转换运算符。单个参数的构造函数指的是，只传递给它一个参数就可以调用的构造函数。这种构造函数可以只定义一个参数，也可以定义多个参数。定义多个参数的时候，除了第一个参数，后面的参数应该是有默认值的。例子如下：12345678class Name&#123;public: Name(const string&amp; s);&#125;;class Ratinal&#123;public: Rational(int numerator = 0, int denominator = 1);&#125;; 隐式的类型转换运算符只不过是名字看上去比较奇怪的成员函数：在operator关键字后面指定类型。 条款6：区分自增运算符和自减运算符的前缀形式和后缀形式前缀形式和后缀形式的区别1234567class UPInt&#123;public: UPInt&amp; operator++(); const UPInt operator++(int); UPInt&amp; operator--(); const UPInt operator--(int);&#125;; 当函数被调用的时候，编译器悄无声息的传递一个0作为int参数的值给该函数。其中前缀形式返回一个引用，后缀形式返回一个const对象。 123456789101112UPInt&amp; UPInt::operator++()&#123; *this += 1; return *this;&#125;const UPInt UPInt::operator++(int)&#123; count UPInt oldvalue = *this; //*this += 1; //复用前缀自增 ++(*this); return oldvalue;&#125; 后缀形式返回const后缀自增形式的返回值是一个const对象，为什么是一个const对象呢？如果不是const对象，那么下面这个代码就是正确的： 12UPInt i;i++++; 但是很明显这样是不正确的。根据内置类型的性质，当我们自增两次int类型的数据的时候，这个是不允许发生的。有一个点需要说明的是，如果不是很必要使用后缀自增的形式，那么尽量使用前缀自增。因为后缀自增首先需要显示创建一个临时变量，然后返回的时候，还需要创建一个临时对象作为返回。最后结束函数的时候需要析构两者。如果十分在意效率问题，尽量使用前缀自增。最后，为了降低维护成本，后缀自增或自减最好复用前缀自增或自减。这样只需要维护前缀自增或自减即可。 条款7：不要重载“ &amp;&amp; ”、“ || ”和“ , ”短路求值法C++使用了短路求值法对布尔表达式求值。这个表示，一旦确定了布尔表达式为真或为假，即使还有部分表达式还没有测试，布尔表达式也会停止运算。 1234char* p;//...if(p != 0 &amp;&amp; strlen(p) &gt; 10) //... 这里我们永远不需要担心strlen中的p是否为0值，因为p=0的时候，strlen(p)根本就不会进行运算。 不要重载“ &amp;&amp; ” 和 “ || ”实际上，C++允许我们对&amp;&amp; ||进行重载，但是为了保证短路求值法的正确性，我们要确定不要重载&amp;&amp; ||这两个运算符。如果重载了&amp;&amp;，效果如下： 123if(exp1 &amp;&amp; exp2)if(exp1.operator&amp;&amp;(exp2)if(operator(ex1, ex2) 这样就变成了函数的调用，首先，函数的调用需要求出两个参数的运算结果，这样就不能实现短路求值的功能；其次，函数的调用没有规定先运算哪个参数，有可能是第一个，也有可能是第二个。 不要重载逗号运算符逆置一个字符串的例子：1234567void reverse(char s[])&#123; for(int i = 0, j = strlen(s) - 1; i &lt; j; ++i, --j)&#123; int c = s[i]; s[i] = s[j]; s[j] = c; &#125;&#125; 包含逗号的表达式，首先计算逗号左边的表达式，然后计算右边的表达式；整个表达式返回最右边的表达式的值。鉴于你完全没有办法模拟这个行为，所以不要重载逗号运算符。 同时也不要重载以下的运算符 . .* :: ?: new delete sizeof typeid static_cast dynamic_cast const_cast reinterpret_cast 条款8：理解new和delete在不同情形下的含义区分 new 操作符(new operator)和 operator new 函数1string *ps = new string(\"Memory Management\"); 上面的代码中使用的new 指的是 new 操作符。","categories":[{"name":"learning","slug":"learning","permalink":"http://www.jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"static const integral data member在类中的初始化","slug":"static-const-integral-data-member在类中的初始化","date":"2018-01-30T06:25:04.000Z","updated":"2018-02-09T02:36:56.418Z","comments":true,"path":"static-const-integral-data-member在类中的初始化.html","link":"","permalink":"http://www.jingxxn.cn/static-const-integral-data-member在类中的初始化.html","excerpt":"当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。该类的其它对象对这个静态变量也是可以进行修改的。1234567891011121314151617//非常量静态成员变量初始化对比#include &lt;iostream&gt;using namespace std;class person&#123; public: static int num; //static int num = 11;&#125;;int person::num = 10;int main()&#123; person bob; system(\"clear\"); cout &lt;&lt; bob.num &lt;&lt; endl; return 0;&#125;","text":"当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。该类的其它对象对这个静态变量也是可以进行修改的。1234567891011121314151617//非常量静态成员变量初始化对比#include &lt;iostream&gt;using namespace std;class person&#123; public: static int num; //static int num = 11;&#125;;int person::num = 10;int main()&#123; person bob; system(\"clear\"); cout &lt;&lt; bob.num &lt;&lt; endl; return 0;&#125; 在类内初始化非常量静态成员变量失败在类外初始化静态成员变量成功123//定义另外一个对象timmyperson timmy;cout &lt;&lt; \"timmy:\" &lt;&lt; timmy.num&lt;&lt; endl; 同一个类的不同对象共用一个静态成员变量 但是，常量的静态成员变量可以在类里面定义。12345678910111213141516#include &lt;iostream&gt;using namespace std;class person&#123; public: static const int num = 11; const static int age = 23;&#125;;int main()&#123; system(\"clear\"); person tom; cout &lt;&lt; \"tom:\" &lt;&lt; tom.num &lt;&lt; endl; cout &lt;&lt; \"tom:\" &lt;&lt; tom.age &lt;&lt; endl; return 0;&#125; static const和const static一样的。 可是只有integral data member才可以，像 int，long，char才行。double，float等都不行12345678910111213#include &lt;iostream&gt;using namespace std;class person&#123; public: static const double num = 2.2;&#125;;int main()&#123; system(\"clear\"); person tom; cout &lt;&lt; \"tom:\" &lt;&lt; tom.num &lt;&lt; endl; return 0;&#125; 用 static const double 初始化失败","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"创建一个不能被继承的类","slug":"创建一个不能被继承的类","date":"2018-01-29T02:23:19.000Z","updated":"2018-02-24T08:04:44.249Z","comments":true,"path":"创建一个不能被继承的类.html","link":"","permalink":"http://www.jingxxn.cn/创建一个不能被继承的类.html","excerpt":"题目：题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。 思路： 题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。","text":"题目：题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。 思路： 题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。那么我们只要将构造函数或析构函数定义为私有成员函数就好了。 第二个要求，能够正常使用，这样显然之前的方式是行不通的。构造函数为私有了，就无法创建对象了。那我再给他加一个友元函数，这样对象也可以创建了。 可是题目的要求是正常使用这个类，显然通过一个友元函数是不符合我们正常使用类的方式。 这个时候，正真正确的思路就出来了。我们借用一个中间类。例如：我们不能被继承的类是man，我们创建一个 私有构造函数的父类person，同时将 man定义为person的友元类。这样man就可以正常访问person的私有构造函数了。接着我们让 man虚继承person，到这里我们就完成了这个题目。 让man虚继承person是为了让继承man的类，都需要在man的父类，即person中调用构造函数，但只有man是person的友元类，其他的类都不能访问person的构造函数。因此man就成为了不能被继承的类，而man本身可以正常使用。 代码如下：123456789101112131415161718192021222324252627282930313233343536include &lt;iostream&gt;using namespace std;//设计一个不能被继承的类class person&#123; public: friend class man; private: //构造函数为private person()&#123;&#125;&#125;;//man虚拟继承personclass man:virtual public person &#123; public: man()&#123; age = 18; &#125; void show()&#123; cout &lt;&lt; age &lt;&lt; endl; &#125; private: int age;&#125;;// class son:public man&#123;// public:// son()&#123;&#125;// &#125;;int main()&#123; man bob; system( \"clear\" ); bob.show(); //son tom; return 0;&#125; 不定义man的继承类son，正常输出man的age = 18 定义man的继承类son失败","categories":[{"name":"practice","slug":"practice","permalink":"http://www.jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://www.jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"位运算实现Add","slug":"位运算实现Add","date":"2018-01-28T05:30:43.000Z","updated":"2018-02-08T06:20:27.616Z","comments":true,"path":"位运算实现Add.html","link":"","permalink":"http://www.jingxxn.cn/位运算实现Add.html","excerpt":"题目：实现一个Add函数，让两个整数相加，不能够使用+-*/、++、-- 思路： 正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，15+5=20先将位进行相加，不进行进位，得到10，再将进位加上，个位没有进位，十位进1，得到20。","text":"题目：实现一个Add函数，让两个整数相加，不能够使用+-*/、++、-- 思路： 正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，15+5=20先将位进行相加，不进行进位，得到10，再将进位加上，个位没有进位，十位进1，得到20。 题目要求不能使用+-*/，所以想到了位运算。15的二进制是1111，5的二进制是0101。根据上面的思路，我们先进行不进位相加，得到1010。(这个运算方式正好对应^)然后将进位加上(只求进位的运算正好对应&amp;再左移一位)，例子中只有第四位、第二位数值有进位值。得到10100，这个值就是20。 代码如下123456789101112131415161718192021222324//1、递归实现，每次将不进位相加的值赋给a，将计算出来的进位值赋给b，递归进行两者的分步相加，直到进位值`b=0`，返回a。long long Add( int a, int b )&#123; if( b == 0 ) return a; int sum = a^b; b = (a&amp;b)&lt;&lt;1; a = sum; return Add( a, b );&#125;int main()&#123; system( \"clear\" ); cout &lt;&lt; Add(3, 7) &lt;&lt; endl; //2、同时可以用迭代实现(非函数)，思路一样，进位值b最后肯定会等于0，因为总有进位结束的时候。 int a = 49; int b = 4; while( b != 0 )&#123; int sum = a^b; b = (a&amp;b)&lt;&lt;1; a = sum; &#125; cout &lt;&lt; a &lt;&lt; endl; return 0;&#125;","categories":[{"name":"practice","slug":"practice","permalink":"http://www.jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://www.jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"1+2+……+n的特殊求法","slug":"1-……-n的特殊求法","date":"2018-01-26T16:44:40.000Z","updated":"2018-02-08T06:20:15.815Z","comments":true,"path":"1-……-n的特殊求法.html","link":"","permalink":"http://www.jingxxn.cn/1-……-n的特殊求法.html","excerpt":"题目：求1+2+3+…+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。 自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&amp;&amp;的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。 更新：18.1.28发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了柔性数组，这种数组的长度的可变的，不需要用常量定义。","text":"题目：求1+2+3+…+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。 自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&amp;&amp;的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。 更新：18.1.28发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了柔性数组，这种数组的长度的可变的，不需要用常量定义。 123456789101112class Solution&#123; public: int Sum_Solution( int n )&#123; bool a[n][n+1]; return sizeof(a)&gt;&gt;1; &#125;&#125;;int main()&#123; Solution s; cout &lt;&lt; s.Sum_Solution(10) &lt;&lt; endl; return 0;&#125; 原文： 利用&amp;&amp;操作符，|| 也一样的做法。思路：当result = 0 的时候，&amp;&amp;不再判断右操作数，递归停止。 123456789int sum( int n )&#123; int result = n; result &amp;&amp; (result += sum(n-1)); return result;&#125;int main()&#123; cout &lt;&lt; sum(100) &lt;&lt; endl; return 0;&#125; 利用构造函数以及静态成员变量思路：构造N次对象，每次对静态变量sum++，对n赋值。利用静态变量对所有同类对象有效的特点。 1234567891011121314151617181920212223242526272829303132333435class tmp&#123;public: //构造 tmp( )&#123; ++n; sum += n; &#125; //初始化 void static init()&#123; n = 0; sum = 0; &#125; //获得sum int static getsum()&#123; return sum; &#125;private: static int n; static int sum;&#125;;int tmp::n = 0;int tmp::sum = 0;//运行的函数int count(int n)&#123; tmp::init(); tmp* a = new tmp[n]; delete[] a; a = NULL; tmp::getsum();&#125;int main()&#123; cout &lt;&lt; count(100) &lt;&lt; endl; return 0;&#125; 利用虚函数、继承和函数指针思路： 定义两个类，A是基类，B是子类。 定义一个A* Array[2],其中Array[0]存放A对象的地址，Array[1]存放B对象的地址。 调用函数Sum中调用Sum的递归。同时对变量n两次取反Array[!!n]-&gt;Sum(n-1)+n,这样当n不为0的时候，得到bool值1。Array[!!n] = Array[1] 当n=0调用基类A的sum。充分利用虚函数参数与类型有关的性质。 12345678910111213141516171819202122232425262728293031323334353637383940414243//1、虚函数#include &lt;iostream&gt;using namespace std;class A;A* Array[2];class A&#123;public: virtual int Sum( int n )&#123; return 0; &#125;&#125;;class B:public A&#123;public: virtual int Sum( int n )&#123; //当 n != 0, !!n = 1 return Array[!!n]-&gt;Sum(n-1)+n; &#125;&#125;;int Sum2( int n )&#123; A a; B b; Array[0] = &amp;a; Array[1] = &amp;b; //调用虚函数 int value = Array[1]-&gt;Sum(n); return value;&#125;int main()&#123; cout &lt;&lt; Sum2(100) &lt;&lt; endl; return 0;&#125;//2、同上，这里利用函数指针来实现。typedef int (*fun)(int);int Sum( int i )&#123; return 0;&#125;int Sum2( int i )&#123; fun f[2] = &#123; Sum, Sum2 &#125;; return i + f[!!n](i-1);&#125; 利用异常处理的机制思路：try接收到的异常会在catch中捕获。 1234567891011int sum(int n)&#123; try&#123; //n = 2 的时候，出现异常，程序流跳转到catch int[] array = new int[n-2]; return n+sum(n-1); &#125; catch(Exception e)&#123; //返回1到上一个递归处，n = 2处。 return 1; &#125;&#125; 利用模板思路：利用了模板的特化作为递归结束的条件，并借用枚举类型。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;template &lt;unsigned N&gt;class Sum&#123; public: enum&#123; sum = N+Sum&lt;N-1&gt;::sum &#125;;&#125;;//模板特化，当N=1 的时候，调用template&lt;&gt;class Sum&lt;1&gt;&#123; public: enum&#123; sum = 1 &#125;;&#125;;int main()&#123; cout &lt;&lt; Sum&lt;100&gt;::sum &lt;&lt; endl; return 0;&#125; 方法来源地址","categories":[{"name":"practice","slug":"practice","permalink":"http://www.jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://www.jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"收集","slug":"Linux相关网站","date":"2018-01-25T10:18:01.000Z","updated":"2018-02-09T02:33:52.783Z","comments":true,"path":"Linux相关网站.html","link":"","permalink":"http://www.jingxxn.cn/Linux相关网站.html","excerpt":"1、Linux命令相关 Linux命令大全：http://man.linuxde.net/ 修改时间查看时间：https://www.cnblogs.com/jiu0821/p/5999566.html 移动、重命名文件/目录：https://linux.cn/article-2688-1.html 查看系统版本：http://www.linuxidc.com/Linux/2015-07/119897.htm","text":"1、Linux命令相关 Linux命令大全：http://man.linuxde.net/ 修改时间查看时间：https://www.cnblogs.com/jiu0821/p/5999566.html 移动、重命名文件/目录：https://linux.cn/article-2688-1.html 查看系统版本：http://www.linuxidc.com/Linux/2015-07/119897.htm vim相关 vim的配置：http://blog.csdn.net/footmart_c/article/details/51588524 多行删除复制：https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html vim安装报错EXTERN.h：http://tieba.baidu.com/p/4471948063 vim升级8.0+YouCompleteMe补全插件：http://blog.csdn.net/nzyalj/article/details/75331822 vim8.0升级后添加到路径中：http://blog.csdn.net/u013388603/article/details/72780586 YouCompleteMe：http://blog.51cto.com/990487026/1905427 git相关 git安装：https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html git安装：http://blog.csdn.net/u013256816/article/details/54743470 git升级2.7.3：https://www.cnblogs.com/yexinw/p/6401663.html python相关 2.6升级2.7：https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html 安装3.5.2并与python2共存：https://www.ywlib.com/archives/96-1.html 输入相关 python造成 input method preferences无效：http://blog.csdn.net/jaket5219999/article/details/52912321 安装Fcitx 4.0.0：https://www.douban.com/note/319236531/ 设置Fcitx默认：https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html ibus开启：http://blog.csdn.net/zitong_ccnu/article/details/40110583 源相关 Nux Dextop源：http://www.linuxidc.com/Linux/2016-06/132101.htm yum源解析（详细）：https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html Hexo相关 gcc升级：http://www.cnblogs.com/lpbottle/p/install_gcc.html gcc升级：http://blog.csdn.net/furzoom/article/details/53322510 gcc升级：http://blog.csdn.net/zr1076311296/article/details/51334538 Nodejs安装：https://www.cnblogs.com/lpbottle/p/7733397.html 其它 /mnt/hgfs没有共享文件夹：http://www.mamicode.com/info-detail-1655589.html Linux就该这么学：http://www.linuxprobe.com/chapter-00.html 2、C语言 链表相关笔试题：http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html 3、GitHub 知乎：https://www.zhihu.com/question/20070065 他的网站里有：http://youngxhui.github.io/ 以下，搭建自己的github博客： 配置详细：https://www.jianshu.com/p/b7886271e21a 很强大的一个：http://kchen.cc/2016/11/12/hexo-instructions/ WordPress和Hexo以及md编辑器：https://www.imooc.com/article/12257 localhost:4000出问题：http://blog.csdn.net/u012246342/article/details/51543370 Hexo问题总结：http://blog.csdn.net/wx_962464/article/details/44786929 4、blog http://www.zipperary.com/ 陈皓：https://coolshell.cn/featured 5、其它 msdn：https://msdn.itellyou.cn/ NTFS和FAT32区别：http://www.ntfsformac.cn/qita-nytqubie.html SQL源码剖析：http://deepfuture.iteye.com/blog/718478","categories":[{"name":"网站收集","slug":"网站收集","permalink":"http://www.jingxxn.cn/categories/网站收集/"}],"tags":[]}]}