{"meta":{"title":"青匆","subtitle":"","description":"为即将来临的精彩。","author":"timmy","url":"http://www.jingxxn.cn"},"pages":[{"title":"","date":"2018-02-17T02:37:02.037Z","updated":"2018-02-17T02:37:02.037Z","comments":true,"path":"baidu_verify_aF8IqoDm9Z.html","permalink":"http://www.jingxxn.cn/baidu_verify_aF8IqoDm9Z.html","excerpt":"","text":"aF8IqoDm9Z"},{"title":"categories","date":"2018-01-27T09:16:23.000Z","updated":"2018-03-13T04:03:43.164Z","comments":false,"path":"categories/index.html","permalink":"http://www.jingxxn.cn/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2018-03-13T03:36:36.000Z","updated":"2018-03-13T04:03:47.272Z","comments":false,"path":"link/index.html","permalink":"http://www.jingxxn.cn/link/index.html","excerpt":"","text":"1、Linux命令相关 Linux命令大全：http://man.linuxde.net/ 修改时间查看时间：https://www.cnblogs.com/jiu0821/p/5999566.html 移动、重命名文件/目录：https://linux.cn/article-2688-1.html 查看系统版本：http://www.linuxidc.com/Linux/2015-07/119897.htm vim相关 vim的配置：http://blog.csdn.net/footmart_c/article/details/51588524 多行删除复制：https://www.cnblogs.com/MMLoveMeMM/articles/3707287.html vim安装报错EXTERN.h：http://tieba.baidu.com/p/4471948063 vim升级8.0+YouCompleteMe补全插件：http://blog.csdn.net/nzyalj/article/details/75331822 vim8.0升级后添加到路径中：http://blog.csdn.net/u013388603/article/details/72780586 YouCompleteMe：http://blog.51cto.com/990487026/1905427 git相关 git安装：https://jingyan.baidu.com/article/e9fb46e16698687521f766ec.html git安装：http://blog.csdn.net/u013256816/article/details/54743470 git升级2.7.3：https://www.cnblogs.com/yexinw/p/6401663.html python相关 2.6升级2.7：https://www.cnblogs.com/yaoyuanmengjing/p/7853228.html 安装3.5.2并与python2共存：https://www.ywlib.com/archives/96-1.html 输入相关 python造成 input method preferences无效：http://blog.csdn.net/jaket5219999/article/details/52912321 安装Fcitx 4.0.0：https://www.douban.com/note/319236531/ 设置Fcitx默认：https://jingyan.baidu.com/article/0320e2c1393a3e1b86507b51.html ibus开启：http://blog.csdn.net/zitong_ccnu/article/details/40110583 源相关 Nux Dextop源：http://www.linuxidc.com/Linux/2016-06/132101.htm yum源解析（详细）：https://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html Hexo相关 gcc升级：http://www.cnblogs.com/lpbottle/p/install_gcc.html gcc升级：http://blog.csdn.net/furzoom/article/details/53322510 gcc升级：http://blog.csdn.net/zr1076311296/article/details/51334538 Nodejs安装：https://www.cnblogs.com/lpbottle/p/7733397.html 其它 /mnt/hgfs没有共享文件夹：http://www.mamicode.com/info-detail-1655589.html Linux就该这么学：http://www.linuxprobe.com/chapter-00.html 2、C语言 链表相关笔试题：http://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6416649.html 3、GitHub 知乎：https://www.zhihu.com/question/20070065 他的网站里有：http://youngxhui.github.io/ 以下，搭建自己的github博客： 配置详细：https://www.jianshu.com/p/b7886271e21a 很强大的一个：http://kchen.cc/2016/11/12/hexo-instructions/ WordPress和Hexo以及md编辑器：https://www.imooc.com/article/12257 localhost:4000出问题：http://blog.csdn.net/u012246342/article/details/51543370 Hexo问题总结：http://blog.csdn.net/wx_962464/article/details/44786929 4、blog http://www.zipperary.com/ 陈皓：https://coolshell.cn/featured 5、其它 msdn：https://msdn.itellyou.cn/ NTFS和FAT32区别：http://www.ntfsformac.cn/qita-nytqubie.html SQL源码剖析：http://deepfuture.iteye.com/blog/718478"}],"posts":[{"title":"BST二叉搜索树","slug":"BST二叉搜索树","date":"2018-03-29T12:04:18.000Z","updated":"2018-04-02T07:21:12.747Z","comments":true,"path":"BST二叉搜索树.html","link":"","permalink":"http://www.jingxxn.cn/BST二叉搜索树.html","excerpt":"性质二叉搜索树是一个优化的二叉树，也称作二叉排序树、二叉查找树、BST等。一般在每个节点定义一个关键值Key。插入的时候按照一定的规则使之有序插入，方便搜索。它可以是一颗空树，或者这棵树有着以下的性质：1、如果左子树不为空，那么左子树上的所有节点的值都小于根节点的值2、如果右子树不为空，那么右子树上的所有节点的值都大于根节点的值3、同时，左右子树也是二叉搜索树4、这棵二叉树没有相同关键值的节点，也就是每一个节点的值多不相同如果插入序列是：6,3,8,7,1,2,4,0,5,9,4图示如下：","text":"性质二叉搜索树是一个优化的二叉树，也称作二叉排序树、二叉查找树、BST等。一般在每个节点定义一个关键值Key。插入的时候按照一定的规则使之有序插入，方便搜索。它可以是一颗空树，或者这棵树有着以下的性质：1、如果左子树不为空，那么左子树上的所有节点的值都小于根节点的值2、如果右子树不为空，那么右子树上的所有节点的值都大于根节点的值3、同时，左右子树也是二叉搜索树4、这棵二叉树没有相同关键值的节点，也就是每一个节点的值多不相同如果插入序列是：6,3,8,7,1,2,4,0,5,9,4图示如下： 节点二叉树用二叉链的形式实现。每个节点有一个关键值_key，指向左子树的指针_left，指向右子树的指针_right。123456789101112template &lt;class K&gt;struct BStreeNode&#123; K _key; BStreeNode&lt;K&gt;* _left; BStreeNode&lt;K&gt;* _right; BStreeNode(const K&amp; key) :_key(key) ,_left(NULL) ,_right(NULL) &#123;&#125;&#125;; 插入思路分为三个步骤，查找插入位置，利用key创建节点，跟二叉树连接起来1、插入函数接收一个关键值key，用这个key跟当前指针指向的节点(cur)的关键值(cur-&gt;_key)比较。2、如果key大，cur向右子树走；如果key小，cur向左子树走；如果相等，那么就不需要插入。这里利用一个循环就可以实现。一直到cur指向空节点，那么这个地方就是需要插入的位置。4、但是为了将新增节点和二叉树连接起来，还需要一个指针指向上一个节点(parent)，此时要分清楚链入parent节点的左子树上还是右子树上。 图示插入key为4的节点 代码实现代码分为递归写法和非递归写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//非递归bool Insert(const K&amp; key)&#123; //特殊处理插入空树的情况 if(_root == NULL)&#123; _root = new Node(key); return true; &#125; Node* cur = _root; Node* parent = NULL; //查找插入位置 while(cur)&#123; if(cur-&gt;_key &lt; key)&#123; parent = cur; cur = cur-&gt;_right; &#125; else if(cur-&gt;_key &gt; key)&#123; parent = cur; cur = cur-&gt;_left; &#125; //已经有相同关键值的节点，不插入 else&#123; return false; &#125; &#125; cur = new Node(key); //插入到parent的右子树上 if(parent-&gt;_key &lt; key)&#123; parent-&gt;_right = cur; &#125; else&#123; parent-&gt;_left = cur; &#125; return true;&#125;//递归写法bool InsertR(const K&amp; key)&#123; return _InsertR(_root, key);&#125;//root使用的是引用，解决了连接的问题bool _InsertR(Node*&amp; root, const K&amp; key)&#123; if(root == NULL)&#123; root = new Node(key); &#125; else if(root-&gt;_key &lt; key)&#123; _InsertR(root-&gt;_right, key); &#125; else if(root-&gt;_key &gt; key)&#123; _InsertR(root-&gt;_left, key); &#125; else return false; return true;&#125; 这里解释两个地方：1、递归为什么要调用一个内置函数，不直接递归。2、递归写法为什么不需要链接的过程。1、由于递归函数需要多次调用本身，考虑如果不调用内置函数，为了实现递归左右子树，需要传入参数如下：1bool InsertR(Node* root, const K&amp; key)&#123;&#125; 但是很尴尬的是，我们没有办法将根节点_root的左子树或者右子树进行调用。因为_root是私有的，我们在类的外面是没有办法直接调用的。2、递归写法不是不需要链接的过程，而是连接的过程在使用了引用root这个语法之后，隐式的完成了。一个例子：我们现在有一个关键值为6的节点，我们要插入关键值为3的节点。根据代码，代码会走到_InsertR(root-&gt;_left, key);这里。此时的root有两层含义：第一层，root是当前节点的位置，指向了NULL；第二层，root是上一层函数root-&gt;_left指向的位置。之所以会有这样的联系，是因为root参数是引用的原因，当前的root是上一层函数的root-&gt;_left的别名。这样我们就不需要考虑连接的问题了，只要将新增节点直接交给当前函数的root就已经和二叉树连接在一起了。 查找查找的思路十分简单，可以认为是插入的弱化版本。找到返回当前节点的指针，未找到返回空指针。 代码实现查找函数也有非递归和递归两个版本。1234567891011121314151617181920212223242526272829303132333435//FindNode* Find(const K&amp; key)&#123; if(_root)&#123; Node* cur = _root; while(cur)&#123; if(cur-&gt;_key &lt; key)&#123; cur = cur-&gt;_right; &#125; else if(cur-&gt;_key &gt; key)&#123; cur = cur-&gt;_left; &#125; else&#123; return cur; &#125; &#125; &#125; return NULL;&#125;//FindRNode* FindR(const K&amp; key)&#123; return _FindR(_root, key);&#125;Node* _FindR(Node* root, const K&amp; key)&#123; if(root == NULL) return NULL; else if(root-&gt;_key &lt; key)&#123; _FindR(root-&gt;_right, key); &#125; else if(root-&gt;_key &gt; key)&#123; _FindR(root-&gt;_left, key); &#125; else&#123; return root; &#125;&#125; 删除删除思路删除较为复杂，分析如下：1、当前树是否为空2、寻找需要删除节点的位置3、如果删除的节点是叶子节点或者有一个子树为空的情况，可以归为第一类4、如果删除的节点两个子树都存在，归为第二类使用示例： 第一类，叶子节点或者有一个子树为空为什么将叶子节点归为这一类，是因为可以将叶子节点看做是左子树为空或者右子树为空的情况。 左子树为空左子树为空分为两种情况，第一种上图中红色cur一样，是parent的左子树，需要用parent的左去链接cur的右子树；第二种是上图中橙色cur，是parent的右子树，需要用parent的右去链接cur的右子树。 右子树为空同理，右子树为空也分为两种情况，上图中红色cur和橙色cur。 注意需要特殊处理parent是NULL的情况。当左右子树为空的时候，还有一种特殊的情况需要处理，如果符合要求的节点是根节点，我们需要特殊处理。如下图： 第二类，两个子树都存在这个类型的节点，需要使用到处理堆的一个操作。如果有一个大堆，需要获取第二大的节点的时候。需要将最大的节点出堆，然后获取堆顶数据。但是出堆之后，如果需要堆还是符合大堆的性质。就需要特殊处理。处理方法是替换：将堆顶的最大元素和最小元素交换，然后再删除最后一个节点，最后使用向下调整就可以了。这里也是这样处理，当我们找到了需要删除的节点，我们就去找右子树中最小的节点，然后替换，替换之后再删除。如图所示：如果需要删除节点cur，这个时候找到右子树中最小的节点pos，将节点pos的值赋给节点cur，让parent-&gt;_left==NULL。再删除cur节点，就实现了删除了。但是为什么是节点pos呢？这是因为删除了两个子树都在的节点。还需要保持BST的特性：左右子树还是BST。这时，右子树的最左节点肯定是右子树中最小的，或者说是排序下，跟当前删除节点相邻的节点。用它来改变删除节点最合适了，而且不需要对树的结构有大的修改。注意：这里有一个特殊的点，比如删除下图中的根节点。特殊的地方是，没有办法找到子树中的最左节点，因为根本没有，所以就需要在使用上述交换的方法的时候，特殊处理一次，判断parent的指向的时候，到底是直接让parent-&gt;_left==NULL还是parent-&gt;_right==pos-&gt;_right。通过删除节点pos的右是否存在判定。 代码实现递归和非递归两种情况123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//Removebool Remove(const K&amp; key)&#123; if(_root)&#123; Node* cur = _root; Node* parent = NULL; while(cur)&#123; //寻找节点 if(cur-&gt;_key &lt; key)&#123; parent = cur; cur = cur-&gt;_right; &#125; else if(cur-&gt;_key &gt; key)&#123; parent = cur; cur = cur-&gt;_left; &#125; //找到节点开始删除 else&#123; Node* del = cur; //删除节点的左子树为空 if(cur-&gt;_left == NULL)&#123; //特殊处理parent为NULL的情况 if(parent == NULL)&#123; _root = cur-&gt;_right; &#125; else&#123; //分cur是parent的左还是右子树 if(parent-&gt;_left == cur)&#123; parent-&gt;_left = cur-&gt;_right; &#125; else&#123; parent-&gt;_right = cur-&gt;_right; &#125; &#125; &#125; //删除节点的右子树为空 else if(cur-&gt;_right == NULL)&#123; if(parent == NULL)&#123; _root = cur-&gt;_left; &#125; else&#123; if(parent-&gt;_left == cur)&#123; parent-&gt;_left = cur-&gt;_left; &#125; else&#123; parent-&gt;_right = cur-&gt;_left; &#125; &#125; &#125; //删除节点的两个子树都在 else&#123; parent = cur; Node* pos = cur-&gt;_right; //寻找右子树最左节点 while(pos-&gt;_left)&#123; parent = pos; pos = pos-&gt;_left; &#125; //赋值给cur cur-&gt;_key = pos-&gt;_key; del = pos; //特殊处理pos是不是找到的右子树中的最左节点 if(pos-&gt;_right)&#123; parent-&gt;_right = pos-&gt;_right; &#125; else&#123; parent-&gt;_left = NULL; &#125; &#125; //三种情况统一删除 delete del; return true; &#125; &#125; &#125; //没找到，返回错误 return false;&#125;//RemoveRbool RemoveR(const K&amp; key)&#123; return _RemoveR(_root, key);&#125;bool _RemoveR(Node*&amp; root, const K&amp; key)&#123; if(root)&#123; Node* cur = root; if(cur-&gt;_key &lt; key)&#123; _RemoveR(root-&gt;_right, key); &#125; else if(cur-&gt;_key &gt; key)&#123; _RemoveR(root-&gt;_left, key); &#125; else&#123; Node* del = root; if(root-&gt;_left == NULL)&#123; root = root-&gt;_right; &#125; else if(root-&gt;_right == NULL)&#123; root = root-&gt;_left; &#125; else&#123; Node* pos = root-&gt;_right; while(pos-&gt;_left)&#123; pos = pos-&gt;_left; &#125; root-&gt;_key = pos-&gt;_key; return _RemoveR(root-&gt;_right, pos-&gt;_key); &#125; delete del; return true; &#125; &#125; return false;&#125; 说明一下递归调用的思想，对于树来说，递归的调用就相当于子问题的调用，每次都将左右节点当做是下次的根节点，然后通过相同的处理方式，一直到遇到返回条件。在递归删除中，也利用了引用的关键作用。123456if(root-&gt;_left == NULL)&#123; root = root-&gt;_right;&#125;else if(root-&gt;_right == NULL)&#123; root = root-&gt;_left;&#125; 这一段中，因为引用的原因，当前的root除了是指向当前节点的指针，还是上一级root指针的_left或者_right。这样也就不需要考虑连接的问题。在递归中处理删除节点的左右子树都在的情况，还是寻找到右子树中key最小的节点，然后赋值给需要删除的节点，在通过调用函数来删除这个节点，这样就可以直接利用删除左节点为空或者右节点为空的情况来处理。 中序遍历二叉搜索树又叫做排序树，这个是因为他是排好序的。同时如果使用中序遍历的话，就可以得到这个排好序的序列。 代码实现利用中序的遍历，也有递归和非递归两种形式。非递归的形式，是借用了栈来模拟回退的功能。123456789101112131415161718192021222324252627282930313233//InOrdervoid InOrder()&#123; Node* root = _root; if(_root)&#123; Node* cur = root; stack&lt; Node* &gt; s; while(cur || !s.empty())&#123; while(cur)&#123; s.push(cur); cur = cur-&gt;_left; &#125; cur = s.top(); cout &lt;&lt; cur-&gt;_key &lt;&lt; \" \"; s.pop(); cur = cur-&gt;_right; &#125; cout &lt;&lt; endl; &#125;&#125;//InOrderRvoid InOrderR()&#123; _InOrderR(_root); cout &lt;&lt; endl;&#125;void _InOrderR(Node* root)&#123; if(root)&#123; _InOrderR(root-&gt;_left); cout &lt;&lt; root-&gt;_key &lt;&lt; \" \"; _InOrderR(root-&gt;_right); &#125; return;&#125;","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"linux下简易彩色进度条","slug":"linux下简易彩色进度条","date":"2018-03-19T11:03:14.000Z","updated":"2018-03-19T13:11:24.096Z","comments":true,"path":"linux下简易彩色进度条.html","link":"","permalink":"http://www.jingxxn.cn/linux下简易彩色进度条.html","excerpt":"前言在Linux下安装文件的时候，都会有个进度条来提示我们安装的进度是多少。这里我们模拟输出这个进度条。主要用到输出函数的操作、缓冲区的刷新、usleep函数、linux终端颜色的显示等知识。效果如下：","text":"前言在Linux下安装文件的时候，都会有个进度条来提示我们安装的进度是多少。这里我们模拟输出这个进度条。主要用到输出函数的操作、缓冲区的刷新、usleep函数、linux终端颜色的显示等知识。效果如下： 铺垫知识点缓冲区缓冲区分位三种：无缓冲，行缓冲，全缓冲。无缓冲：没有缓冲，也就是信息在输入输出的时候，立马输入或输出。典型的代表就是标准错误流stderr。行缓冲：当输入输出的时候，遇到换行才执行I/O操作。典型的代表是键盘的操作。全缓冲：当输入输出写满缓冲区才执行I/O操作。典型的代表是磁盘的读写。由于输出函数是行缓冲类型的。所以我们需要使用缓冲区刷新函数fflush来输出。否则我们看到的进度条将是一段一段输出的。补充：printf函数是一个行缓冲函数，先写到缓冲区，满足条件就将缓冲区刷到对应文件中。满足下列条件之一，缓冲区都会刷新：（1）缓冲区填满（2）写入的字符中有&#39;\\n&#39;&#39;\\r&#39;（3）调用fflush刷新缓冲区（4）调用scanf从缓冲区获取数据时，也会刷新新缓冲区。 换行符有两个符号需要区分：&#39;\\n&#39;&#39;\\r&#39;。他们有不同的含义。&#39;\\n&#39;表示的是换行，将光标指向下一行的开头位置。’`r’`指的是回车，将光标回到当前行的开头位置。在这里我们要使用&#39;\\r&#39;，否则我们的进度条将输出一个&#39;#&#39;就换一行。 usleep函数刷新了缓冲区之后，如果并没有加上睡眠函数，结果将一次性输出来。进度条应该是随着加载不停出现才对。这里统一总结一下Linux睡眠函数：头文件：#include &lt;unistd.h&gt;以 秒为单位：unsigned int sleep( unsigned int seconds );以 微秒为单位：int usleep ( useconds_t usec );以 四分之一毫秒为单位：extern void delay( unsigned int msec ); 以睡眠一秒为例:sleep(1); usleep(1000 000); delay(250); 输出颜色的设置printf函数可以通过输出特定的转义序列来实现输出字符的颜色和状态。转义序列以控制字符’ESC’开头。该字符的ASCII码十进制表示为27，十六进制表示为0x1B，八进制表示为033。多数转义序列超过两个字符，故通常以’ESC’和左括号’[‘开头。该起始序列称为控制序列引导符(CSI，Control Sequence Intro)，通常由’\\033[‘或’\\e[‘代替。一般格式如下：(显示方式指的是样式，前景色是30+颜色值，背景色是40+颜色值，字符m表示结束) \\033[显示方式；前景色；背景色m + 输出字符串或者\\e[显示方式；前景色；背景色m + 输出字符串 常见参数如下：显示方式：0(默认)、1(粗体/高亮)、22(非粗体)、4(单条下划线)、24(无下划线)、5(闪烁)、25(无闪烁)、7(反显、翻转前景色和背景色)、27(无反显)颜色：0(黑)、1(红)、2(绿)、 3(黄)、4(蓝)、5(洋红)、6(青)、7(白)见例子：123printf(\"\\033[31mHello!\\n\\033[0m\");printf(\"\\033[4;32mHello!\\n\\033[0m\");printf(\"\\033[1;34;43mHello!\\n\\033[0m\"); 其中：\\033[0m用于恢复默认的终端输出属性，否则会影响后续的输出。颜色设置详细解析传送门 代码如下1234567891011121314151617181920212223242526272829#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main()&#123; int i = 0; int j = 0; char bar[102]; //color数组用来改变颜色的值，让进度条在七种颜色中变幻 int color[] = &#123;1, 2, 3, 4, 5, 6, 7&#125;; //设置状态，显示此时正在加载 const char *status = \"|/-\\\\\"; memset(bar, 0, siezof(bar)); while(i &lt;= 100)&#123; //无颜色版本 //printf(\"[%-100s][%d%%][%c]\\r\", bar, i, status[i%4]); printf(\"\\033[3%dm[%-100s]\\033[0m\\033[33m[%d%%]\\033[0m[%c]\\r\", color[j], bar, i, lable[i%4]); fflush(stdout); bar[i ++] = '#'; //每加载15%，就变换一次颜色 if(i%15 == 0)&#123; ++ j; &#125; //休眠0.03秒输出字符 usleep(30000); &#125; printf(\"\\n\"); return 0;&#125; 参考一参考二","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.jingxxn.cn/categories/Linux/"},{"name":"practice","slug":"Linux/practice","permalink":"http://www.jingxxn.cn/categories/Linux/practice/"}],"tags":[]},{"title":"C语言输入输出函数详解","slug":"C语言文件输入输出函数详解","date":"2018-03-15T11:56:44.000Z","updated":"2018-03-22T10:14:24.061Z","comments":true,"path":"C语言文件输入输出函数详解.html","link":"","permalink":"http://www.jingxxn.cn/C语言文件输入输出函数详解.html","excerpt":"总览12345678910111213141516171819202122232425262728293031323334353637383940414243//错误报告函数：void perror( char const* str );//终止执行函数：void exit (int status);//打开和关闭文件函数FILE * fopen ( const char * filename, const char * mode );int fclose ( FILE * stream );//字符输入函数int fgetc ( FILE * stream );int getc ( FILE * stream );int getchar ( void );//字符输出函数int fputc ( int character, FILE * stream );int putc ( int character, FILE * stream );int putchar ( int character );//撤销字符函数：int ungetc ( int character, FILE * stream );//文本行输入函数char * fgets ( char * str, int num, FILE * stream );char* gets( char* str );//文本行输出函数int fputs ( const char * str, FILE * stream );int puts ( const char * str );//格式化输入函数int fscanf( FILE* stream, const char* format, ... );int scanf( const char* format, ... );int sscanf( const char* s, const char* format, ... );//格式化输出函数int fprintf( FILE* stream, const char* format, ... );int printf( const char* format, ... );int sprintf( char* str, const char* format, ... );//二进制I/O函数size_t fread( void* ptr, size_t size, size_t count, FILE* stream );size_t fwrite( void* ptr, size_t size, size_t count, FILE* stream );//刷新缓冲区函数：int fflush ( FILE * stream );//文件流定位函数long int ftell( FILE* stream );int fseek( FILE* stream, long offset, int from );//流错误函数int feof( FILE* stream );int ferror( FILE* stream );void clearerr( FILE* stream );","text":"总览12345678910111213141516171819202122232425262728293031323334353637383940414243//错误报告函数：void perror( char const* str );//终止执行函数：void exit (int status);//打开和关闭文件函数FILE * fopen ( const char * filename, const char * mode );int fclose ( FILE * stream );//字符输入函数int fgetc ( FILE * stream );int getc ( FILE * stream );int getchar ( void );//字符输出函数int fputc ( int character, FILE * stream );int putc ( int character, FILE * stream );int putchar ( int character );//撤销字符函数：int ungetc ( int character, FILE * stream );//文本行输入函数char * fgets ( char * str, int num, FILE * stream );char* gets( char* str );//文本行输出函数int fputs ( const char * str, FILE * stream );int puts ( const char * str );//格式化输入函数int fscanf( FILE* stream, const char* format, ... );int scanf( const char* format, ... );int sscanf( const char* s, const char* format, ... );//格式化输出函数int fprintf( FILE* stream, const char* format, ... );int printf( const char* format, ... );int sprintf( char* str, const char* format, ... );//二进制I/O函数size_t fread( void* ptr, size_t size, size_t count, FILE* stream );size_t fwrite( void* ptr, size_t size, size_t count, FILE* stream );//刷新缓冲区函数：int fflush ( FILE * stream );//文件流定位函数long int ftell( FILE* stream );int fseek( FILE* stream, long offset, int from );//流错误函数int feof( FILE* stream );int ferror( FILE* stream );void clearerr( FILE* stream ); 错误报告函数：void perror( char const* str );先解释一个整型变量errno，这个变量是错误码，当一个库函数失败的时候，errno会被设置。形参：str是一个字符串补充：当一个程序执行了错误的操作的时候，操作系统设置一个errno，perror函数首先会将str中的信息打印出来，后面跟上一个分号和空格，在打印出一条用于解释errno当前错误码的信息。例子：12345678910111213/* perror example */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; pFile=fopen (\"unexist.ent\",\"rb\"); if (pFile==NULL) perror (\"The following error occurred\"); else fclose (pFile); return 0;&#125; 如果文件unexist.ent不存在，那么将会输出以下信息： 注意：只有当一个库函数失败的时候，errno才会被设定。当函数成功运行的时候，errno并不会被设定。所以我们不能通过测试errno的值来判断是否有错误发生。 终止执行函数：void exit( int status );头文件：stdlib.h形参：status参数返还给操作系统。预定符号是EXIT_SUCCESS和EXIT_FAILURE。通常用0和EXIT_SUCCESS表示程序正常退出，用除零以外的整数和EXIT_FAILURE表示程序退出异常。补充：我们经常将这个函数和perror配合起来使用，当我们发现了程序的错误的时候，用来终止程序的执行。例子：12345678910111213141516171819/* exit example */#include &lt;stdio.h&gt; /* printf, fopen */#include &lt;stdlib.h&gt; /* exit, EXIT_FAILURE */int main ()&#123; FILE * pFile; pFile = fopen (\"myfile.txt\",\"r\"); if (pFile==NULL) &#123; printf (\"Error opening file\"); exit (EXIT_FAILURE); &#125; else &#123; /* file operations here */ &#125; return 0;&#125; 如果文件myfile.txt不存在 打开文件函数：FILE* fopen( char const* filename, const char* mode );形参：两个参数都是字符串，filename是希望打开的文件或者设备名字；mode是用来表示流是用于只读、只写、读和写，以及是文本流还是二进制流。返回值：如果成功打开文件，返回一个指向FILE类型的指针。失败返回一个NULL，并把错误码存入errno中。补充：以一定的模式打开文件或设备。模式常见如下：以下模式用文本流打开： 模式 功能 “r” read，只能读取，不能写入，同时要求文件必须存在。 “w” write，只能写入，不能读取。若文件存在，那么清空文件内容再写入；若文件不存在，创建文件再写入。 “a” append，只能写入，不能读取。若文件存在，在文件末尾添加内容；如果文件不存在，创建文件再写入。 “r+” read/update，可读可写，要求文件必须存在。 “w+” write/update，可读可写，如果文件存在，清空文件内容再写入；如果文件不存在，创建文件再写入。 “a+” append/update，可读可写，若文件存在，在文件末尾添加内容；若文件不存在，创建文件再写入。 以下模式用二进制流打开：“rb”, “wb”, “ab”, “r+b”, “w+b”, “a+b”或者”rb+”, “wb+”, “ab+”。功能和文本流一样，只是打开写入方式是二进制流。 二进制流和文本流的区别：文本流(text)：指的是在流中流动的数据是 以字符形式出现的。举个例子：输入的时候，’\\n’这个符号会被替换为回车CR和换行的ASCII码0DH和0AH。输出的时候，0DH和0AH被替换为’\\n’。二进制流(binary)：指的是在流中流动的数据是以 二进制数字序列出现的。说白了就是在内存中是怎么存储的，输入到文件中也是怎么样存储的。而且不会对’\\n’进行替换。举个例子：对于2001这个数文本流用ASCII码表示：’2’’0’’0’’1’分别是：50,48,48,49一共是四个字节二进制流表示为：0000 0111 1101 0001转换为十六进制就是07D1，占用了两个字节。此例来源：http://blog.csdn.net/barryCG/article/details/7621097 例子：12345678910111213/* fopen example */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; pFile = fopen (\"myfile.txt\",\"w\"); if (pFile!=NULL) &#123; fputs (\"fopen example\",pFile); fclose (pFile); &#125; return 0;&#125; 如果没有myfile.txt这个文件，将会创建一个myfile.txt文件，并写入内容fopen example。 关闭文件函数：int fclose( FILE* stream );形参：stram是一个FILE类型指针指向的流文件。返回值：当文件被正常关闭，返回一个整型的0；如果关闭异常，返回文件结束符EOF，通常被解释为整型的-1。补充：我们习惯于将fopen和fclose搭配使用。fclose会在文件关闭的之前刷新缓冲区，将缓冲区的数据存入文件中，否则会有数据丢失。必要的时候，我们需要检测fclose的返回值是否正确，以避免数据丢失或。 输入输出函数总览 家族名 目的 可用于所有的流 只用于stdin或stdout 内存中的字符串 getchar 字符输入 fget,getc getchar ① putchar 字符输出 fputc,putc putchar ① gets 文本行输入 fgets gets ② puts 文本行输出 fputs puts ② scanf 格式化输入 fscanf scanf sscanf printf 格式化输出 fprintf printf sprintf ①表示对指针使用下标引用或间接访问操作从内存中获得\\写入一个字符②使用strcpy函数从内存读取\\写入文本行 字符输入函数：fgetc、getc、getchar函数原型：int fgetc( FILE* stream ); 用于所有流宏原型：int getc(FILE* stream ); 用于所有流int getchar( void ); 只能用于stdin形参：stram是一个FILE类型指针指向的流文件。返回值：若读取成功，返回读取的一个字符，并实现整型提升。若到了文件的结束，返回EOF表示文本的结束。若读取失败，同样返回EOF并设置error变量。补充：1、函数作用是读取一个字符，同时文件指针向后指向下一个字符。2、返回值是整型，这是因为允许函数报告文件末尾(EOF)。如果返回值是char型，那么256个字符中肯定有一个被指用于表示EOF。如果这个字符在文件内部出现，这个字符以后的内容不会被读取。因为这个字符被解释为EOF。所以应该使用整型变量来接收这个字符3、fgetc是函数，getc和getchar是通过#define定义的宏。所以getc和getchar不能传入带有副作用的参数。同时，getc和getchar的效率会比fgetc快上一点。4、getchar始终从标准输入读取一个字符。例子：12345678910111213141516171819202122232425/* fgetc example: money counter */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //EXIT_FAILUREint main ()&#123; FILE * pFile; int c; int n = 0; pFile=fopen (\"myfile.txt\",\"r\"); if (pFile==NULL) &#123; perror (\"Error opening file\"); exit(EXIT_FAILURE); &#125; else &#123; do &#123; c = fgetc (pFile); if (c == '$') n++; &#125; while (c != EOF); fclose (pFile); printf (\"The file contains %d dollar sign characters ($).\\n\",n); &#125; return 0;&#125; 上面代码用来统计myfile.txt中$符号的个数，在文件中输入五个，最后得到结果正确。如果没有这个文件，将会执行perror程序，报错 字符输出函数：fputc、putc、putchar函数原型：int fputc( int character, FILE* stream ); 用于所有流宏原型：int putc( int character, FILE* stream ); 用于所有流int putchar( int character ); 只能用于stdout形参：character是将要被输出的字符；stram是一个FILE类型指针指向的流文件。返回值：若函数执行成功，返回被写入的字符；若失败，返回EOF。同时errno被设置。补充：1、参数character在输入的时候会被裁剪为无符号整型。2、fputc是真正的函数，putc和putchar是#define定义的宏函数。3、putchar始终将字符打印在标准输出流。例子：12345678910111213141516/* fputc example: alphabet writer */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; char c; pFile = fopen (\"alphabet.txt\",\"w\"); if (pFile!=NULL) &#123; for (c = 'A' ; c &lt;= 'Z' ; c++) fputc ( c , pFile ); fclose (pFile); &#125; return 0;&#125; 上述代码将大写字符A~Z写入文件alphabet.txt中。 撤销字符函数 ：int ungetc( int character, FILE* stream );这个函数的作用是将先前读取到的字符返回到原来的流中，这样它可以在以后被重新读入。形参：character是要返回的字符，stram是一个FILE类型指针指向的流文件。返回值：若成功，返回被返回流中的字符；若失败，EOF被返回。补充：1、“退回”的字符和流当前的位置有关，所以如果用fseek、fsetpos、rewind函数改变了流的位置，所有退回的字符将被丢弃。2、把字符退回到流中和写入到流中是不一样的。也就是从文件中读取出来后的退回，并不会影响到物理存储上的内容。例子：12345678910111213141516171819202122/* ungetc example */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; int c; char buffer [256]; pFile = fopen (\"myfile.txt\",\"rt\"); if (pFile==NULL) perror (\"Error opening file\"); else while (!feof (pFile)) &#123; c=getc (pFile); if (c == EOF) break; if (c == '#') ungetc ('@',pFile); else ungetc (c,pFile); if (fgets (buffer,255,pFile) != NULL) fputs (buffer,stdout); else break; &#125; return 0;&#125; 上述代码，将文件myfile.txt中每行开头的’#’替换为‘@’。如果打开失败，打印”Error opening file”。 文本行输入函数：fgets、gets函数原型：char* fgets( char* str, int num, FILE* stream );char* gets( char* str ); //一般不使用，不安全。完全可以用fgets代替。形参：str是目标字符串，num是一个整型参数；用来表示读取的字符个数,它包括了’\\0’在内；stream是获取字符的流。返回值：如果读取失败，也就是在读取任何字符之前就到了文件的结束，缓冲区没有被修改，返回一个NULL指针；如果读取成功，返回str。补充：1、当fgets读取到一个换行符并存储到缓冲区之后，结束读取。2、如果读取的字符数量达到num-1个，结束读取。但是这种情况并不会出现数据丢失，因为下次调用fgets将从流的下一个字符开始读取。3、任何一种情况下，一个NUL字节将被添加到缓冲区所存储数据的末尾，让其成为一个字符串。例子：1234567891011121314151617/* fgets example */#include &lt;stdio.h&gt;int main()&#123; FILE * pFile; char mystring [100]; pFile = fopen (\"myfile.txt\" , \"r\"); if (pFile == NULL) perror (\"Error opening file\"); else &#123; if ( fgets (mystring , 100 , pFile) != NULL ) puts (mystring); fclose (pFile); &#125; return 0;&#125; 上述代码，获取文件myfile.txt中的第一行字符串最多获取99个字符。注意：1、fgets无法将字符串读取到一个长度小于两个字符的缓冲区，因为其中一个字符需要为NUL字节保留。2、gets和fgets的不同，在于gets读取一行输入是，它不在缓冲区中存储结尾的换行符。3、同时，应该注意的是，我们并不使用gets，因为它没有缓冲区长度参数，如果一个长输入行读到一个短缓冲区，多出来的字符将被写入到缓冲区后面的内存位置，这样会破坏此内存中的数据。 文本行输出函数：fputs、puts函数原型：int fputs( const char* str, FILE* stream );int puts( const char* str );形参：str是一个字符型指针，用来指向一个字符串，用来获取输入。返回值：如果函数调用失败，返回EOF；成功返回一个非负数的值。补充：1、fputs函数输出行的时候，不会将字符串的’\\0’输出。123456789101112#include &lt;stdio.h&gt;int main ()&#123; FILE *pFile; pFile = fopen(\"file.txt\", \"a\"); fputs(\"this is c\", pFile); fputs(\"this is cpp\", pFile); fclose(pFile); return(0);&#125; 上述代码可以证明，fputs不输出字符串结尾’\\0’。2、puts函数会在读取的字符串后面自动加上一个结尾符号’\\0’，并输出到stdin中。 格式化输入函数：fscanf、scanf、sscanf函数原型：int fscanf( FILE* stream, const char* format, … );int scanf( const char* format, … );int sscanf( const char* s, const char* format, … );形参：stream是一个FILE指针指向的流；format字符串是相应的格式。省略号表示一个可变长度的指针列代表。sscanf中的s指的是一个字符串，用来读取字符。返回值：当字符串到达末尾或读取的输入不再匹配字符串所指定的类型的时候，输入停止。同时，被转换的输入值的个数当成函数的返回值；如果在任何输入值被转换之前文件就已经到达了尾部，返回EOF。补充：1、输入源的区别：fscanf的输入源是stream；scanf的输入源是标准输入stdin；sscanf的输入源是字符串s。2、这些函数的正常运行依赖于格式代码。必须保证指针参数的类型必须是对应格式代码的正确类型。否则将会产生垃圾值。比如下面例子：123456789#include &lt;stdio.h&gt;int main ()&#123; float a; scanf(\"%d\", &amp;a); printf(\"%f\", a); return 0;&#125; 上述代码中a的类型是float，但是输入的时候指针参数的类型是整型，而格式代码是&amp;a，是float类型。输出的时候用的是float输出，最终得到了垃圾值。3、为什么scanf中需要用&amp;符号。这个是因为在c中是传值调用，如果需要修改当前值地址的内容就需要传递一个地址。否则将会程序崩溃。4、format字符串参数解析：(1)空白字符：它们与输入中的零个或多个空白字符匹配，在处理的过程中被忽略。(2)格式代码：它们指定函数如何解释接下来的输入字符。(3)其他字符：当任何其他字符出现在格式字符串时，下一个输入字符必须与之匹配。如果匹配，该字符被丢弃。如果不匹配，函数结束读取。5、格式代码解析：上述代码都是以%开头，接下来接：(1)星号：星号将转换后的值被丢弃而不是存储，可以用来跳过不需要输入的字符。(2)宽度：以一个非负整数给出，它限制被读取用于转换的输入字符个数。如果没有给出宽度，那么就连续读入字符直到遇到输入中的下一个空白字符。下面这个例子给出宽度的用法：12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int a = 0; int b = 0; int c = 0; FILE* input = fopen(\"input.txt\", \"r\"); if (input == NULL) perror (\"Error opening file\"); else&#123; fscanf(input, \"%4d %4d %4d\", &amp;a, &amp;b, &amp;c); printf(\"a = %d\\n\", a); printf(\"b = %d\\n\", b); printf(\"c = %d\\n\", c); &#125; return 0;&#125; input.txt中存放如下：输出如下：只有a和b改变，c未改变。如果input.txt中存放如下；输出如下：a=1234，b=5，c=6789。0被舍弃注意：在使用fscanf函数的时候，文件中的换行符也被当成了空白字符跳过。(3)限定符：h,l,L；限定符的目的是为了指定参数的长度。具体见下表：(4)格式代码：就是单个字符，用于指定输入字符将被如何解析。上表中的第一列就是部分格式代码。具体见下表：例子：12345678910111213141516171819/* scanf example */#include &lt;stdio.h&gt;int main ()&#123; char str [80]; int i; printf (\"Enter your family name: \"); scanf (\"%79s\",str); printf (\"Enter your age: \"); scanf (\"%d\",&amp;i); printf (\"Mr. %s , %d years old.\\n\",str,i); printf (\"Enter a hexadecimal number: \"); scanf (\"%x\",&amp;i); printf (\"You have entered %#x (%d).\\n\",i,i); return 0;&#125; 上述例子就是对各种格式的输入。 格式化输出函数：fprintf、printf、sprintf函数原型：int fprintf( FILE* stream, const char* format, … );int printf( const char* format, … );int sprintf( char* str, const char* format, … );形参：stream是一个FILE指针指向的流；format字符串是相应的格式。省略号表示一个可变长度的指针列代表。sprintf中str是一个用来存储字符的指定字符串。返回值：返回值就是实际打印或者存储的字符个数。补充：1、sprintf是一个容易出错的函数，因为缓冲区的大小并没有作为一个形参被传入。函数并不知道该输入多少个字符是安全的。2、printf家族函数和scanf家族函数一样，必须保证值和格式码表示一致。3、format字符串中含有格式代码，格式代码由一个百分号开头，后面可以跟：(1)零个或者多个标志字符。(2)一个可选的最小字段宽度(3)一个可选的精度(4)一个可选的修改符(5)转换类型4、格式代码如下：5、格式标志如下： 二进制I/O函数：函数原型：size_t fread( void* ptr, size_t size, size_t count, FILE* stream );size_t fwrite( void* ptr, size_t size, size_t count, FILE* stream );形参：ptr是一个指向用于保存数据的内存位置的指针，至少有size*count个字节；size是缓冲区中每个元素的字节数；count是读取的元素数。返回值：实际读取的元素(非字节)的数目，如果过程中遇到了文件尾，这个数字可能比请求的元素数目小。补充：一般来说，二进制的写入效率比文件写入要高，因为二进制输出避免了在数值转换为字符串过程中所涉及的开销和精读损失。但是很遗憾的是，二进制的数据，不是我们人眼可以阅读的。文本写入的文件就可以很好的阅读。例子：123456789101112131415161718192021222324252627282930313233/* fread example: read an entire file */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main () &#123; FILE * pFile; long lSize; char * buffer; size_t result; pFile = fopen ( \"myfile.bin\" , \"rb\" ); if (pFile==NULL) &#123;fputs (\"File error\",stderr); exit (1);&#125; // obtain file size: fseek (pFile , 0 , SEEK_END); lSize = ftell (pFile); rewind (pFile); // allocate memory to contain the whole file: buffer = (char*) malloc (sizeof(char)*lSize); if (buffer == NULL) &#123;fputs (\"Memory error\",stderr); exit (2);&#125; // copy the file into the buffer: result = fread (buffer,1,lSize,pFile); if (result != lSize) &#123;fputs (\"Reading error\",stderr); exit (3);&#125; /* the whole file is now loaded in the memory buffer. */ // terminate fclose (pFile); free (buffer); return 0;&#125; 上述例子将文件myfile.bin中的数据，通过函数fread读取到数组buffer中去。 刷新缓冲区函数：int fflush( FILE* stream );返回值：若函数正确执行返回一个0，若失败，返回EOF同时error被设置。补充：这个函数会立刻刷新缓冲区，如果我们需要输入的字符立刻写入的话，我们可以调动这个函数。例子：1234567891011121314151617/* fflush example */#include &lt;stdio.h&gt;char mybuffer[80];int main()&#123; FILE * pFile; pFile = fopen (\"example.txt\",\"r+\"); if (pFile == NULL) perror (\"Error opening file\"); else &#123; fputs (\"test\",pFile); fflush (pFile); // flushing or repositioning required fgets (mybuffer,80,pFile); puts (mybuffer); fclose (pFile); return 0; &#125;&#125; 上述例子，使用了fflush将缓冲区中的test立刻刷新到文件流pFile中，然后从pFile中获取最多80个字符到mybuffer中。并打印到屏幕上。example.txt存储内容如下：执行程序之后的输出：从被替换的第四个字符开始输出，这个是因为文本指针已经指向第四个字符。执行之后的example.txt内容：前四个字符被替换成text如果没有刷新函数fflush将会出现下面情况：输出如下：此时的缓冲区未刷新，内容并没有写入文本流pFile中。example.txt3内容：当调用puts函数的时候，缓冲区的内容被刷新，所有缓冲区的内容被写入pFile中 文件流定位函数：ftell、fseek函数原型：long int ftell( FILE* stream );int fseek( FILE* stream, long offset, int from );形参：参考下表：补充：1、ftell返回流的当前位置。这函数允许你保存一个文件的当前位置，可能在将来会返回到这个位置。在二进制流中，这个值就是当前位置距离文件起始位置之间的字节数。2、fseek允许你定位在流中的位置，用于下次的读取或写入。3、在二进制流中，从SEEK_END进行定位可能不被支持，应该避免。在文本流中，如果from是SEEK_CUR或SEEK_END，offset必须是零。如果from是SEEK_SET，offset必须是一个从同一个流中以前调用ftell所返回的值。4、这些限制的存在，部分原因是因为文本流所执行的行末字符映射。由于这个映射的存在，文本文件的字节数可能和程序写入的字节数不同。5、用fseek改变一个流的位置会带来三个副作用。第一个，行末指示字符会被清除；第二个，在fseek之前用ungetc退还给流的字符，会被丢失；第三个，定位允许你从写入切换到读取，或者回到打开的流用来更新。例子：12345678910111213141516171819/* ftell example : getting size of a file */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; long size; pFile = fopen (\"myfile.txt\",\"r\"); if (pFile==NULL) perror (\"Error opening file\"); else &#123; fseek (pFile, 0, SEEK_END); // non-portable size=ftell (pFile); fclose (pFile); printf (\"Size of myfile.txt: %ld bytes.\\n\",size); &#125; return 0;&#125; 上述程序就是通过利用fseek函数将文件指针定位到文本末，然后通过ftell函数获取当前位置。这样可以统计出文件字节数。下面这个例子说明了文本文件下，换行符被编译为两个字符，分别是&#39;\\n&#39;&#39;\\r&#39; 流错误函数：feof、ferror、clearerr函数原型：int feof( FILE* stream );int ferror( FILE* stream );void clearerr( FILE* stream );返回值：若到了文件的结束，返回一个非零的值；若不是文件结尾，返回一个零。补充：1、feof函数检查文件指针是否指向文本结束符。ferror函数报告流的错误状态。clearerr对指定流的错误标准进行重置。2、函数clearerr、rewind、fseek会清除文末指示符，当时下次有I/O函数操作这个流，文末指示符会被重新设定。例子：1234567891011121314151617181920212223/* feof example: byte counter */#include &lt;stdio.h&gt;int main ()&#123; FILE * pFile; int n = 0; pFile = fopen (\"myfile.txt\",\"rb\"); if (pFile==NULL) perror (\"Error opening file\"); else &#123; while (fgetc(pFile) != EOF) &#123; ++n; &#125; if (feof(pFile)) &#123; puts (\"End-of-File reached.\"); printf (\"Total number of bytes read: %d\\n\", n); &#125; else puts (\"End-of-File was not reached.\"); fclose (pFile); &#125; return 0;&#125; 上述代码读取文件中的字符个数， 并在文件结束的时候，返回读取字符个数。 本文中的知识点来自于C和指针，代码例子绝大部分来自网站www.cplusplus.com","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"查看Linux系统版本信息","slug":"查看Linux系统版本信息","date":"2018-03-08T03:44:55.000Z","updated":"2018-03-08T08:32:20.222Z","comments":true,"path":"查看Linux系统版本信息.html","link":"","permalink":"http://www.jingxxn.cn/查看Linux系统版本信息.html","excerpt":"查看内核版本 cat /proc/version uname -a","text":"查看内核版本 cat /proc/version uname -a 查看系统版本 cat /etc/redhat-release lsb_release -a 这个命令需要安装，安装命令： yum install lsb -y cat /etc/issue 都说可以，这个我的查出来很奇怪 rpm -q centos-release 查看cpu相关信息，包括型号、主频、内核等信息 cat /proc/cpuinfo 参考地址1参考地址2","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.jingxxn.cn/categories/Linux/"},{"name":"method","slug":"Linux/method","permalink":"http://www.jingxxn.cn/categories/Linux/method/"}],"tags":[]},{"title":"Linux中时间的设置","slug":"Linux中时间的设置","date":"2018-03-08T03:36:45.000Z","updated":"2018-03-08T12:33:37.661Z","comments":true,"path":"Linux中时间的设置.html","link":"","permalink":"http://www.jingxxn.cn/Linux中时间的设置.html","excerpt":"test: CentOS Linux release 7.4.1708 (Core) 查看时区 data -R +0800 表示在东八区其中：CST：中国标准时间（China Standard Time），这个解释可能是针对RedHat Linux。UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。UTC较于GMT更准确。GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。 修改时区 tzselect","text":"test: CentOS Linux release 7.4.1708 (Core) 查看时区 data -R +0800 表示在东八区其中：CST：中国标准时间（China Standard Time），这个解释可能是针对RedHat Linux。UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。UTC较于GMT更准确。GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。 修改时区 tzselect 这个命令并不是用来修改时区的，这个命令可以通过你自己的选择然后清楚的知道每个时区的样式。然后你通过修改.progile、.bash_profile或者/etc/profile文件，设置正确的TZ环境变量并导出，可以成功改变时区。 tip：这些修改应该出现用户家目录下下面例子，我将时区由东八区改变为波兰的时区，东一区：先通过tzselect查询波兰的时区书写格式：然后通过修改文件.bash_profile并应用得以修改。 通过替换系统时区文件，或者创建链接文件 1、在目录/usr/share/zoneinfo中有所有的时区文件，通过复制替换到/etc/locatime即可但是有的时候会出现没有效果的情况，比如上例子。这是因为修改了在profile或.bash_profile中设置了TZ。这个时候就需要重新修改TZ。 2、创建链接文件这里如果出现修改失败，同上。 查看和修改时间和日期 datedate用于查看和设置 系统时间 如果不输入命令”hwclock -w”将时间写入硬件时间，电脑重启之后将会返回原样。 hwclockhwclock用来查看设置 硬件时间。 hwclock –hctosyshc代表硬件时间，sys代表系统时间，即用硬件时钟同步系统时钟 hwclock –systohc即用系统时钟同步硬件时钟,等于 hwclock -w 执行完这两个命令系统没有任何反馈。 解释一下硬件时钟和系统时钟的区别：硬件时钟指的是主板上由电池供电的那个时间，可以在BIOS中设置。Linux可以通过hwclock设置。当Linux启动的时候，硬件时钟会赋值给系统时钟。然后系统时钟会独立于硬件时钟工作。系统时钟指的是当前Linux Kernel中的时钟。Linux中的所有命令包括函数都是采用系统时钟设置的。这就是为什么当我们用date修改了时间，没有同步到硬件时钟的时候，这个修改是无效的。 时间自动同步 yum install -y ntpdate首先安装ntpdate软件，用来同步Linux时间服务。 ntpdate time.nist.gov 上面表示同步成功，调整时间为服务器129.6.15.29的时间，时间相差0.136318 sec hwclock -w调整硬件时间 crontab -e设定crontab计划任务自动校时，并添加下列内容0 1 * ntpdate time.nist.gov这样设定一个小时自动进行网络校时。 通过cat /etc/crontab 查看crontab的设置解释，如下：参考文章1参考文章2","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.jingxxn.cn/categories/Linux/"},{"name":"method","slug":"Linux/method","permalink":"http://www.jingxxn.cn/categories/Linux/method/"}],"tags":[]},{"title":"判断元素的入栈和出栈顺序是否合法","slug":"判断元素的入栈和出栈顺序是否一致","date":"2018-03-07T06:46:00.000Z","updated":"2018-03-07T07:48:17.619Z","comments":true,"path":"判断元素的入栈和出栈顺序是否一致.html","link":"","permalink":"http://www.jingxxn.cn/判断元素的入栈和出栈顺序是否一致.html","excerpt":"题目提供两个元素的集合，一个是元素入栈的顺序，另一个是元素出栈的顺序。设计一个函数，判断两个元素集合是否满足入栈出栈的规则。如：入栈顺序：“12345”，出栈顺序是：“54321”，这样就是符合要求的。如果出栈顺序是：“51234”，这样不符合要求。","text":"题目提供两个元素的集合，一个是元素入栈的顺序，另一个是元素出栈的顺序。设计一个函数，判断两个元素集合是否满足入栈出栈的规则。如：入栈顺序：“12345”，出栈顺序是：“54321”，这样就是符合要求的。如果出栈顺序是：“51234”，这样不符合要求。 思路根据题目的要求，就是判断两数组是否满足出栈入栈的顺序。可以这样做：1、先按照入栈顺序的集合进行入栈。2、在入栈的同时，跟出栈顺序的元素进行比较。如果相同就将入栈的元素pop出来。3、结束的时候，如果栈为空，说明两者的入栈顺序和出栈顺序可以匹配，那么就是符合要求的；如果栈不为空，那就是不符合要求。还有一点：如果两元素的个数不一样或者同时为空，直接判定不符合要求。 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;bool stack_io_right(char* src, char* dst)&#123; int src_len = sizeof(src); int dst_len = sizeof(dst); int i = 0; int j = 0; if(src_len == 0 || src_len != dst_len) return false; for(; i &lt; src_len; ++i)&#123; s.push(*(src+i)); while(s.size() &amp;&amp; s.top() == *(dst+j))&#123; ++j; s.pop(); &#125; &#125; if(s.empty()) return true; else return false;&#125;int main()&#123; system(\"clear\"); char src[] = \"12345\"; char dst[] = \"32145\"; char dst1[] = \"51243\"; cout &lt;&lt; stack_io_right(src, dst) &lt;&lt; endl; cout &lt;&lt; stack_io_right(src, dst1) &lt;&lt; endl; return 0;&#125; 运行结果","categories":[{"name":"practice","slug":"practice","permalink":"http://www.jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://www.jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"二叉树的基本实现","slug":"二叉树的基本实现","date":"2018-03-06T07:47:19.000Z","updated":"2018-03-06T09:16:54.673Z","comments":true,"path":"二叉树的基本实现.html","link":"","permalink":"http://www.jingxxn.cn/二叉树的基本实现.html","excerpt":"二叉树本文将使用c++实现模板类的二叉树，内容包括创建、递归遍历、非递归遍历、结点个数、深度、叶子结点的个数、第K层结点个数等函数。 结点、二叉树结构二叉树的结点是一个结构体，包括值_data，指向左子树的指针和指向右子树的指针_left和_right。还有构造函数，用于创建结点。","text":"二叉树本文将使用c++实现模板类的二叉树，内容包括创建、递归遍历、非递归遍历、结点个数、深度、叶子结点的个数、第K层结点个数等函数。 结点、二叉树结构二叉树的结点是一个结构体，包括值_data，指向左子树的指针和指向右子树的指针_left和_right。还有构造函数，用于创建结点。将BinaryTreeNode&lt;T&gt;typedef为Node,很多时候我会遗漏模板的类型名需要加上&lt;T&gt;，这样就会出错。为了减少这种错误，索性用typedef换名。&lt;12345678910111213141516171819202122template &lt;class T&gt;struct BinaryTreeNode&#123; BinaryTreeNode* _left; BinaryTreeNode* _right; T _data; BinaryTreeNode(const T&amp; data = T())&#123; _data = data; _left = NULL; _right = NULL; &#125;&#125;;template &lt;class T&gt;class BinaryTree&#123;typedef BinaryTreeNode&lt;T&gt; Node;public: //...protected: Node* _root;&#125;; 默认成员函数构造函数设置了两个构造函数，一个为空，用于创建一个空的二叉树；另一个参数为两个。const T* a 数组名const T&amp; invalid 非法值解释一下，这里我用一个数组创建二叉树，同时用’#’表示这个空。如这个例子： int a1[] = {1,2,3,&apos;#&apos;,&apos;#&apos;,4,&apos;#&apos;,&apos;#&apos;,5,6,&apos;#&apos;,&apos;#&apos;,&apos;#&apos;}; 如果a1[i] != &#39;#&#39;那么就创建，反之，表示这个位置没有结点。1234567891011121314151617//constructorBinaryTree()&#123; _root = NULL;&#125;BinaryTree(const T* a, const T&amp; invalid)&#123; size_t index = 0; _root = _CreateTree(a, invalid, index);&#125;Node* _CreateTree(const T* a, const T&amp; invalid, size_t&amp; index)&#123; Node* root = NULL; if(a[index] != invalid)&#123; root = new Node(a[index]); root-&gt;_left = _CreateTree(a, invalid, ++index); root-&gt;_right = _CreateTree(a, invalid, ++index); &#125; return root;&#125; 构造函数利用递归的思想，先跟的次序创建二叉树。由于要利用到递归，就没有办法直接用构造函数来实现，因为在class之外是没有办法访问到_root的。所以通过一个函数，利用这个函数来实现递归的过程。构造出来的二叉树关系图： 拷贝构造拷贝构造利用了一个_CopyTree函数。123456789101112BinaryTree(const BinaryTree&amp; tree)&#123; _root = _CopyTree(tree._root);&#125;Node* _CopyTree(Node* root)&#123; Node* node = root; if(node)&#123; node = new Node(root-&gt;_data); node-&gt;_left = _CopyTree(root-&gt;_left); node-&gt;_right = _CopyTree(root-&gt;_right); &#125; return node;&#125; 析构函数析构函数利用了一个Destroy函数1234567891011//destructor~BinaryTree()&#123; Destroy(_root);&#125;void Destroy(Node* root)&#123; if(root == NULL) return; Destroy(root-&gt;_left); Destroy(root-&gt;_right); delete root;&#125; operator=(赋值运算符的重载)先调用析构函数的Destroy销毁当前二叉树，然后调用_CopyTree重新构造当前二叉树。123456789101112131415//operator=BinaryTree&lt;T&gt;&amp; operator=(const BinaryTree&lt;T&gt;&amp; tree)&#123; if(this != &amp;tree)&#123; Destroy(_root); _root = _CopyTree(tree._root); return *this; &#125;&#125;//BinaryTree&lt;T&gt;&amp; operator=(BinaryTree&lt;T&gt; tree)&#123; //if(this != &amp;tree)&#123; //swap(_root, tree._root); //return *this; //&#125;//&#125; 赋值运算符的重载有两种实现方式，第一种是传统写法，第二种是现代写法。传统写法就是销毁原来的空间，然后重新开辟新的空间。对内存的操作比较多。现代写法是利用拷贝构造的方式，在传值进来的时候，生成一份临时拷贝，然后交换当前二叉树和临时拷贝的根节点，返回根节点，同时利用临时拷贝的作用域，交换后的二叉树在出了当前函数之后被销毁。相当于借用了系统的拷贝机制和自动析构机制来实现赋值的过程。 递归遍历先序遍历先序遍历：root left right12345678910111213//PrevOrdervoid PrevOrder()&#123; _PrevOrder(_root); cout &lt;&lt; endl;&#125;void _PrevOrder(Node* root)&#123; if(root)&#123; cout &lt;&lt; root-&gt;_data &lt;&lt; \" \"; _PrevOrder(root-&gt;_left); _PrevOrder(root-&gt;_right); &#125; return;&#125; 中序遍历中序遍历：left root right12345678910111213//InOrdervoid InOrder()&#123; _InOreder(_root); cout &lt;&lt; endl;&#125;void _InOreder(Node* root)&#123; if(root)&#123; _InOreder(root-&gt;_left); cout &lt;&lt; root-&gt;_data &lt;&lt; \" \"; _InOreder(root-&gt;_right); &#125; return;&#125; 后序遍历后序遍历：left root right12345678910111213//PostOrdervoid PostOrder()&#123; _PostOrder(_root); cout &lt;&lt; endl;&#125;void _PostOrder(Node* root)&#123; if(root)&#123; _PostOrder(root-&gt;_left); _PostOrder(root-&gt;_right); cout &lt;&lt; root-&gt;_data &lt;&lt; \" \"; &#125; return;&#125; 非递归遍历之所以要出现非递归遍历，是因为递归遍历有一定的缺陷。比如：当二叉树是一颗父节点只有一个子节点的树，那么对堆栈的使用就很大，有可能出现堆栈使用太深而栈溢出的情况。为了避免这种情况的出现，有必要使用非递归遍历。非递归遍历利用栈来实现对之前的结点的存储，因为每一颗二叉树都有可能有左右子树，所以需要在访问单边的子树的时候，将结点保存下来，这样是为了之后可以返回去访问结点的另一边的子树。 层次遍历层次遍历是一层一层的遍历结点的。它与之前三个的遍历方式都不一样。他利用的是队列，通过队列让父节点带动子节点。123456789101112131415161718192021//LevelOrdervoid LevelOrder()&#123; //不能是T，要用到root-&gt;_left; root-&gt;_right; //不好是Node，结构体太大; queue&lt;Node*&gt; q; if(_root)&#123; q.push(_root); while(!q.empty())&#123; Node* top = q.front(); //获取到队头之后，将当前结点pop q.pop(); cout &lt;&lt; top-&gt;_data &lt;&lt; \" \"; //如果左右子树存在，就入队列 if(top-&gt;_left) q.push(top-&gt;_left); if(top-&gt;_right) q.push(top-&gt;_right); &#125; &#125; cout &lt;&lt; endl;&#125; 先序遍历非递归根据先序遍历的特点，先输出当前结点，然后一路向左，访问完左边再返回访问上一个结点的右子树，这个就是子问题，利用上面一样的方法。1234567891011121314151617181920//PrevOrderNonRvoid PrevOrderNonR()&#123; //利用栈得以记录访问过的根，用来以后访问右子树 stack&lt;Node*&gt; s; Node* cur = _root; while(cur || !s.empty())&#123; //根据先根的次序，访问当前节点，并一路向左访问 while(cur)&#123; cout &lt;&lt; cur-&gt;_data &lt;&lt; \" \"; s.push(cur); cur = cur-&gt;_left; &#125; Node* top = s.top(); //pop表示左子树已经访问完，接下来访问右子树 s.pop(); //右子树的访问是子问题 cur = top-&gt;_right; &#125; cout &lt;&lt; endl;&#125; 中序遍历非递归中序遍历和先序遍历唯一的不同就是先序遍历是访问当前结点就打印当前结点，中序遍历就是先走完左边，再回来获取结点，这个时候再输出。12345678910111213141516//InOrderNonRvoid InOrderNonR()&#123; stack&lt;Node*&gt; s; Node* cur = _root; while(cur || !s.empty())&#123; while(cur)&#123; s.push(cur); cur = cur-&gt;_left; &#125; Node* top = s.top(); s.pop(); cout &lt;&lt; top-&gt;_data &lt;&lt; \" \"; cur = top-&gt;_right; &#125; cout &lt;&lt; endl;&#125; 后序遍历非递归后序遍历相比于之前的有一个转弯，看下图：所以为了区分这个点，先设立一个prev，prev指向当前结点cur的上一个结点。如果prev == cur-&gt;_right表示当前结点的右子树已经访问完成，那么就可以输出cur了。12345678910111213141516171819202122232425262728//PostOrderNonRvoid PostOrderNonR()&#123; stack&lt;Node*&gt; s; Node* cur = _root; Node* prev = NULL; while(cur || !s.empty())&#123; //一路向左走到底 while(cur)&#123; s.push(cur); cur = cur-&gt;_left; &#125; Node* top = s.top(); //访问当前结点的两个条件 //1、没有右子树 //2、右子树已经访问完成 if(top-&gt;_right == NULL || prev == top-&gt;_right)&#123; s.pop(); //此时的top成为过去式，将top设置为prev prev = top; cout &lt;&lt; top-&gt;_data &lt;&lt; \" \"; &#125; //此时表示右子树还没有访问 else&#123; cur = top-&gt;_right; &#125; &#125; cout &lt;&lt; endl;&#125; 结点个数函数以下函数都利用了递归的思想。 统计结点个数函数Size123456789//Sizesize_t Size()&#123; return _Size(_root);&#125;size_t _Size(Node* root)&#123; if(root == NULL) return 0; return _Size(root-&gt;_left) + _Size(root-&gt;_right) + 1;&#125; 统计深度函数Depth统计深度的时候，因为二叉树有左右子树，所以需要区分是左子树结点多还是右子树结点多。通过两个变量来记录，分别统计大小，然后再比较大小，大的是深度。这里默认根节点是第一层12345678910111213141516//Depthsize_t Depth()&#123; return _Depth(_root);&#125;size_t _Depth(Node* root)&#123; size_t leftnum = 0; size_t rightnum = 0; if(root == NULL) return 0; //如果存在就接着往下递归 if(root-&gt;_left) leftnum += _Depth(root-&gt;_left); if(root-&gt;_right) rightnum += _Depth(root-&gt;_right); return (leftnum &gt; rightnum ? leftnum : rightnum) + 1;&#125; 统计叶子结点个数的函数LeafSize叶子结点的统计是在当前结点都没有左右子树的时候返回个数1。1234567891011//LeafSizesize_t LeafSize()&#123; return _LeafSize(_root);&#125;size_t _LeafSize(Node* root)&#123; if(root == NULL) return 0; if(root-&gt;_left == NULL &amp;&amp; root-&gt;_right == NULL) return 1; return _LeafSize(root-&gt;_left) + _LeafSize(root-&gt;_right);&#125; 计算第K层的结点个数函数GetKLevel这个函数可以通过子问题的思想来解决。比如：我要计算第三层，当指针在第一层的时候，是计算K=3；当指针在第二层的时候，是计算K=2；当指针在第三层的时候，是计算K=1的结点个数。所以只要当K=1的时候返回计算值1就好了。12345678910111213//GetKLevelsize_t GetKLevel(size_t K)&#123; return _GetKLevel(_root, K);&#125;size_t _GetKLevel(Node* root, size_t K)&#123; if(K == 0 || root == NULL) return 0; if(K == 1) return 1; //不能使用--K，应该用K-1。 //不能返回除了K=1的其他情况。 return _GetKLevel(root-&gt;_left, K - 1) + _GetKLevel(root-&gt;_right, K - 1);&#125; 测试代码1234567891011121314151617181920212223242526272829303132int a1[] = &#123;1,2,3,'#','#',4,'#','#',5,6,'#','#','#'&#125;;int a2[] = &#123;1,2,'#',3,'#','#',4,5,'#',6,'#',7,'#','#',8,'#','#'&#125;;BinaryTree&lt;int&gt; tree(a1,'#');BinaryTree&lt;int&gt; tree1(a2, '#');BinaryTree&lt;int&gt; tree2(tree);tree2 = tree1;cout &lt;&lt; \"tree.PrevOrder\" &lt;&lt; endl;tree.PrevOrder();cout &lt;&lt; \"tree1.InOrder\" &lt;&lt; endl;tree1.InOrder();cout &lt;&lt; \"tree2.PostOrder\" &lt;&lt; endl;tree2.PostOrder();cout &lt;&lt; \"tree.LevelOrder\" &lt;&lt; endl;tree.LevelOrder();cout &lt;&lt; \"tree.PrevOrderNonR\" &lt;&lt; endl;tree.PrevOrderNonR();cout &lt;&lt; \"tree1.InOrderNonR\" &lt;&lt; endl;tree1.InOrderNonR();cout &lt;&lt; \"tree2.PostOrderNonR\" &lt;&lt; endl;tree2.PostOrderNonR();cout &lt;&lt; \"tree.Size:\" &lt;&lt; tree.Size() &lt;&lt; endl;cout &lt;&lt; \"tree.Depth:\" &lt;&lt; tree.Depth() &lt;&lt; endl;cout &lt;&lt; \"tree.LeafSize:\" &lt;&lt; tree.LeafSize() &lt;&lt; endl;cout &lt;&lt; \"tree.GetKLevel(K=2):\" &lt;&lt; tree.GetKLevel(2) &lt;&lt; endl;cout &lt;&lt; \"tree1.Size:\" &lt;&lt; tree1.Size() &lt;&lt; endl;cout &lt;&lt; \"tree1.Depth:\" &lt;&lt; tree1.Depth() &lt;&lt; endl;cout &lt;&lt; \"tree1.LeafSize:\" &lt;&lt; tree1.LeafSize() &lt;&lt; endl;cout &lt;&lt; \"tree1.GetKLevel(K=3):\" &lt;&lt; tree1.GetKLevel(3) &lt;&lt; endl; 截图如下：二叉树的实现，最重要的是要掌握子问题的思想，通过子问题的思想来解决左右子树，只需要一个递归就好了。","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"智能指针","slug":"智能指针","date":"2018-02-25T01:28:08.000Z","updated":"2018-02-26T07:50:16.314Z","comments":true,"path":"智能指针.html","link":"","permalink":"http://www.jingxxn.cn/智能指针.html","excerpt":"智能指针是C++中一个编程技巧。它保证内存的正确释放，解决了内存泄漏的问题。有一个思想叫做RAII，RAII指的是资源分配即初始化。我们通常会定义一个类来封装资源的分配和释放，在构造函数中完成资源的分配和初始化，在析构函数中完成资源的清理。在C++中，我们一般是使用new和delete来实现内存的初始化和释放。正确的配对使用可以处理绝大部分问题，但是如果出现了执行流的跳转，比如：语句中间出现了return，break，continue，goto，等关键字，我们的delete可能没有执行，这样就导致了内存没有被释放。又或者我们的语句出现了错误，抛出异常导致程序结束，也有可能没有执行delete语句。这 些问题都导致了内存泄漏。智能指针的出现就是为了解决这些问题的。智能指针其实是一个类，它可以自动的处理指针指向的动态资源的释放。 发展历程","text":"智能指针是C++中一个编程技巧。它保证内存的正确释放，解决了内存泄漏的问题。有一个思想叫做RAII，RAII指的是资源分配即初始化。我们通常会定义一个类来封装资源的分配和释放，在构造函数中完成资源的分配和初始化，在析构函数中完成资源的清理。在C++中，我们一般是使用new和delete来实现内存的初始化和释放。正确的配对使用可以处理绝大部分问题，但是如果出现了执行流的跳转，比如：语句中间出现了return，break，continue，goto，等关键字，我们的delete可能没有执行，这样就导致了内存没有被释放。又或者我们的语句出现了错误，抛出异常导致程序结束，也有可能没有执行delete语句。这 些问题都导致了内存泄漏。智能指针的出现就是为了解决这些问题的。智能指针其实是一个类，它可以自动的处理指针指向的动态资源的释放。 发展历程 早期C++98：auto_ptr，最早出现的智能指针，拷贝机制是管理权转移，致命缺陷，不使用。 boost(非官方)： scoped_ptr/scoped_array：守卫指针，拷贝机制是不拷贝，简单粗暴 shared_ptr/shared_array：共享指针，拷贝机制是引用计数，比较复杂，会出现循环引用的问题。 weak_ptr：弱指针，不单独使用，辅助共享指针解决循环引用的问题 C++11：unique_ptr对应boost的scoped_ptr；shared_ptr对应boost的shared_ptr；weak_ptr对应boost的weak_ptr。 本文主要实现shared_ptr和weak_ptr的模拟，auto_ptr和scoped_ptr模拟拷贝相关的函数。 auto_ptr123456789101112131415161718192021222324252627282930313233343536//模拟主要函数：template &lt;class T&gt;class AutoPtr&#123;private: T* _ptr;public: AutoPtr(T* ptr)&#123; _ptr = ptr; &#125; ~AutoPtr()&#123; delete _ptr; &#125; T&amp; operator*()&#123; return *_ptr; &#125; T* operator-&gt;()&#123; return _ptr; &#125; AutoPtr(AutoPtr&lt;T&gt;&amp; ap)&#123; //管理权转移 _ptr = ap._ptr; ap._ptr = NULL; &#125; AutoPtr&lt;T&gt;&amp; operator=(AutoPtr&lt;T&gt;&amp; ap)&#123; //自己给自己赋值不作处理 if(this != &amp;ap)&#123; if(_ptr) delete _ptr; //管理权转移 _ptr = ap._ptr; ap_ptr = NULL; &#125; return *this; &#125;&#125;;int main()&#123; AutoPtr&lt;int&gt; ap1(new int(10)); AutoPtr&lt;int&gt;ap2 = ap1; //崩溃，因为ap1已经指向NULL *ap1 = 20; return 0;&#125; 图解如下：任何时候我们都不使用auto_ptr，因为管理权的转移是不符合我们正常指针的使用的，而且会引起程序崩溃，这个是不允许的。最后，解释一下，operator-&gt;()返回T*的原因：12345//设定一个类struct student&#123; int num; &#125;//调用AutoPtr&lt;student&gt; sp = new student;sp-&gt;num = 20; sp-&gt;num等价于sp.operator-&gt;()。sp.operaotr-&gt;()返回T*指针之后，编译器自动将原式优化为_ptr-&gt;num,从而实现对元素的访问。 scoped_ptr防拷贝的智能指针，boost版本相当于C++11的unique_ptr12345678//模拟拷贝的主要函数：template &lt;class T&gt;class ScopedPtr&#123;private: //与AutoPtr不同的就是这两个函数 ScopedPtr(const ScopedPtr&lt;T&gt;&amp; sp); ScopedPtr&lt;T&gt;&amp; operator= (const ScopedPtr&lt;T&gt;&amp; sp);&#125;; scoped_ptr通过将拷贝构造函数和赋值运算符重载定义为私有，同时只声明不定义，这样可以保证该类不能被拷贝。这就简单的解决了auto_ptr因为拷贝导致的管理权转移问题。 shared_ptr引用计数的智能指针，这个类除了有指针之外，再多开辟了一个内存空间，用于存放计数。这种智能指针是实现的最好的，在boost库中，实现起来很复杂，因为要考虑多线程等情况。12345678910111213141516171819202122232425262728293031323334353637383940414243//模拟主要函数template &lt;class T&gt;class SharedPtr&#123;private: T* _ptr; int* _refcount;public: //构造 SharedPtr(const T&amp; ptr)&#123; _ptr = ptr; _refcount = new int(1); &#125; //析构 ~SharedPtr()&#123; if(--_refcount == 0)&#123; delete _ptr; delete _refcount; &#125; &#125; //拷贝构造 SharedPtr(SharedPtr&lt;T&gt;&amp; sp)&#123; _ptr = sp._ptr; _refcount = sp._refcount; ++_refcount; &#125; //赋值运算符重载 SharedPtr&lt;T&gt;&amp; operator=(const SharedPtr&lt;T&gt;&amp; sp)&#123; if(*this != &amp;sp)&#123; if(--(*_refcount) == 0)&#123; delete _ptr; delete _refcount; &#125; _ptr = sp._ptr; _refcount = sp._refcount; (*_refcount)++; &#125; return *this; &#125; //*重载 T&amp; operator*()&#123; return *_ptr; &#125; //-&gt;重载 T* operator-&gt;()&#123; return _ptr; &#125;&#125;; 这个实现，将是比较实用的。但是依然有一个场景下，会出现问题。这个问题叫做循环引用，问题的根源是引用计数被循环使用，不能减为0，导致死循环。下面以双向链表作为例子：1234567891011121314151617//定义一个链表节点如下struct ListNode&#123; //构造函数... //为了方便调用，设为public int _data; SharedPtr&lt;ListNode&gt; _next; SharedPtr&lt;ListNode&gt; _prev;&#125;;//调用这个节点，设定这样一个场景int main()&#123; SharedPtr&lt;ListNode&gt; cur(new ListNode); SharedPtr&lt;ListNode&gt; next(new ListNode); cur-&gt;_next = next; next-&gt;_prev = cur;&#125; 创建模型如下：根据上面例子，_next和next都指向后面节点这个空间，next._refcount = 2。_prev和cur指向前面那个节点的空间，cur._refcount = 2。当程序结束的时候，next先被析构。若需要析构next就需要析构next._prev;要析构next._prev就需要析构cur;要析构cur就需要析构cur._next;要析构cur._next就需要析构next……这样就造成了死循环。为了解决这个循环引用的问题，引入了弱指针weak_ptr。 weak_ptr弱指针不单独使用，它的存在就是为了解决使用shared_ptr造成的循环引用问题。12345678910111213141516171819202122232425262728293031323334template &lt;class T&gt;class WeakPtr&#123;private: T* _ptr;public: WeakPtr()&#123; _ptr = NULL; &#125; WeakPtr(const SharedPtr&lt;T&gt;&amp; sp)&#123; _ptr = sp._ptr; &#125; T&amp; operator*()&#123; return *_ptr; &#125; T* operator-&gt;()&#123; return _ptr; &#125; WeakPtr&lt;T&gt;&amp; operator=(const SharedPtr&lt;T&gt;&amp; sp)&#123; _ptr = sp._ptr; return *this; &#125;&#125;;//还需要修改一下两处：//1、修改ListNode的结构struct ListNode&#123; int _data; WeakPtr&lt;ListNode&gt; _next; WeakPtr&lt;ListNode&gt; _prev;&#125;;//2、将WeakPtr定义为SharedPtr的友元，因为WeakPtr中需要访问SharedPtr的私有成员template &lt;class T&gt;class SharedPtr&#123; friend class WeakPtr; //...&#125;; 这样，上面那个例子中，next._refcount = 1，cur._refcount = 1,就不会出现循环引用的问题了。","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"模板的类型萃取","slug":"模板的类型萃取","date":"2018-02-24T06:56:38.000Z","updated":"2018-02-24T09:30:16.478Z","comments":true,"path":"模板的类型萃取.html","link":"","permalink":"http://www.jingxxn.cn/模板的类型萃取.html","excerpt":"类型萃取，是C++中的一种编程技术。当我们希望对模板传递的不同类型进行不同的操作的时候，同时我们又不希望改变该模板的封装方式。我们可以通过这种技术，对传入的不同类型进行不同的原理操作。 特化要明白类型萃取，首先要知道模板中的特化。一般来说，我们的模板是通用类型的，但是如果有一些类型，我们希望有不同的操作方式，我们就可以通过特化的方式。例子如下：","text":"类型萃取，是C++中的一种编程技术。当我们希望对模板传递的不同类型进行不同的操作的时候，同时我们又不希望改变该模板的封装方式。我们可以通过这种技术，对传入的不同类型进行不同的原理操作。 特化要明白类型萃取，首先要知道模板中的特化。一般来说，我们的模板是通用类型的，但是如果有一些类型，我们希望有不同的操作方式，我们就可以通过特化的方式。例子如下：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;//模板的一般版本template &lt;class T&gt;class number&#123;public: void show()&#123; cout &lt;&lt; \"number\" &lt;&lt; endl; &#125;&#125;;//模板的int类型特化版本template &lt;&gt;class number&lt;int&gt;&#123;public: void show()&#123; cout &lt;&lt; \"int\" &lt;&lt; endl; &#125;&#125;;int main()&#123; system(\"clear\"); number&lt;int&gt; numint; numint.show(); number&lt;float&gt; numfloat; numfloat.show(); number&lt;char&gt; numchar; numchar.show(); return 0;&#125; 只有int类型才会输出int，其它的就像是float和char类型输出的都是number特化的方式，其实是十分冗余的。如果我的number类有很多的封装，那么实现它的特化，就需要将这些封装重新实现一遍。这样的复用性就十分低。 类型萃取TypeTraits关于类型萃取的知识，可以看看我的这篇读书笔记中的3.3和3.4我的个人博客文章地址我的CSDN博客文章地址这里我进行一个对于自创类SeqList类(对STL中vector的模拟)的类型萃取举例，情景说明：这里我想要对模板类SeqList进行拷贝，涉及到一个问题。如果我的元素类型是string的话，我必须进行深拷贝，否则就会出现奔溃的情况，这是对内存的使用出现问题。当我的元素类型是int、float、char等平凡类型(即POD:plain old data，基本类型，这些类型的拷贝不会涉及到内存的使用异常)，我就可以使用浅拷贝，这样比起深拷贝提高了效率。这个时候，我通过在SeqList类中进行类型萃取，就可以实现两种不同的拷贝方式：12345678910111213141516171819202122232425262728293031323334353637383940414243//定义两个空类struct __TrueType&#123;&#125;;struct __FalseType&#123;&#125;;//一般类型及特化(内嵌重定义IsPODType)template&lt;class T&gt;struct __TypeTraits&#123; typedef __FalseType IsPODType; &#125;;template&lt;&gt;struct __TypeTraits&lt;int&gt;&#123; typedef __TrueType IsPODType; &#125;;//实现功能函数(用__TrueType/__FalseType实现重载)template &lt;class T&gt;T* __TypeCopy(T* dst, const T* src, size_t n, __TrueType)&#123; //浅拷贝，调用memcpy return (T*)memcpy(dst, src, n*sizeof(T));&#125;template &lt;class T&gt;T* __TypeCopy(T* dst, const T* src, size_t n, __FalseType)&#123; //深拷贝，进行了 operator= 调用 for(size_t i = 0; i&lt;n; ++i)&#123; dst[i] = src[i]; &#125; return dst;&#125;//对外接口(实现IsPODType的__TrueType和__FalseType的转换)template &lt;class T&gt;T* TypeCopy(T* dst, const T* src, size_t n)&#123; return __TypeCopy(dst, src, n, __TypeTraits&lt;T&gt;::IsPODType);&#125;//调用int main()&#123; int a1[3] = &#123;1, 2, 3&#125;; int a2[2] = &#123;0, 0, 0&#125;; string s1[3] = &#123;\"1\", \"2\", \"3\"&#125;; string s2[3] = &#123;\"0\", \"0\", \"0\"&#125;; TypeCopy(a1, a2, 3); TypeCopy(s1, s2, 3); return 0;&#125; 这样，当传入的参数是s1,s2的时候，__TypeTraits调用的是一般版本，IsPODType为__FalseType,这样__TypeCopy调用的是__FalseType的重载版本，进行深拷贝。当传入的参数是a1，a2的时候，调用的是__TrueType的重载版本，进行浅拷贝。这里只对int进行了特化，所以只有int可以调用__TrueType的版本。但是我们可以对float、double等PODType进行特化，这样就大大提高了代码的复用性。","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"模板与分离编译","slug":"模板与分离编译","date":"2018-02-24T06:56:19.000Z","updated":"2018-02-24T14:58:30.756Z","comments":true,"path":"模板与分离编译.html","link":"","permalink":"http://www.jingxxn.cn/模板与分离编译.html","excerpt":"分离编译模式一个项目如果有多个源文件组成，每个源文件单独编译，形成目标文件。最后通过链接器将所有的目标文件链接起来，形成一个可执行的文件。这个过程就叫做分离编译。 模板不能分离编译有一个项目，其中函数声明放在”test.h”中，函数实现放在”test.cpp”中，函数调用放在”main.cpp”中。如果没用使用模板，将不会有任何问题。而且这样是被推荐使用的。","text":"分离编译模式一个项目如果有多个源文件组成，每个源文件单独编译，形成目标文件。最后通过链接器将所有的目标文件链接起来，形成一个可执行的文件。这个过程就叫做分离编译。 模板不能分离编译有一个项目，其中函数声明放在”test.h”中，函数实现放在”test.cpp”中，函数调用放在”main.cpp”中。如果没用使用模板，将不会有任何问题。而且这样是被推荐使用的。但是如果有函数的实现是模板函数或有模板类，将会出现链接错误。代码如下:1234567891011121314151617181920//test.h#pragma oncetemplate &lt;class T&gt;void print(T num);//test.cpptemplate &lt;class T&gt;void print(T num)&#123; cout &lt;&lt; num &lt;&lt; endl; &#125;//main.cpp#include &lt;iostream&gt;#include \"test.h\"using namespace std;int main()&#123; int number = 10; print(number); return 0;&#125; 这样的代码看起来是没有问题的。执行的时候并不会出现编译错误，但是会出现链接错误。这是因为采取了分离编译之后，我们的.cpp文件是独立编译的。test.cpp中的模板函数，由于没有被调用，所以它的T并没有被实例化相应的类型，比如例子中的int类型。main.cpp中调用了函数print，他需要实例print(int num)。在链接的时候，找不到需要的实例化函数，这样就产生了错误。 解决办法1-显示实例化在函数定义的时候，指定我们需要实例化的类型。在头文件定义中添加指定类型的定义：123456#pragma oncetemplate &lt;class T&gt;void print(T num);//添加int定义template void print&lt;int&gt;(int num); 这种方式是最简单，但是这样却是最麻烦的。如果我有多个不同类型，就需要有相应个数的特化。 解决办法2-不使用分离编译既然不能使用，那么我们不使用分离编译就是了。将我们的函数声明和函数定义放在test.h中。这样我们编译的时候，需要将头文件展开，这样就可以将模板函数在编译的时候实例化。123456//test.h//不需要test.cpp#pragma oncetemplate &lt;class T&gt;void print(T num)&#123; cout &lt;&lt; num &lt;&lt; endl; &#125; 这样解决了模板的分离编译的问题，但是这样也就暴露了我们的函数定义。","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"浅读《STL源码剖析》笔记 4章-vector和list","slug":"浅读《STL源码剖析》笔记-4章-vector和list","date":"2018-02-09T02:13:57.000Z","updated":"2018-03-06T08:42:21.511Z","comments":true,"path":"浅读《STL源码剖析》笔记-4章-vector和list.html","link":"","permalink":"http://www.jingxxn.cn/浅读《STL源码剖析》笔记-4章-vector和list.html","excerpt":"4 序列式容器4.1 容器的概观与分类所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。","text":"4 序列式容器4.1 容器的概观与分类所谓序列式容器，其中的元素都是可序的(ordered),但未必有序(sorted)。C++本身有array，其它是STL提供的。 4.2 vector4.2.1 vector概述array是静态的，vector是动态增长的，随着元素的增加，内部机制自动扩充空间以容纳元素，不需要自己分配空间。 4.2.3 vector的迭代器由于vector维护的是连续线性空间，所以不论元素类型是什么，普通指针都可以作为vector的迭代器而满足要求。vector支持随机存取，普通指针也满足。vector&lt;int&gt; :: iterator ivite;vector&lt;Shape&gt; :: iterator svite;其中 ivite的类型就是int*，svite的类型就是Shape* 。 4.2.4 vector的数据结构vector的数据结构如下：123456789template&lt;class T, class Alloc = alloc&gt;class vecotr&#123; //... protected: //注意STL的左闭右开特性。finish和end_of_storage指向最后一个元素的下一个位置 iterator start; //表示目前使用空间的头部 iterator finish; //表示目前使用空间的尾部 iterator end_of_storage; //表示目前可用空间的尾部&#125; 为了降低空间配置时的成本，实际上，vector配置的空间会比客户端需要的更大一些，这样是为了将来可能扩充的准备。当容量等于大小的时候，开辟新的空间。运用 start，finish，end_of_storage三个迭代器，可以实现begin(),end(),size(),capacity(),empty(),operator[],front(),back()等方法。 4.2.5 vector的构造与内存管理：constructor，push_backpush_back：将新元素插入vector尾端的时候，先检查是否还有备用空间，够的话，直接构造元素，并调整finish。如果没有备用空间，动态增长空间。这指并不是在原空间之后开辟新的空间，因为无法保证原空间之后还有可供配置的空间。而是以原大小的两倍例外配置一块大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对于vector的任何操作，一旦引起了空间重新配置，指向原vector的所有迭代器都是失效了。push_back源代码节选如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void push_back( const T&amp; x)&#123; if( finish != end_of_storage )&#123; construct( finish, x ); ++finish; &#125; else //无备用空间 insert_aux(end(), x);&#125;template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux( iterator positon, const T&amp; x )&#123; if( finish != end_of_storage )&#123; //为什么还要再次判断 construct( finish, *(finish - 1)); ++finish; T x_copy = x; //不懂 copy_backward(position, finish - 2, finish - 1); *position = x_copy; &#125; else&#123; //无备用空间 const size_type old_size = size(); const size_type len = old_size != 0 ? 2*old_size : 1; iterator new_start = data_allocator::allocatr(len); //实际配置空间 iterator new_finish = new_start; try&#123; //将原来vector内容拷贝到新的vector new_finish = uninitialized_copy(start, position, new_start); //为新元素设定初值x construct(new_finish, x); ++new_finish; //将安插点的原内容也拷贝过来//不懂 new_finish = uninitialized_copy(posiition, finish, new_finish); &#125; catch(...)&#123; //开辟失败 destroy(new_start, new_finish); data_allocator::deallocate(new_start, len); throw; &#125; //析构并释放原vector destory(begin(), end()); deallocate(); //调整迭代器，指向新的vector start = new_start; finish = new_finish; end_of_storage = new_start+len; &#125;&#125; 4.2.6 vector的元素操作：pop_back, erase, clear, insert1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//清除[first, last)中的元素iterator erase(iterator first, iterator last)&#123; iterator ii = copy(last, finish, first); //copy是全局函数，第六章 destory(i, finish); finish = finish - (last - first); return first;&#125;//清除某个位置上的元素iterator erase(iterator position)&#123; if(position + 1 != end()) copy(position + 1, finish, position); --finish; destroy(finish); return position;&#125;void clear()&#123; erase(begin(), end()); &#125;//从position开始，插入n个元素，元素初值为xtemplate &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert(iterator position, size_type n ,const T&amp; x)&#123; if(n != 0)&#123; //备用空间大于等于新增元素个数 if(size_type(end_of_storage - finish) &gt;= 0)&#123; T x_copy = x; //计算插入点之后的现有元素个数 const size_type elems_after = finish - position; iterator old_finish = finish; if(elems_after &gt; n)&#123; //插入点之后的现有元素个数 &gt; 新增元素个数 uninitialized_copy(finish - n, finish, finish); finish += n; //将vector 尾端标记后移 copy_backward(position, old_finish - n, old_finish); fill(position, position+n, x_copy); //从插入点开始填入新值 &#125; else&#123; uninitialized_fill_n(finish, n-elems_affter, x_copy); finish += n - elems_after; uninitialized_copy(position, old_finish, finish); finish += elems_after; fill(position, old_finish, x_copy); &#125; &#125; else&#123; //备用空间 &lt; 新增元素个数 const size_type old_size = size(); //决定新的长度为旧长度+新增元素个数 const size_type len = old_size + max(old_size, n); //配置新的vector空间 iterator new_start = data_allocaator::allocate(len); iterator new_finish = new_start; __STL_TRY&#123; //&lt;-- 这个是什么 //将旧的vector在插入点之前的元素复制到新空间 new_finish = uninitialized_copy(start, position, new_start); //将新增元素(初值为x)填入新空间 new_finish = uninitialized_fill_n(new_finish, n, x); //将旧的vector在插入点之后的元素复制到新空间 nwe_finish = uninitialized_copy(position, finish, new_finish); &#125; //异常处理 //... //清除释放旧的空间 destroy(start，finish); deallocate(); //调整迭代器指向新的空间 start = new_start; finish = new_finish; end_of_storage = new_start+len; &#125; &#125;&#125;//插入操作完成之后，新增节点应位于position的后面。 图解如下： 4.3 list4.3.1 list概述list每次插入或删除一个元素，就配置或释放一个元素空间。对于任何位置的元素插入或元素移除，是时间常数。 4.3.2 list的节点(node)list的节点和list本身的设计是分开的。以下是STL list的节点结构：12345678template &lt;class T&gt;struct __list_node&#123; typedef void* void_pointer; void_pointer prev; //型别为void*，其实可以是__list_node&lt;T&gt; void_pointer next; T data;&#125;//这是一个双向链表节点 4.3.3 list的迭代器list的迭代器有一个重要性质，insert(插入)和splice(接合)操作都不会造成原有的迭代器失效。list的delete(删除)只有被删除的那个节点的迭代器失效 4.3.4 list的数据结构SGI list 是一个双向循环链表。list结构如下：123456789template &lt;class T, class Alloc = alloc&gt;class list&#123;protected: typedef __list_node&lt;T&gt; list_node;public: typedef list_node* link_type;protected: link_type node;&#125; STL中指针node指向尾端的一个空白节点，以符合STL中前闭后开规范。12345678910iterator begin() &#123; return (link_type)((*node).next); &#125;iterator end() &#123; return node; &#125;bool empty() const &#123; return node-&gt;next == node; &#125;size_type size() const &#123; size_type result = 0; distance(begin(), end(), result); //全局函数，第三章//计算两个迭代器之间的距离 return result;&#125;reference front() &#123; return *begin(); &#125;reference back() &#123; return *(--end()); &#125; 图解如下： 4.3.5 list的构造与内存管理：constructor， push_back, insertlist缺省使用alloc，并由此定义了一个list_node_alloctor是为了更方便的以节点大小为配置单位。list_node_alloctor(n)表示配置n个节点空间。同时有四个函数，如下：12345678//配置一个节点并传回link_type get_node();//释放一个节点void put_node(link_type p);//配置并构造一个节点，带有元素值link_type create_node(const T&amp; x);//析构并释放一个节点void destroy_node(link_type p); list众多构造函数中，有一个允许我们构造一个空list出来：123456789public: list()&#123; empty_initialize(); &#125;protected: void empty_initialize()&#123; //next、prev指针都指向自己 node = get_node(); node-&gt;next = node; node-&gt;prev = node; &#125; 空节点对象模型：当我们用push_back()插入新节点的时候，函数内部调用insert()void push_back(const T&amp; x) { inset( end(), x ); }insert()有很多的重载函数，最简单的如下:12345678910//在迭代器position所指位置插入一个节点，值为xiterator insert(iterator position, const T&amp; x)&#123; link_type tmp = create_node(x); //插入位置在position之前,这是STL规范。 tmp-&gt;next = position.node; tmp-&gt;prev = position.node-&gt;prev; (link_type(position.node-&gt;node-&gt;prev))-&gt;next = tmp; position.node-&gt;prev = tmp; return tmp;&#125; 4.3.6 list的元素操作：push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sortpush_front, push_back复用insert；pop_front, pop_back复用erase。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//移除迭代器position所指节点iterator erase(iterator position)&#123; link_type next_node = link_type(position.node-&gt;next); link_type prev_node = link_type(position.node-&gt;prev); prev_node-&gt;next = next_node; next_node-&gt;prev = prev_node; destroy_node(position.node); return iterator(next_node);&#125;//清除所有节点template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::clear()&#123; link_type cur = (link__type) node-&gt;next; //begin(); while( cur != node )&#123; link_type tmp - cur; cur = (link_type)cur-&gt;next; destroy_node(tmp); &#125; //恢复成空节点的初始结构 node-&gt;next = node; node-&gt;prev = node;&#125;//将数值为value的所有元素移除template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::remove(const T&amp; value)&#123; iterator first = begin(); iterator last = end(); while(first != last)&#123; iterator next = first; ++next; if(*first == value) erase(first); first = next; &#125;&#125;//移除相同连续的元素，只有连续相同的元素才会被移除只剩一个//很帅啊template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::unique()&#123; iterator first = begin(); iterator last = end(); if(first == last) return; //判空 iterator next = first; while(++next != last)&#123; if(*first == *next) erase(next); else first = next; next = first; &#125;&#125; list 内部提供了一个迁移操作(transfer)：将某连续分为的元素迁移到某特定位置之前。12345678910111213141516protected: //将[first, last)内的所有元素移动到position之前。 void transfer(iterator position, iterator first, iterator last)&#123; if(position != last)&#123; //先处理各节点的next (*(link_type((*last.node).prev))).next = position.node; (*(link_type((*first.node).prev))).next = last.node; (*(link_type((*position.node).prev))).next = first.node; //tmp为position的prev节点 link_type tmp = link_type((*position.node).prev); //处理各节点的prev (*position.node).prev = (*last.node).prev; (*last.node).prev = (*first.node).prev; (*first.node).prev = tmp; &#125; &#125; splice各个版本：1234567891011121314151617181920public: //将list x接合与position所指位置之前，x必须不同于*this void splice(iterator position, list&amp; x)&#123; if(!x.empty()) transfer(position, x.begin(), x.end()); &#125; //将i 所指元素接合于position所指元素之前。position和i可指向同一个list void splice(iterator position, list&amp;, iterator i)&#123; iterator j = i; ++j; if(position == i || position == j) return; trasfer(position, i, j); &#125; //将[first, last)内的所有元素接合于position所指位置之前， //position和[first, last)可指向同一个list。 //但是position不能在[first, last)范围之内 void splice(iterator posiition, list&amp;, iterator first, iterator last)&#123; if(first != last) transfer(position, first, last); &#125; merge(), reverse(), sort()源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//merge()将x合并到*this上，两个list必须是递增排序的template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::merge(list&lt;T, Alloc&gt;&amp; x)&#123; iterator first1 = begin(); iterator last1 = end(); iterator first2 = x.begin(); iterator last2 = x.end(); while(first1 != last1 &amp;&amp; first2 != last2)&#123; if(*first2 &lt; *first1)&#123; iterator next = first2; transfer(first1, first2, ++next); first2 = next; &#125; else ++first1; if(first2 != last2) transfer(last1, first2,last2); &#125;&#125;//reverse()将*this的内容逆置template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::reverse()&#123; //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢 if(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; iterator first = begin(); ++first; while(first != end())&#123; iterator old = first; ++first; transfer(begin(), old, first); &#125;&#125;//list不能使用STL中的sort()算法，只能使用自己的sort()//因为STL的sort()只接受RamdonAccessIterator//本函数使用quick sorttemplate &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::sort()&#123; //判空或只有一个节点，用size() == 0 || size() == 1速度比较慢 if(node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; //创建新的list空间，作为中介数据存放区 list&lt;T, Alloc&gt; carry; list&lt;T, Alloc&gt; counter[64]; int fill = 0; while(!empty())&#123; carry.splice(carry.begin(), *this, begin()); int i = 0; while(i &lt; fill &amp;&amp; !counter[i].empty())&#123; counter[i].merge(carry); carry.swap(counter[i++]); &#125; carry.swap(counter[i]); if(i == fill) ++fill; &#125; for(int i = 1; i &lt; fill; ++i) counter[i].merge(counter[i-1]); swap(counter[fill-1]);&#125;","categories":[{"name":"learning","slug":"learning","permalink":"http://www.jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"浅读《STL源码剖析》笔记 3章","slug":"浅读《STL源码剖析》笔记-3章","date":"2018-02-08T09:07:30.000Z","updated":"2018-03-06T08:44:24.742Z","comments":true,"path":"浅读《STL源码剖析》笔记-3章.html","link":"","permalink":"http://www.jingxxn.cn/浅读《STL源码剖析》笔记-3章.html","excerpt":"3 迭代器(iterator)概念与traits编程技法迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式 3.1 迭代器设计思维STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一","text":"3 迭代器(iterator)概念与traits编程技法迭代器(iterator)是一种抽象的设计概念，iterator模式定义如下；提供一种方法，使之能够按照次序访问某个聚合物（容器）所含有的各个元素，而同时又无需暴露该聚合物的内部表述方式 3.1 迭代器设计思维STL的中心是将数据容器和算法分开，然后用一个胶合剂将他们联系在一起，这个就是iterators的作用之一 12345678910111213141516171819202122232425262728293031323334//3.1举例说明迭代器的使用//find()的定义。template &lt;class InputIterator, chass T&gt;InputIterator find( InputIterator first, InputIterator last, const T&amp; value )&#123; while ( first != last &amp;&amp; *first != value ) ++first; return first;&#125;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; const int arraySiza = 7; int ia[arraySiza] = &#123; 0, 1, 2, 3, 4, 5, 6 &#125;; vector&lt;int&gt; ivect(ia, ia+arraySiza); //调用vector的iterator用于find() vector&lt;int&gt;::iterator it1 = find(ivect.begin(), ivect.end(), 4); if( it1 == ivect.end() ) cout &lt;&lt; \"4 not found.\" &lt;&lt; endl; else cout &lt;&lt; \"4 found:\" &lt;&lt; *it1 &lt;&lt; endl; it1 = find(ivect.begin(), ivect.end(), 8); if( it1 == ivect.end() ) cout &lt;&lt; \"8 not found.\" &lt;&lt; endl; else cout &lt;&lt; \"8 found\" &lt;&lt; *it1 &lt;&lt; endl; return 0;&#125; 运行结果： 3.2 迭代器(ierator)是一种smart pointer迭代器是一个行为类似指针的对象，所以迭代器最重要的编程工作就是对operator* 和 operator-&gt; 进行重载工作。以下，简单模拟一个list的结构，然后设计对应的iterator。12345678910111213141516171819202122232425//listnodetemplate &lt;typename T&gt;class ListItem&#123;public: T value() const&#123; return _value; &#125; ListItem* next() const&#123; return _next; &#125; //...private: T _value; ListItem* _next; //单向链表(single linked list)&#125;;//listtemplate &lt;typename T&gt;class List&#123;public: void insert_front(T value); //省略实现 void insert_end(T value); //省略实现 voide display(std::ostream &amp;os = std::cout) const;//省略实现 //...private: ListItem&lt;T&gt;* _end; ListItem&lt;T&gt;* _front; long _size;&#125;; 当我们解引用这个迭代器的时候，传回的应该是ListItem对象；当我们++迭代器的时候，它应该指向下一个ListItem对象。设计如下：1234567891011121314151617181920212223242526//iteratortemplate &lt;class Item&gt;//Item可以是单向链表节点或双向链表节点，此处这个迭代器特地为链表服务，因为他的operator++只适用于链表。struct ListIter&#123; Item* ptr; //保持与容器之间的一个联系 ListIter( Item* p = 0 ) :ptr(p) &#123;&#125; //不必实现copy ctor，因为编译器提供的缺省行为已经足够 //不必实现operator=，因为编译器提供的缺省行为已经足够 Item&amp; operator*() const &#123; return *ptr; &#125; Item* operator-&gt;() const &#123; return ptr; &#125; //operator++分为两种，一种是前置++(pre-increament operator),另一种是后置++(post-increment operator) //pre-increament operator ListIter&amp; operator++()&#123; ptr = ptr-&gt;next(); return *this; &#125; //post-incteament operator LostIter operator++(int)&#123; ListIter tmp = *this; ++*this; return tmp; &#125; bool operator==(const LostIter&amp; i)const&#123; return ptr == i.ptr; &#125; bool operator!=(const LostIter&amp; i)const&#123; return ptr != i.ptr; &#125;&#125; 接下来，将List和find()由ListIter粘合起来：1234567891011121314151617181920int main()&#123; List&lt;int&gt; mylist; for( int i=0; i&lt;5; ++i )&#123; mylist.insert_front(i); mylist.insert_end(i+2); &#125; mylist.displau(); //10( 4 3 2 1 0 2 3 4 5 6) ListIter&lt;ListItem&lt;int&gt; &gt; begin(mylist.front()); ListIter&lt;ListItem&lt;int&gt; &gt; end; ListIter&lt;ListItem&lt;int&gt; &gt; iter; iter = find(begin, end, 3); if( iter == end ) cout &lt;&lt; \"not found\" &lt;&lt; endl; else cout &lt;&lt; \"found.\" &lt;&lt; iter-&gt;value() &lt;&lt; endl; //执行结果：found.3 return 0;&#125; 由于find() 函数以*iter != value来检查元素值是否吻合，本例子中value的型别是 int，iter 的型别是 ListIterm&lt;int&gt;,两者之间没有可以使用的operator!=函数，所以需要重载这个函数，全局的，参数是int和ListIterm&lt;int&gt;。如下：12template &lt;typename T&gt;bool operator!=(const ListItem&lt;T&gt;&amp; item, T n)&#123; return item.value() != n; &#125; 3.3 迭代器相应型别(associated types)当算法中有必要声明一个变量，需要获取“迭代器所指对象的型别”为型别，我们可以通过function template 的参数推导(argument deducation)机制实现。例如：以func()为对外接口，实际操作全部置于func_imp中，由于func_imp()是一个function template，一旦被调用，编译器会自动进行template参数推导。推导出型别T，顺利解决了问题。 3.4 Traits 编程技法——STL源代码门钥value type：迭代器所指对象的型别。上述的参数型别推导技巧在value type需要用于函数的传回值就束手无策了，因为函数的”template参数推导机制”推导的只是参数，无法推导函数的返回值型别。我们需要别的方法，例如声明内嵌型别。如下：123456789101112131415template &lt;class T&gt;struct MyIter&#123; typedef T value_type; //内嵌型别声明(nested type) MyIter(T* p = 0) :ptr(p) &#123;&#125; T&amp; operator*() const &#123; return *ptr; &#125; //... T* ptr; //成员变量&#125;;template &lt;class I&gt;typename I::value_type func( I ite )&#123; return *ite; &#125; //typename I::value_type 这是func的返回值型别；//...MyIter&lt;int&gt; ite(new int(8));cout &lt;&lt; func(ite); //输出:8 typename I::value_type必须加上typename，因为T是一个template参数，在它被编译器实例化之前，编译器是不知道他是什么的。加上了关键字typename的用意在于告诉编译器这个是一个型别，如此才能够顺利编译通过。 这样有一个缺陷，并不是所有的迭代器都是class type，原生指针就不是。真正可以解决这个问题的是 偏特化(template partial specialization)。也就是将泛化版本中的某些template参数赋予明确大的指定内容。见如下例子：12345678910//class templatetemplate &lt;typename T&gt;class C&#123; //这个泛化版本接受T为任何型别 //...&#125;;//prartial specializationtemplate &lt;typename T&gt;class C&lt;T*&gt;&#123; //这个特化版本只适用于\"T 为原生指针\"的情况 //...&#125;; 下面这个例子，专门用来萃取迭代器的特性，value type正是迭代器的特性之一1234template &lt;class I&gt;struct iterator_traits&#123; //traits意思为“特性” typedef typename I::value_type value_type;&#125;; 这样，前面那个func函数可以修改成这样。123template &lt;class I&gt;//typename iterator_traits&lt;I&gt;::value_type 是函数的返回型别typename iterator_traits&lt;I&gt;::value_type func(I ite)&#123; return *ite; &#125; 跟之前的相比，只是多了一个中间层，但是就是多了这个中间层，traits可以拥有特化版本。如下：1234template &lt;class T&gt;struct iterator_traits&lt;T*&gt;&#123; //偏特化版本--迭代器是一个原生指针 typedef T value_type;&#125; 此时，就算是原生指针，我们也可以通过traits萃取到它的value type。我们想要的到的原生指针是一个非const值，但当像这样的iterator_traits&lt;const int*&gt;::value_type得到的是const int。所以我们另外设计一个特化版本，让const T*转变为T*：1234template &lt;class T&gt;struct iterator_traits&lt;const T*&gt;&#123; //偏特化版本，当迭代器是一个const指针的时候， typedef T value_type; //萃取出来的是T，而不是const T&#125;; 到这里为止，不论是面对class-type迭代器，原生指针，const修饰的原生指针。我们都可以通过traits萃取出正确的value type。但是，需要这traits正常运作，每一个迭代器必须自行以内嵌型别定义(nested typedef)的方式定义出相应型别(associated types)。这是一个约定，STL中必须满足。 图解iterator_traits：常用的迭代器相应型别有以上五种，“特性萃取机”traits会原汁原味的榨取出来：12345678template &lt;class I&gt;struct iterator_traits&#123; typedef typename I::iterator_category iterator_category; typedef typename I::value_type value_type; typedef typename I::difference_type difference_type; typedef typename I::pointer pointer; typedef typename I::reference reference;&#125;; 其中，iterator_traits必须对传入的型别为pointer和pointer-to-const设计特化版本。以上： 3.4.1 value type 如上3.4.2 difference type3.4.3 reference type3.4.4 pointer type3.4.5 iterator_catrgory","categories":[{"name":"learning","slug":"learning","permalink":"http://www.jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"浅读《STL源码剖析》笔记 1、2章","slug":"浅读《STL源码剖析》笔记-1、2章","date":"2018-02-03T03:15:06.000Z","updated":"2018-03-06T08:44:54.368Z","comments":true,"path":"浅读《STL源码剖析》笔记-1、2章.html","link":"","permalink":"http://www.jingxxn.cn/浅读《STL源码剖析》笔记-1、2章.html","excerpt":"1 STL概论与版本简介1.2 STL六大组件 容器(containers):vector,list,deque,set,map,用来存放数据 算法(algorithms):sort,search,copy,erase 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，","text":"1 STL概论与版本简介1.2 STL六大组件 容器(containers):vector,list,deque,set,map,用来存放数据 算法(algorithms):sort,search,copy,erase 迭代器(iterators):扮演容器与算法之间的胶合剂，所谓的“泛型指针”。从实现角度来看，迭代器器将operator*,operator++,operator--,operator-&gt;等指针进行了重载的class template。原生指针（native pointer）也是一种迭代器。 仿函数(functors):行为类似函数，实现来看，重载了operator()的class或class template。 配接器(adapters):一种用来修饰容器(containers)或仿函数(functors)或迭代器(iterators)接口的东西。如stack和queue他们的底层实现是deque。 配置器(allocators):负责空间配置与管理，从实现的角度看来，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。 1.5~1.8 STL版本之二 P.J.Plauger (Microsoft Visual C++) SGI STL (Linux GCC) C++标准规范下的C头文件: cstdio,cstdlib,cstring C++标准程序库中不属于STL范畴: stream,string STL标准头文件: vector,deque,list,map,algorithm,functional C++Standard定案前，HP所规范的STL头文件: vector.h,deque.h,list.h,algo.h,function.h SGI STL内部文件(STL真正实现于此): stl_vector.h,stl_deque.h,stl_list.h,stl_map.h,stl_algo.h,stl_function.h 1.9 可能令你困惑的C++语法1.9.2 临时对象的产生与运用临时对象就是匿名对象，创造临时对象的方法是，在类型后面直接加上()，同时可以赋初值。如：Shape(3,5),int(8)。他的意义相当于调用相应的constructor且不指定对象名称。STL中最常将此技巧用在仿函数(functor)中。临时对象的生命周期只有这一行指令。 1.9.3 静态常量整数成员在class内部直接初始化class内含有const static integral data member，我们可以直接给予初值。123456789101112131415//1.9.3测试代码如下template &lt;typename T&gt;class testclass&#123;public: static const int datai = 5; static const long datal = 3L; static const char datac = 'c';&#125;;int main()&#123; cout &lt;&lt; testclass&lt;int&gt;::datai &lt;&lt; endl; cout &lt;&lt; testclass&lt;int&gt;::datal &lt;&lt; endl; cout &lt;&lt; testclass&lt;int&gt;::datac &lt;&lt; endl; return 0;&#125; 运行结果： 1.9.5 前闭后开区间表示法[)STL中范围是用前闭后开。[first, last)元素从first开始，结束于last-1.迭代器中的last指的是最后一个元素的下一个。 1.9.6 function call操作符(operator())function call操作符(oprator())。C语言中用函数指针作为参数传递。有个缺点就是，没有可适配性，也就是确定了这个函数指针之后，无法再加上新的修饰条件从而改变他的状态。STL中用仿函数(functor)实现这个功能。如果你针对某个class进行operator()重载，它就成为一个仿函数。1234567891011121314151617//1.9.6测试代码如下template &lt;class T&gt;struct Add&#123; //重载了operator() T operator()(const T&amp;x, const T&amp;y) const&#123; return x+y; &#125;&#125;;int main()&#123; Add&lt;int&gt; addxy; system( \"clear\" ); //调用重载函数 cout &lt;&lt; addxy(3,5) &lt;&lt; endl; //调用匿名对象 cout &lt;&lt; Add&lt;int&gt;()(5,5) &lt;&lt; endl; return 0;&#125; 运行结果： 2 空间配置器(allocator)空间配置器在容器背后工作，整个STL的操作对象(所有的数值)，对存放在容器中，而容器一定要配置空间以置放资料。不一定是内存，也可以是磁盘或其他的辅助存储介质。 2.2 具备此配置力的SGI空间配置器2.2.1 SGI标准的空间配置器,std::allocatorSGI的空间配置器和标准规范不同，他的名称是alloc而不是allocator，且不接受任何参数。标准写法如下：vector&lt;int,std::allocator&lt;int&gt;&gt;;SGI STL写法如下：vector&lt;int, std::aloc&gt;绝大多数情况下，我们都是使用缺省的空间配置器。 2.2.2 SGI特殊的空间配置器，std::allocSGI同时也配备了标准空间配置器std::allocator，但是这只是对C++的operator new和operator delete做了一层封装，效率低下，SGI并不使用，只是为了向前兼容语法。 SGI自身使用的空间配置器是std::alloc一般来说，我们习惯的C++内存操作和释放操作是这样的：123class Foo&#123;&#125;;Foo* pf = new Foo;delete pf; 这其中的new包含两个操作，一个是调用::operator new配置内存；另一个是调用Foo::Foo()构造对象内容。delete也是两个，一个是调用Foo::~Foo()析构对象，另一个是调用::operator detele 释放内存。为了分工，STL allocator将这个两个阶段分开来，内存配置操作有alloc:allocate()负责，内存释放操作有alloc::deallocate()负责，对象构造操作有:construct()负责，对象析构操作由::destroy()负责。STL的配置器(allocator)定于于&lt;memory&gt;，其中包含两个文件,一个是负责内存空间的配置与释放&lt;stl_alloc.h&gt;,这里定义了一二级配置器，配置器名为alloc；另一个是负责对象内容的构造与析构&lt;stl_construct.h&gt;，定义了全局函数construct()和destroy()。 2.2.3 构造和析构基本工具:construct()和destroy()construct()的实现如下：12345#include &lt;new.h&gt; //使用placement new 需要这个头文件template &lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value)&#123; new (p) T1(value); //使用了placement new;调用T1:T1(value);&#125; 代码解释：construct()接收一个指针p和一个初始值value，用来将初值设定到指针所指向的空间，通过placement new实现。destroy()有两个版本，实现如下:123456789101112131415161718192021222324252627282930//第一个版本，接受一个指针template &lt;class T&gt;inline void destroy(T* pointer)&#123; pointer-&gt;~T();&#125;//第二个版本，接受两个迭代器。此函数设法找出元素的数值型别，进而利用__type_traits&lt;&gt;求取最适当的措施。template &lt;class ForwardIterator&gt;inline void destroy(ForwardIterator first, ForwardIterator last)&#123; __destroy(first, last, value_type(first));&#125;//判断元素的数值型别(value type)是否有 trivial destructortemplate &lt;class ForwardIterator, class T&gt;inline void __destroy(ForwardIterator first, ForwardIterator last, T*)&#123; typedef typename __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor; __destroy_aux(first, last, trivial_destructor());&#125;//如果元素的数值型别(value type)有non-truvial destructor，循环释放template &lt;class ForwardIterator&gt;inline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type)&#123; for( ; first &lt; last; ++first) //调用第一个版本的destroy() destroy(&amp;* first);&#125;//如果元素的数值型别(value type)有trivial destructor,函数什么也不做template &lt;class ForwardIterator, ForwardIterator, __true_type&gt;&#123; inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type)&#123;&#125;&#125;//destroy()中第二版本针对迭代器为char* 和 wchar_t*的特化版本,函数什么都不做inline void desroy(char*, char*)&#123;&#125;inline void destroy(wchar_t*,wchar_t*)&#123;&#125; 代码解释：destroy()有两个版本，第一个版本接收一个指针，准备将该指针所指之物析构，这个直接调用该对象的析构函数即可。第二个版本接收first和last两个迭代器，准备将[firat, last)范围内的所有对象析构。我们不知道范围有多大，万一很大，而每个对象的析构函数都无关痛痒(所谓trivial destructor),那么一次次调用这些无关痛痒的析构函数，对效率是一个伤害，因此，这里首先利用value_type()获得迭代器所指对象的型别，再利用__type_traits&lt;T&gt;判断该型别的析构函数是否无关痛痒。若是(__true_type)，则什么都不做结束；若不是(__false_type),这才循环巡防整个范围，并在循环中每经历一个对象就调用第一个版本的destroy()。 construct()和destroy()图解：对于C++本身并不支持“指针所指之物”的型别判断，也不支持对“对象析构函数是否为trivial”的判断，具体实现value_type()和__type_traits&lt;&gt;在3.7节。 2.2.4 空间的配置与释放，std::alloc对象构造前的空间配置和对象析构后的空间释放，由&lt;stl_alloc.h&gt;负责。 向 system heap 要求空间 考虑多线程(multi-threads)状态(这里不考虑多线程的情况) 考虑内存不足时的应变措施 考虑过多“小型区域”可能造成的内存碎片(fragment)问题 C++内存配置的基本操作是::operator new()，内存释放的基本操作是::operator delete()。这两个全局函数相当于C的malloc()和free()函数，所以SGI正是用malloc()和free()完成内存的配置和释放。 为了解决小型区块可能造成的内存破碎问题，SGI设计了双层级的配置器，第一级配置器(__malloc_alloc_template)用malloc()和free()，第二级配置器(__default_alloc_template)看情况而定：当配置区块超过128bytes，调用第一级配置器；小于128bytes，采用复杂的内存池memory bool整理方式。其中具体是开放了第一级配置器还是两级配置器都开放了由USE_MEALLOC是否定义决定，定义了USE_MEALLOC就将alloc定义为第一级配置器，没有定义就将alloc定义为第二级配置器。SGI STL采用第二级配置器。 无论是第一级配置器还是第二级配置器，SGI都为其包装了一个接口simple_alloc，使其能够符合STL的接口规格。1234567891011121314151617template &lt;class T,class Alloc&gt;class simple_alloc&#123;public: static T* allocate(size_t n)&#123; return 0 == n?0 : (T*) Alloc::allocate(n* sizeof (T)); &#125; static T* allocate(void)&#123; return (T*) Alloc::allocatte(sizeof (T)); &#125; static void dallocate(T* p, size_t n)&#123; if(0 != n) Alloc::deallocate(p, n*sizeof (T)); &#125; static void deallocat(T* p)&#123; Alloc::deallocate(p, sizeof (T)); &#125;&#125;; 内部四个成员函数都是单纯的转调用，这个接口使配置器的单位从bytes转为个别元素的大小(sizeof(T))。 图解如下： 第一级配置器和第二级配置器： 包装接口和运用： 更新时间：2018.02.17 2.2.5 第一级配置器 __malloc_alloc_template 剖析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172template &lt;int inst&gt; //inst 没有用到class __malloc_alloc_template&#123;private: //处理内存不够的情况 //oom: out of memory static void *oom_malloc(size_t); static void *oom_realloc(void*, size_t); static void (* __malloc_alloc_oom_handler)();public: //直接调用malloc，free，realloc，只是多了一层封装，使之可以处理内存不够的情况 static void* allocate(size_t n)&#123; void *result = malloc(n); if(0 == result) result = oom_malloc(n); &#125; static void deallocate(void* p, size_t)&#123; free(p); &#125; static void* reallocate(void* p, size_t, size_t new_sz)&#123; void* result = realloc(p, new_sz); if(0 = result) result = oom_realloc(p, new_sz); return result; &#125; //仿真c++的set_new_handdler() static void(* set_malloc_handler(void(*f)()))()&#123; //被调用的函数__malloc_alloc_oom_handler void(* old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = f; return (old); &#125; //__malloc_alloc_oom_handler函数初始值是0，该值由客端自己设定 template &lt;int inst&gt; void (* __malloc_alloc_template&lt;inst&gt; :: __malloc_alloc_oom_handler)() = 0; //oom_malloc template &lt;int inst&gt; void* __malloc_alloc_template&lt;inst&gt; :: oom_malloc(size_t n)&#123; void (* my_malloc_handler)(); void* result; for(; ;)&#123; //不停的尝试，释放，配置，释放，配置…… my_malloc_handler = __malloc_alloc_oom_handler; //如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常 if(0 == my_malloc_handler)&#123; __THROW_BAD_ALLOC; &#125; (*my_malloc_handler)(); //调用处理例程，企图释放内存 result = malloc(n); //再次配置 if(result) return (result); &#125; &#125; //oom_realloc template &lt;int inst&gt; void* __malloc_alloc_template&lt;inst&gt; :: oom_realloc(void* p, size_t n)&#123; void (* my_malloc_handler)(); void* result; for(; ;)&#123; //不停的尝试，释放，配置，释放，配置…… my_malloc_handler = __malloc_alloc_oom_handler; //如果没有设置__malloc_alloc_oom_handler的值，直接抛出异常 if(0 == my_malloc_handler)&#123; __THROW_BAD_ALLOC; &#125; (*my_malloc_handler)(); //调用处理例程，企图释放内存 result = malloc(n); //再次配置 if(result) return (result); &#125; &#125;&#125; 第一级配置器以malloc()、free()、realloc()等C函数执行实际的内存的配置、释放、重配置操作，同时实现出类似C++ new-handler的机制。所谓new-handler就是在系统内存配置需求无法被满足的情况下，调用一个指定的函数。 2.2.6 第二级配置器__default_alloc_template 剖析第二级配置器__default_alloc_template多了些机制，避免太多小额区块造成内存的碎片。 当区块超过128bytes，则用内存池管理，此做法又称为次层配置(sub-allocation)：每次配置一大块内存，并维护对应自由链表(free-lists)。下次如果再有相同大小的内存需求，就直接从free-lists中取出。如果客端释放返还小额区块，就有配置器会受到free-lists中。二级配置器会自动将内存调整为8的倍数，并维护16个free-lists，各自管理8的倍数的小额区块。12345//free-list的节点union obj&#123; union obj *free_list_link; char client_data[1];&#125; 其中，obj是一个obj指针，指向下一个相同大小的区块。同时obj是一个指针，指向实际中区块。结合2.2.7的图理解。如图： 2.2.7 空间配置函数allocate()allocate()是二级配置器__default_alloc_template的一个标准接口函数。这个函数首先判断区块大小，大于128bytes调用的第一级配置器，小于128bytes的查询对应free-list有可以用的区块，就直接拿来用，如果没有，就将区块大小调至8倍数边界，然后调用refill()，为free list重新填充空间。123456789101112131415161718192021//n &gt; 0static void* allocate(size_t n)&#123; //二级指针，但是volatile的用法不详 obj* volatile *my_free_list; obj* result; if(n&gt;(size_t) __MAX_BYTES)&#123; return (malloc_alloc::allocate(n)); &#125; //寻找16个free list中适合的一个 my_free_list = free_list + FREELIST_INDEX(n); result = *my_free_list; if(result == 0)&#123; //准备填充free list void* r = refill(ROUND_UP(n)); return r; &#125; //调整free list *my_free_list = result -&gt; free_list_link; return (result);&#125; 图解如下： 2.2.8 空间释放函数 deallocate()deallocate()是配置器__default_alloc_template的一个标准接口函数。大于128bytes调用第一级配置器，小于128bytes找到对应的free list将区块回收。12345678910111213141516// p不可以是 0static void deallocate(void *p, size_t n)&#123; obj* q = (obj* )p; //二级指针，但是volatile的用法不详 obj* volatile *my_free_list; if(n&gt;(size_t) __MAX_BYTES)&#123; malloc_alloc::deallocate(p, n); return; &#125; //寻找对应的free list my_free_list = free_list + FREELIST_INDEX(n); //调整free list，回收区域 q-&gt;free_list_link = *my_free_list(); *my_free_list = q;&#125; 图解如下： 2.2.9 重新填充 free listsallocate()中，当它发现free list中没有可用区块的时候，调用refill()，为free list重新填充空间。新的空间将取自内存池(chunk_alloc()完成)。缺省获得20个新节点。12345678910111213141516171819202122232425262728293031323334//返回一个大小为n的对象，并且有时候会为适当的free list增加节点//假设n已经适当上调至8的倍数template &lt;bool threads, int inst&gt;void* __default_alloc_template&lt;threads, inst&gt; :: refill(size_t n)&#123; int nobjs = 20; //缺省值 //调用chunk_alloc()，尝试获得nobjs个区块作为free list的新节点 char* chunk = chunk_alloc(n, nobjs); obj* volatile* my_free_list; obj* result; obj* current_obj, *next_obj; int i; //如果只获得一个区块，这个区块就分配给调用者使用，free list无新节点 if(1 == nobjs) return (chunk); //否则调整free list纳入新的节点 my_free_list = free_list + FREELIST_INDEX(n)； //以下在chunk空间创建free list result = (obj *)chumk; //以下导引free list 指向新配置的空间(取自内存池) *my_free_list = next_obj = (obj*)(chunk + n); //以下将free list 的各个节点串联起来 for(i = 1; ; i++)&#123; //从n == 1开始，因为0号要返回给客端 current_obj = next_obj; next_obj = (obj*)((char *)next_obj + n); if(nobjs - 1 == i)&#123; current_obj -&gt; free_list_link = 0; break; &#125; else&#123; current_obj-&gt;free_list_link = next_obj; &#125; &#125; return (result);&#125; 内存池暂时先按下…… 2.2.10 内存池(memory pool)2.3 内存基本处理工具STL定义了五个全局函数，作用于未初始化化空间上：用于构造的construct()和析构的destroy(),另外三个是：uninitialized_copy(),uninitialized_fill(),uninitialozed_fill_n()(定于于&lt;memory&gt;),分别对应于高层次函数copy(),fill(),fill_n(),这些都是STL的算法。 2.3.1 uninitialized_copy2.3.2 uninitialized_fill2.3.3 uninitialized_fill_n","categories":[{"name":"learning","slug":"learning","permalink":"http://www.jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"复杂单链表的复制","slug":"复杂单链表的复制","date":"2018-01-31T06:54:57.000Z","updated":"2018-02-08T06:19:39.885Z","comments":true,"path":"复杂单链表的复制.html","link":"","permalink":"http://www.jingxxn.cn/复杂单链表的复制.html","excerpt":"题目:有一个单链表，该链表节点有两个指针，一个_next指向下一个节点，另一个_random指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。 思路： 单链表的复制比较简单，但是_random不好处理，如果_random指向前面的节点，我们该如何处理。_random还有可能是指向NULL，这种情况也需要单独处理。","text":"题目:有一个单链表，该链表节点有两个指针，一个_next指向下一个节点，另一个_random指向任意节点，可能为NULL，可能是前面或后面的节点。请复制该链表，并返回头结点指针。 思路： 单链表的复制比较简单，但是_random不好处理，如果_random指向前面的节点，我们该如何处理。_random还有可能是指向NULL，这种情况也需要单独处理。 为了解决这个问题，我们可以用一个比较巧妙的方法，对每一个节点都复制，同时插入到当前节点的后面。这样我们就得到了一个重复的链表，此时有一个优势，新_random就是原来_random的后一个。我们就不需要在考虑往前寻找的问题了。只需要找到当前节点的_random的_next就行。 这样处理之后，我们就得到了一个新的链表，接着只需要进行拆分就好了。 看图如下：创建了一个复杂链表 进行对每一个节点的复制同时插入到原链表中 给出节点的结构如下：123456789101112#define datatype inttypedef struct complexnode&#123; complexnode(datatype val)&#123; _data = val; _next = NULL; _random = NULL; &#125; datatype _data; complexnode* _next; complexnode* _random;&#125;comnode; 实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//主函数comnode* copy_complex_list( comnode* head )&#123; comnode* cur = head; comnode* next = cur-&gt;_next; if( cur == NULL ) return NULL; //将每一个节点复制到当前节点的后面，并链入链表 while( cur )&#123; comnode* tmp = new comnode(cur-&gt;_data); cur-&gt;_next = tmp; tmp-&gt;_next = next; cur = next; //防止对NULL访问 if( cur ) next = cur-&gt;_next; &#125; //将指针重置指向头结点 cur = head; next = cur-&gt;_next; //给新链入的节点置random while( cur )&#123; //分类处理_random为NULL的情况 if( cur-&gt;_random ) next-&gt;_random = cur-&gt;_random-&gt;_next; else next-&gt;_random = NULL; cur = next-&gt;_next; if( cur ) next = cur-&gt;_next; &#125; cur = head; next = cur-&gt;_next; comnode* result = next; //拆分两个链表 while( cur )&#123; cur-&gt;_next = next-&gt;_next; cur = cur-&gt;_next; if( cur )&#123; next-&gt;_next = cur-&gt;_next; next = next-&gt;_next; &#125; &#125; return result;&#125;//打印函数void print_random( comnode* head )&#123; comnode* cur = head; cout &lt;&lt; \"list:\"; while( cur )&#123; cout &lt;&lt; cur-&gt;_data &lt;&lt; \"-&gt;\"; cur = cur-&gt;_next; &#125; cout &lt;&lt; \"NULL\" &lt;&lt; endl &lt;&lt; \"random:\"; cur = head; while( cur )&#123; if( cur-&gt;_random ) cout &lt;&lt; cur-&gt;_random-&gt;_data &lt;&lt; \" \"; else cout &lt;&lt; \"NULL\" &lt;&lt; \" \"; cur = cur-&gt;_next; &#125; cout &lt;&lt; endl;&#125;int main()&#123; comnode* head = new comnode(1); comnode* n1 = new comnode(2); comnode* n2 = new comnode(4); comnode* n3 = new comnode(5); comnode* n4 = new comnode(9); head-&gt;_next = n1; n1-&gt;_next = n2; n2-&gt;_next = n3; n3-&gt;_next = n4; n4-&gt;_next = NULL; head-&gt;_random = n2; n1-&gt;_random = head; n2-&gt;_random = n3; n3-&gt;_random = NULL; n4-&gt;_random = n4; system( \"clear\" ); comnode* copy_list = copy_complex_list( head ); print_random(head); cout &lt;&lt; \"copy_list:\" &lt;&lt; endl; print_random(copy_list); return 0;&#125; 运行结果如下：同时打印了原来的链表和复制的链表 CSDN上用C写的，同时也将各个部分功能进行了函数封装","categories":[{"name":"practice","slug":"practice","permalink":"http://www.jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://www.jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"浅读《More Effective C++》笔记","slug":"浅读《More Effective C++》笔记","date":"2018-01-30T06:27:03.000Z","updated":"2018-03-28T11:27:55.681Z","comments":true,"path":"浅读《More Effective C++》笔记.html","link":"","permalink":"http://www.jingxxn.cn/浅读《More Effective C++》笔记.html","excerpt":"第一章 基础议题条款1：区分指针和引用不存在空引用，引用必须要指向某个对象。当确定某个对象不允许有空值，就需要定义为引用，而不是指针。123//这种做法语法上没有错误，出现了引用为空的情况。但是不同的编译器会有不同的报错。不允许出现这样的代码。char* pc = 0;char &amp;rc = *pc; 因为不存在空引用这种情况，所以使引用会比指针更高效。","text":"第一章 基础议题条款1：区分指针和引用不存在空引用，引用必须要指向某个对象。当确定某个对象不允许有空值，就需要定义为引用，而不是指针。123//这种做法语法上没有错误，出现了引用为空的情况。但是不同的编译器会有不同的报错。不允许出现这样的代码。char* pc = 0;char &amp;rc = *pc; 因为不存在空引用这种情况，所以使引用会比指针更高效。12345678//引用不用判空void print_double(const double&amp; rd)&#123; cout &lt;&lt; rd;&#125;//指针要判空void print_double1(const double *pd)&#123; if(pd)&#123; cout &lt;&lt; *pd; &#125;&#125; 指针可以被重新赋值用以指向另外一个不同的对象，而引用则总是指向初始化时它指向的对象。12345678string s1(\"nancy\");string s2(\"clancy\");string&amp; rs = s1;string *ps = &amp;s1;//rs依然是s1的引用，此时rs = s1 = s2 = \"clancy\"rs = s2;//ps指向了s2,不再指向s1ps = &amp;s2; 实现某些操作符的时候，最常见的是[]操作符，绝大多数应该返回引用。12345vector&lt;int&gt; v(10);//一般情况下的返回值，此时是引用v[5] = 10;//如果返回的是指针就需要这样解引用，看起来v就像是一个指针vector一样。*v[5] = 10; 条款2：优先考虑C++风格的类型转换四个类型转换操作符：static_cast,const_cast,dynamic_cast,reinterpret_cast static_cast：作用类似于C中的隐式类型转换，只能转换相近类型的变量。比如struct到int的转换就不能实现。而且在C++中，static_cast并不能将const属性转换为非const属性。 const_cast：专门用来去除const属性和volatile属性。const_cast被用来用作其他的类型转换会被拒绝。 dynamic_cast：它是用来针对一个继承体系做向下或者横向的安全转换的。也就是说，用dynamic_cast把指向基类的指针或引用转换成指向派生类或者基类的兄弟类的指针或引用，同时可以知道是否成功。出现空指针(转换指针的时候)或者出现异常(转换引用的时候)意味着失败。他不能用于哪些没有虚函数的类型，也不能去除const属性。 reinterpret_const：这个操作符，转换结果往往是编译器定义的。因此它几乎是不可以移植的。最常见的用法是在函数指针之间进行类型转换。但是一般我们不使用这种转换，因为c++没有规定这种做法，有可能出现未知的错误，除非万不得已，不然不使用。 使用格式举例：static_cast&lt;double&gt; (first); const_cast&lt;special*&gt;(first); dynamic_cast&lt;special *&gt;(&amp;first); reinterpret_cast&lt;funcptr&gt; (&amp;dosomething) 条款3：绝不要把多态应用于数组继承的一大特性，它允许你通过指向基类的指针和引用来操纵派生类对象。这种指针和引用的行为具有多态性。同时C++也允许你通过基类指针和引用来操纵派生类数组，但是这个应该不被允许。见下面这个例子：12345678910111213//一个BST类，有一个BalancedBST的类，它继承与BSTclass BST&#123; //...&#125;;class BalancedBST&#123; //...&#125;;//一个用于打印BST数组中BST元素的函数void printBSTArray(ostream&amp;s, const BST array[], int numElements)&#123; for( int i = 0; i &lt; numElements; ++i )&#123; s &lt;&lt; array[i]; &#125;&#125; 第一种情况，传递的数组是BST数组，程序没有问题；第二种情况，传递的数组是BalancedBST数组(继承于BST),编译器并不会报错，但是会出现问题，关键在于对array[i]的使用。array[i]=*(array+i)，我们知道array是指向数组的首地址的指针，其中array+i偏移的地址是根据元素的大小而定的。因为上例子中，array的类型是BST，所以array[i]的偏移是array+i*sizeof(SBT)。但我们传递了BST的子类BalancedBST给array，这样array的访问就会出现问题。 同时，如果打算通过一个基类指针删除一个包含派生类对象的数组，一样会出现问题。1234567void deleteArray(ostream&amp; logStream, BST array[])&#123; logStream &lt;&lt; static_cast&lt;void*&gt;(array) &lt;&lt; endl; delete[] array;&#125;BalancedBST *balTreeArray = new BalancedBST[50];//...deleteArray(cout, balTreeArray); 明面上这里并没有调用指针，但是当删除数组的时候，数组元素的析构函数必须被调用。 条款4 避免不必要的默认构造函数默认构造函数指的是在C++语言中，不需要传参数就可以调用的构造函数，用于对象的初始化。但有的时候，我们要求这个对象，必须包含一些特定的值。比如下面例子：12345class EquipmentPiece&#123;public: EquipmentPiece( int IDNumber )&#123;&#125; //...&#125;; 此时EquipmentPiece类没有默认的构造函数，有三种情况，对它的应用会出现问题。第一种情况，如下：12EquipmentPiece bestPieces[10]; //没法调用构造函数EquipmentPiece *bestPieces = new EquipmentPiece[10]; //没法调用构造函数 这里有三种方法可以避开这个限制。第一种，对于不在堆上分配内存的数组，在定义数组的时候，提供必要参数。第二种，不使用对象数组，使用一个指针数组，如下：1234567typedef EquipmentPiece* PEP;PEP bestPieces[10];PEP *bestPieces = new PEP[10];//这样，数值的每一个指针都可以被重新赋值以指向不同的EquipmentPiece对象。for( int i = 0; i &lt; 10; ++i )&#123; bestPieces[i] = new EquipmentPiece( ID Number );&#125; 但是这两种方法有两个缺点，第一个是，你必须记住删除数组指针所指向的所有对象，不然会出现内存泄漏。第二，这样的方法所需要的内存需求总量会增加，需要额外的空间去存储指针。 第三种方法，为数组分配原始内存，可以避免额外的内存消耗，利用placement new技术，如下：12345void * rawMemory = operator new[](10*sizeof(EquipmentPiece));EquipmentPiece* bestPieces = static_cast&lt;EquipmentPiece*&gt;(rawMemory);for( int i = 0; i &lt; 10; ++i )&#123; new(bestPieces+i) EquipmentPiece( ID Number );&#125; 这个方法的缺点是，删除的时候，先要手工调用析构函数，然后再手工调用delete[]函数，这样才能够释放原始内存。1234for( int i = 9; i &gt;= 0; --i )&#123; bestPieces[i].~EquipmentPiece();&#125;operator delete[](rawMemory); 没有默认构造函数所造成的第二个问题是，他们没有办法作为许多基于模板的容器类的类型参数使用。因为通常用于实例化模板的那些类型需要提供默认构造函数。这个要求大多数时候来自模板内部需要创建关于模板参数类型的数组。例子如下：1234567891011template&lt;class T&gt;class Array&#123;public: Array( int size );private: T* data;&#125;;template &lt;class T&gt;Array&lt;T&gt;::Array(int size)&#123; date = new T[size];&#125; 在大多数情况下，可以通过谨慎的设计排除对默认构造函数的需要。标准的vector模板就不要求。没有默认构造函数的第三个问题是。在有虚基类的时候，到底要不要提供默认构造函数。没有默认构造函数的虚基类使用起来十分痛苦。这是因为虚基类的构造函数所要求的参数必须由被创建对象所属的最远的派生类提供。这样就导致了，没有默认构造函数的虚基类会要求所有由它继承下来的派生类都必须知道、理解虚基类构造函数的参数的含义并提供这些参数。 第二章 运算符条款5：小心用户自定义的转换函数C++允许编译器在两种数据类型之间进行隐式转换，char到int、short到double。甚至会出现数据丢失的也可以，int到char、double到short的转换。接下来介绍两种类型函数可以让编译器实施这种隐式转换：单个参数的构造函数和隐式的类型转换运算符。 单个参数的构造函数和隐式类型转换符单个参数的构造函数指的是，只传递给它一个参数就可以调用的构造函数。这种构造函数可以只定义一个参数，也可以定义多个参数。定义多个参数的时候，除了第一个参数，后面的参数应该是有默认值的。例子如下：12345678class Name&#123;public: Name(const string&amp; s);&#125;;class Ratinal&#123;public: Rational(int numerator = 0, int denominator = 1);&#125;; 隐式的类型转换运算符只不过是名字看上去比较奇怪的成员函数：在operator关键字后面指定类型。同时，不能指定这个函数的返回值类型，因为返回值的类型就是这个函数的名字。比如说，为了允许有理数对象可以被隐式地转换为double类型，可以如下定义：12345class Rational&#123;public: //... operator double() const;&#125;; 这个隐式的转换函数在类似于下列情况下会被自动调用：12Rational r(1, 2);double d = 0.5*r; 为什么不希望给任何类型提供隐式类型转换函数例子：如果还是上面的有理数Rational对象12Rational r(1, 2);cout &lt;&lt; r; //此时应该输出1/2 但是因为没有重载cout，按道理来说应该没有办法编译通过。可是因为编译器的优化，他会试图通过找到合适的隐式类型转换以便程序成功运行。上述代码就会发现可以通过调用Rational::operator double函数将r隐式转换为double。这样上述代码打印的是一个浮点型，而不是一个有理数。 解决办法对于隐式的类型转换符，使用名字不同于语法关键字但功能相同的函数来代替转换运算符。例如为了把Rational对象转换为double，使用名为asDouble这样的函数代替operator double函数：12345678910class Rational&#123;public: //... double asDouble() const;&#125;;//调用Rational r(1, 2);cout &lt;&lt; r; //operator&lt;&lt; 没有被重载，调用失败cout &lt;&lt; r.asDouble(); //调用成功，输出浮点型数据 对于单个参数的构造函数，第一种十分简单的方法：我们可以通过使用 关键字explicit就可以解决隐式类型转换的问题。比如下列例子：123456789101112131415161718192021222324template &lt;class T&gt;class Array&#123;public: //... explicit Array(int size); //... Array&lt;int&gt; a(10); Array&lt;int&gt; b(10);&#125;;if(a == b[i]) //... //报错，如果Array的构造函数没有被声明为explicit的话，是可以判断成功的。 //a是Array&lt;int&gt;类型，b[i]是int类型，operator==函数发现两个参数分别是Array&lt;int&gt;和int类型。 //虽然没有适配的函数，但是b[i]可以通过单参数的构造函数从int类型转换为Array&lt;int&gt;类型。if(a == (Array&lt;int&gt;)b[i]) //... //可以，通过C风格的隐式类型转换if(a == static_cast&lt; Array&lt;int&gt; &gt;(b[i])) //... //可以，这个是C++风格的隐式类型转换 //注意，static_cast&lt;Array&lt;int&gt; &gt;(b[i])此处的 &gt; &gt;一定要空格开来，不然会被解释为输入运算符&gt;&gt;if(a == Array&lt;int&gt;(b[i])) //... //可以，用b[i]创建一个Array&lt;int&gt;对象，类型符合 第二种方法：可以通过重组类的模板实现。因为决定隐式类型转换的序列是否合法，还需要通过一定的规则，其中有一个规则是这些隐式的转换不能包含多于一个用户自定义类型转换。所以我们将上面数组类的大小通过一个代理类来获取，这样构造函数的大小是调用了一个自定义函数。代码如下：1234567891011121314template &lt;class T&gt;class Array&#123;public: class ArraySize&#123; public: ArraySize(int numElements) :theSize(numElements) &#123;&#125; int size() const &#123; return theSize;&#125; private: int theSize; &#125;; Array(ArraySize size);&#125;; 上述代码在Array类中嵌套了一个ArraySize代理类。当我们使用下列代码的时候：1Array&lt;int&gt; a(10); 编译器要求调用一个接受int类型参数的构造函数，但是Array类没有，不过编译器意识到，可以将int类型转换为一个临时的ArraySize对象，ArraySize对象正是Array&lt;int&gt;需要的。这样也就创建成功了。那么是不是可以避免隐式类型转换呢123456789bool operator==(const Array&lt;int&gt;&amp; lrs, const Array&lt;int&gt;&amp; hrs);Array&lt;int&gt; a(10);Array&lt;int&gt; b(10);//...for(int i = 0; i &lt; 10; ++i)&#123; if(a == b[i]) //... //报错&#125; 为了调用operator==函数，需要一个Array&lt;int&gt;对象在==的右边，但是不存在一个参数为int的单个参数构造函数。而且编译器无法通过吧int转换为一个临时的ArraySize对象，再根据这个临时对象创建必须的Array&lt;int&gt;对象。 条款6：区分自增运算符和自减运算符的前缀形式和后缀形式前缀形式和后缀形式的区别1234567class UPInt&#123;public: UPInt&amp; operator++(); const UPInt operator++(int); UPInt&amp; operator--(); const UPInt operator--(int);&#125;; 当函数被调用的时候，编译器悄无声息的传递一个0作为int参数的值给该函数。其中前缀形式返回一个引用，后缀形式返回一个const对象。 123456789101112UPInt&amp; UPInt::operator++()&#123; *this += 1; return *this;&#125;const UPInt UPInt::operator++(int)&#123; count UPInt oldvalue = *this; //*this += 1; //复用前缀自增 ++(*this); return oldvalue;&#125; 后缀形式返回const后缀自增形式的返回值是一个const对象，为什么是一个const对象呢？如果不是const对象，那么下面这个代码就是正确的： 12UPInt i;i++++; 但是很明显这样是不正确的。根据内置类型的性质，当我们自增两次int类型的数据的时候，这个是不允许发生的。有一个点需要说明的是，如果不是很必要使用后缀自增的形式，那么尽量使用前缀自增。因为后缀自增首先需要显示创建一个临时变量，然后返回的时候，还需要创建一个临时对象作为返回。最后结束函数的时候需要析构两者。如果十分在意效率问题，尽量使用前缀自增。最后，为了降低维护成本，后缀自增或自减最好复用前缀自增或自减。这样只需要维护前缀自增或自减即可。 条款7：不要重载“ &amp;&amp; ”、“ || ”和“ , ”短路求值法C++使用了短路求值法对布尔表达式求值。这个表示，一旦确定了布尔表达式为真或为假，即使还有部分表达式还没有测试，布尔表达式也会停止运算。 1234char* p;//...if(p != 0 &amp;&amp; strlen(p) &gt; 10) //... 这里我们永远不需要担心strlen中的p是否为0值，因为p=0的时候，strlen(p)根本就不会进行运算。 不要重载“ &amp;&amp; ” 和 “ || ”实际上，C++允许我们对&amp;&amp; ||进行重载，但是为了保证短路求值法的正确性，我们要确定不要重载&amp;&amp; ||这两个运算符。如果重载了&amp;&amp;，效果如下： 123if(exp1 &amp;&amp; exp2)if(exp1.operator&amp;&amp;(exp2))if(operator(ex1, ex2)) 这样就变成了函数的调用，首先，函数的调用需要求出两个参数的运算结果，这样就不能实现短路求值的功能；其次，函数的调用没有规定先运算哪个参数，有可能是第一个，也有可能是第二个。 不要重载逗号运算符逆置一个字符串的例子：1234567void reverse(char s[])&#123; for(int i = 0, j = strlen(s) - 1; i &lt; j; ++i, --j)&#123; int c = s[i]; s[i] = s[j]; s[j] = c; &#125;&#125; 包含逗号的表达式，首先计算逗号左边的表达式，然后计算右边的表达式；整个表达式返回最右边的表达式的值。鉴于你完全没有办法模拟这个行为，所以不要重载逗号运算符。 不能重载以下的运算符 . .* :: ?: new delete sizeof typeid static_cast dynamic_cast const_cast reinterpret_cast 条款8：理解new和delete在不同情形下的含义区分 new 操作符(new operator)和 operator new 函数1string *ps = new string(\"Memory Management\"); 上面的代码中使用的new 指的是 new 操作符。new分配足够多的内存用以容纳一个string对象，再调用构造函数用来初始化刚分配的内存中的对象。new的这两个操作是无法被修改的。所能修改的是如何为对象分配内存。new操作符分配内存所调用函数的名字是operator new，其声明通常如下：1void *operator new(size_t size); 一般来说，我们并不会直接调用operator new函数。但是如果我们需要调用它可以这样：1void *rawMemory = operator new(sizeof(string)); 函数operator new返回一个指针，指向一块足够容纳一个string对象的内存。如果想要创建一个堆对象，只能使用new函数，这个是因为构造函数只有编译器可以调用，个人无法直接调用。 placement new函数有的时候真的需要直接调用构造函数，有一种情况可以用到。就是在一块已经分配了大小的却没有初始化的内存，可以调用函数placement new，他是operator new函数的特化版本。使用见下列例子：12345678class Widget&#123;public: Widget(int widgetSize); //...&#125;;Widget* constructWidgetInBuffer(void *buffer, int widgetSize)&#123; return new(buffer) Widget(widgetSize);&#125; 这个函数返回一个指向Widget对象的指针，而Widget对象在传递给函数的buffer种分配。当程序使用共享内存或者memory-mapped I/O的时候，这种函数可能会被用到。 如果想在对上建立一个对象，使用new函数，它既分配内存又为对象调用构造函数。 如果仅仅是想要分配内存，就调用operator new函数。它不会调用构造函数。 如果想要定制在堆对象被创建时的内存分配过程，重载operator new函数，然后使用new函数，它会调用你的operator new函数。 想要在一块已经有指针指向的内存中创建一个对象，使用placement new函数。 对象删除和内存释放通常我们使用delete来释放内存。实际上delete操作符调用operator delete函数，其声明如下：1void operator delete(void* memoryToBeDeallocated); 因此调用delete函数的时候，生成类似于下列的语句：12345string* ps;delete ps;//-&gt;ps-&gt;~string();operator delete(ps); 如果 用placement new函数在内存中创建对象，此时不能用delete操作符。因为delete操作符调用operator delete函数，而operator delete函数释放由operator new函数分配的内存。但是谁知道placement new函数指向的内存是谁创建的呢。所以我们 应该显示的调用对象的析构函数来销毁函数创建的对象。 数组(Array)1string *ps = new string[10]; 这里使用的是operator new[]函数1delete [] ps; 相应的使用delete[]函数来释放内存。对delete[]的具体解析 第三章异常第四章效率条款16：记住80-20原则20%的代码占用了80%的资源，所以需要提高效率就需要找到这一小部分的核心代码。 条款17：考虑使用延迟计算延迟计算指的是，我们写一个类的时候，需要运算的部分会被延迟进行，直到程序要求给出结果的时候才进行计算。这里分为四个运算场景 引用计数(Reference Counting)12345class String&#123; //...&#125;;String s1 = \"Hello\";String s2 = s1; 如果我们使用即时计算，那么s2初始化的时候，会直接拷贝构造一份字符串”Hello”。这个需要使用到new操作符在堆上分配空间。这样会有比较大的开销。如果我们使用延时计算，只需要让s1和s2共享s1的”Hello”字符串，这个只是简单的记录工作。以便知道谁共享了这个空间。12cout &lt;&lt; s1;cout &lt;&lt; s1 + s2; 对于以上代码来说，延时计算和即时计算并没有任何的不同，因为这里只是读取，并没有写入。但是延时计算的方式减，了调用操作符new和拷贝构造函数的开销。共享数据唯一行不通的就是需要改变其中一个数据的值的时候，而不是全部都需要改变。这个时候，只能够将s2拷贝一份，然后再进行修改，防止对s1进行了修改。 区分读操作和写操作如果继续探讨引用计数这个例子，还有一个地方可以通过延时计算来提高效率1234String s = \"Hello\";//...cout &lt;&lt; s[2];s[3] = 'x'; 第一次调用operator[]是为了读取s中的字符，第二次调用operator[]是为了向s中写入数据。我们可以通过一个方法，在operator[]函数中区分读操作和写操作，因为只有写操作才需要一份拷贝，读操作是不需要这些拷贝的开销的。残忍的是，我们没有办法知道什么时候是写操作还是读操作。不过通过延迟计算和条款30讲的代理类，我们可以将对操作的判断推迟到我们可以决定哪一个是正确的操作的是。 延迟读取(Lazy Fetching)假设这里有个程序使用了包含许多数据成员的对象。这些对象必须在每次程序运行的时候保留下来，所以他们被存入了数据库。同时每个对象都有一个唯一的对象标识符用来从数据库中取出这个对象：12345678class LargeObject&#123;public: LargeObject(ObjectID id); const string&amp; field1() const; int field2() const; double field3() const; //...&#125;; 这个时候，从硬盘中恢复一个LargeObject所需要的开销是十分大的。但是如果我们只需要field2的数据，这个是获取其他字段付出的开销都是浪费。1234567voide restoreAndProcessObject(ObjectID id)&#123; LargeObject object(id); if(object.field2() == 0)&#123; cout &lt;&lt; \"Object\" &lt;&lt; id &lt;&lt; \": null field2.\\n\"; &#125;&#125; 对于这种情况，我们可以通过创建LargeObject对象的时候，不从硬盘中读取数据，而是仅仅创建这个对象的外壳，在需要使用某项数据的时候，才冲数据库中获取。1234567891011121314151617181920212223242526272829class LargeObject&#123;public: LargeObject(ObjectID id); const string&amp; field1() const; int field2() const; double field3() const; //...private: ObjectID oid; //外壳 mutable string *field1Value; mutable int *field2Value; mutable double *field3Value; //...&#125;;LargeObject::LargeObject(ObjectID id) :oid(id) ,field1Value(0) ,field2Value(0) ,field3Value(0) //... &#123;&#125;const string&amp; LargeObject::field1() const&#123; if(field1Value == 0)&#123; //从数据库中获取field1的数据，让field1Value指针指向field1 &#125; return *field1Value;&#125; mutable关键字，用来让被const修饰的函数里面也可以修改他的成员。mutable关键字详解上述代码的方式是：先将对象中每一个字段都用一个指向数据的指针来表示，初始化的时候全部置为空。每个LargeObject成员函数在访问字段指针指向的数据之前必须检查字段指针的状态。如果为空，在对数据进行任何操作之前必须先从数据库中读取相应的数据。 延迟表达式求值(Lazy Expression Evaluation)12345678template &lt;class T&gt;class Matrix&#123; //...&#125;;Matrix&lt;int&gt; m1(1000, 1000);Matrix&lt;int&gt; m2(1000, 1000);//...Matrix&lt;int&gt; m3 = m1 + m2; 如果这里直接计算m3将会进行一万次加法运算，这个消耗是十分巨大的。如果我们使用延迟计算法，在m3的n内部建立一个数据结构指明m3的值是m1和m2的相加的结果，再加上一个枚举类型表明所进行的操作是加法运算。这里只要用到两个指针就可以了。如果在后面的程序，下列代码被执行了。123Matrix&lt;int&gt; m4(1000, 1000);//...m3 = m4*m1; 这里我们只要进行替换，让m3记住是m4和m1的乘积。就省略了计算m1和m2相加这一步开销。不单单如此，更常见的场景是，我们只要计算其中的一部分值。比如：1cout &lt;&lt; m3[4]; 这个时候，必须要进行计算了。但是只需要计算矩阵m3第四行的值，其他的值也不需要计算。但是如果需要整个输出m3或者m3所依赖的矩阵被修改，就需要进行计算了1234cout &lt;&lt; m3;m3 = m1 + m2; //m3需要被计算出来，不然m1被修改了。m1 = m4; 条款18：分期摊还预期的计算开销条款19：了解临时对象的来源临时对象123456template &lt;class T&gt;void swap(T&amp; object1, T&amp; object2)&#123; T temp = object1; object1 = object2; object2 = temp;&#125; 我们通常把temp变量叫做临时变量。但是就c++本身来说，这个叫做局部对象。临时对象是不可见的。所谓 临时对象指的是：这个对象被创建，而不是在堆上被创建的，并且还没有名字。 临时对象的产生为了函数调用能过通过产生的临时对象当传递给某个函数的对象的类型与这个函数所绑定的参数类型不一致的时候会发生这种情况。下面代码用来计算字符串中某个字母出现的次数：123456size_t countChar(const string&amp; str, char ch);char buffer[MAX_STRING_LEN];char c;cin &gt;&gt; c &gt;&gt; setw(MAX_STRING_LEN) &gt;&gt; buffer;cout &lt;&lt; \"There are \" &lt;&lt; countChar(buffer, c) &lt;&lt; \" occurrences of the character \" &lt;&lt; c &lt;&lt; \"in\" &lt;&lt; buffer &lt;&lt; endl; 这个代码有一个问题，countChar函数的第一个参数是const string&amp;类型，但是调用的时候，传入的是char类型。这个时候，需要类型匹配才可以让函数正常运行。所以编译器会调用string类的构造函数，并用buffer创建一个临时string对象。但函数调用结束的时候，临时对象被销毁。这里就会付出了没有必要的开销。只有以传值方式传递对象或者把对象传递给声明为常量引用的参数，才会出现这样的类型转换。123void uppercasify(string&amp; str);char subtleBookPlug[] = \"C++\";uppercasify(subtleBookPlug); //wrong 上面这个例子，并不会通过产生临时对象的转换来让函数成功执行。解释一下两者的区别：当传入的参数和函数所期待的参数类型不一致的时候，就会产生了临时对象。如果加上了const，表示函数不会对形参进行任何的修改，那么产生临时对象来使函数成功执行并不会产生任何的问题。如果没有const，表示我的形参有可能会被改变。但这个时候产生了临时对象，如果函数对形参做出了任何的修改，也不会修改到传入的形参，而是对临时变量进行了修改。这样就会产生一定的错误，编译器为了避免这种错误的产生，就限制了没有const的情况下，不会调用该函数成功运行。 函数返回对象的时候产生临时对象有一个叫做Number的类型，他的operator+声明如下：1const Number operator+(const Number&amp; lhs, cosnt Number&amp; rhs); 这个函数的返回只是一个临时对象，因为它没有名字：它只是函数的返回值。但是临时对象的构造函数和析构函数都是一个开销。这里，可以通过operator=来避免这种开销。但是大部分时候，我们没法通过转用其他函数的方式来避免这个开销。条款20会提到利用编译器的优化来减少返回值的开销。 条款20：协助编译器实现返回值优化123456class Rational&#123;public: Rational(int numertor = 0, int denominator = 1); //...&#125;；const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs); 由于operator*函数一定要返回一个对象，是两个有理数的乘积。这是不可避免的。 通过返回指针和引用的方式减小临时对象产生的开销，不正确的做法不过程序员有些尝试，通过指针来返回12345const Rational* operator*(const Rational&amp; lhs, const Rational&amp; rhs);Rational a = 10;Rational b(1, 2);Rational c = *(a*b); 这样代码看起来就有点奇怪，而且，这个返回的指针需要删除函数返回给他的指针，否则就会造成资源泄露。也有的人通过返回引用来实现：12345const Rational&amp; operator*(const Rational&amp; lhs, const Rational&amp; rhs);Rational a = 10;Rational b(1, 2);Rational c = a*b; 这个在语法上是没有任何问题的。但是无论如何都是失败的。因为返回引用的对象是局部对象，当函数结束的时候，这个局部对象已经被销毁了，返回一个指向被销毁的对象的引用是大问题。 返回带有参数的构造函数消除开销有些函数就是需要返回对象的，我们没有办法消除对象本身。但是可以通过返回带有参数的构造函数代替直接返回对象让编译器消除临时对象的开销。1234const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125; 上面的表达式，返回的时候调用了一个Rational类的构造函数，这个函数返回值是这个临时对象的一个拷贝。这样似乎没有任何好处啊，此时仍然需要为函数内部创建的临时对象的构造和析构付出开销，还要为函数所返回的对象的构造和析构付出开销。但是这个时候，有一个叫做编译器优化的东西。123Rational a = 10;Rational b(1, 2);Rational c = a*b; 此时c++允许编译器消除operator函数内部的临时变量以及operator\\所返回的临时变量。这样调用operator所产生的临时对象带来的所有开销就是零。这个时候还有一个开销，就是用来创建c对象的构造函数的开销。不过**我们可以通过声明operator\\函数为内联函数取出调用构造函数带来的开销。** 条款21：通过函数重载避免隐式类型转换先看代码：12345678910class UPInt&#123;public: UPInt(); UPInt(int value); //...&#125;;const UPInt operator+(const UPInt&amp; lhs, const UPInt&amp; rhs);UPInt upi1, upi2;//...UPInt upi3 = upi1 + upi2; 上面的代码没有问题，但是执行下面的语句，会产生临时对象，增加开销。因为这些临时对象用来将整形10转换为UPInt类型。12upi3 = upi1 + 10;upi3 = 10 + upi2; 可是我们可用通过重载的方式消除这些开销。123const UPInt operator+(const UPInt&amp; lhs, const UPInt&amp; rhs);const UPInt operator+(const UPInt&amp; lhs, int rhs);const UPInt operator+(int lhs, const UPInt&amp; rhs); 这样就可以直接调用函数，而不是生成临时对象进行隐式类型转换。但是如下的重载是错误的：1const UPInt operator+(int lhs, int rhs); 这个是因为，c++规定，每一个被重载的运算符，必须要有一个自定义类型的参数。否则上面那样的修改，可能会将两个int相加的方式改变，这样会造成混乱。 条款22：考虑使用operator=来取代单独的operator运算符如果我们有一个自定义类型，需要实现+运算，比如：x=x+y;那么x+=y;也要同样适用。实现operator+最好复用operator+=来实现。比如下列这样：123456789class Rational&#123;public: Rational&amp; operator+=(const Rational&amp; rhs); //...&#125;;const Rational operator+(const Rational&amp; lhs, const Rational&amp; rhs)&#123; return Rational(lhs) += rhs;&#125; 这样的实现有一个好处就是复用了operator+=函数，提高了代码的可维护性。而在效率方面，有两个方面的效率值得注意：首先，单独形式的运算符总是要返回一个新的对象，需要付出构建和析构一个临时对象的开销。而赋值形式的运算符没有这个消耗。其次，operator+的实现可以有下列两种方式：12345678910template &lt;class T&gt;const T operator+(const T&amp; lhs, const T&amp; rhs)&#123; return T(lhs) += rhs;&#125;template &lt;class T&gt;const T operator+(const T&amp; lhs, const T&amp; rhs)&#123; T result(lhs); return result += rhs;&#125; 两者的实现是等价的，但是不同的地方是：第二种的实现会产生临时对象，没有编译器优化。第一种实现方式是：表达式T(lhs)它用的是T的拷贝构造函数。它创建了一个和lhs等值的临时对象。然后这个临时对象和rhs一起被用于调用operator+=函数，这里有编译器的优化。 条款23：考虑使用其他等价的程序库条款24：理解虚函数、多重继承、虚基类以及RTTI带来的开销关于虚基类当虚基类被调用的时候，实际执行的代码取决于被调用对象的动态类型，而指向这个对象的指针或引用的类型是无关紧要的。大多数编译器的实现都是采用虚函数表(virtual table)和指向虚函数表的指针(virtual table pointer)，缩写分别为vtbls和vptrs。一个vtbl通常就是一个函数指针的数组。函数中每个申明了或者继承了虚函数的类都有它自己的虚函数表","categories":[{"name":"learning","slug":"learning","permalink":"http://www.jingxxn.cn/categories/learning/"}],"tags":[]},{"title":"static const integral data member在类中的初始化","slug":"static-const-integral-data-member在类中的初始化","date":"2018-01-30T06:25:04.000Z","updated":"2018-02-09T02:36:56.418Z","comments":true,"path":"static-const-integral-data-member在类中的初始化.html","link":"","permalink":"http://www.jingxxn.cn/static-const-integral-data-member在类中的初始化.html","excerpt":"当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。该类的其它对象对这个静态变量也是可以进行修改的。1234567891011121314151617//非常量静态成员变量初始化对比#include &lt;iostream&gt;using namespace std;class person&#123; public: static int num; //static int num = 11;&#125;;int person::num = 10;int main()&#123; person bob; system(\"clear\"); cout &lt;&lt; bob.num &lt;&lt; endl; return 0;&#125;","text":"当我们在类中定义了一个静态成员变量的时候，我们需要在类之外初始化它，因为他是属于所有的类的。该类的其它对象对这个静态变量也是可以进行修改的。1234567891011121314151617//非常量静态成员变量初始化对比#include &lt;iostream&gt;using namespace std;class person&#123; public: static int num; //static int num = 11;&#125;;int person::num = 10;int main()&#123; person bob; system(\"clear\"); cout &lt;&lt; bob.num &lt;&lt; endl; return 0;&#125; 在类内初始化非常量静态成员变量失败在类外初始化静态成员变量成功123//定义另外一个对象timmyperson timmy;cout &lt;&lt; \"timmy:\" &lt;&lt; timmy.num&lt;&lt; endl; 同一个类的不同对象共用一个静态成员变量 但是，常量的静态成员变量可以在类里面定义。12345678910111213141516#include &lt;iostream&gt;using namespace std;class person&#123; public: static const int num = 11; const static int age = 23;&#125;;int main()&#123; system(\"clear\"); person tom; cout &lt;&lt; \"tom:\" &lt;&lt; tom.num &lt;&lt; endl; cout &lt;&lt; \"tom:\" &lt;&lt; tom.age &lt;&lt; endl; return 0;&#125; static const和const static一样的。 可是只有integral data member才可以，像 int，long，char才行。double，float等都不行12345678910111213#include &lt;iostream&gt;using namespace std;class person&#123; public: static const double num = 2.2;&#125;;int main()&#123; system(\"clear\"); person tom; cout &lt;&lt; \"tom:\" &lt;&lt; tom.num &lt;&lt; endl; return 0;&#125; 用 static const double 初始化失败","categories":[{"name":"knowledge","slug":"knowledge","permalink":"http://www.jingxxn.cn/categories/knowledge/"},{"name":"C/C++","slug":"knowledge/C-C","permalink":"http://www.jingxxn.cn/categories/knowledge/C-C/"}],"tags":[]},{"title":"创建一个不能被继承的类","slug":"创建一个不能被继承的类","date":"2018-01-29T02:23:19.000Z","updated":"2018-02-24T08:04:44.249Z","comments":true,"path":"创建一个不能被继承的类.html","link":"","permalink":"http://www.jingxxn.cn/创建一个不能被继承的类.html","excerpt":"题目：题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。 思路： 题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。","text":"题目：题目很简单，就是创建一个不能够被继承的类，同时能够正常使用。 思路： 题目分为两部分组成，第一个是不能被继承的类。类如果要不能被继承，那么子类肯定不能够调用基类的构造函数或者析构函数。那么我们只要将构造函数或析构函数定义为私有成员函数就好了。 第二个要求，能够正常使用，这样显然之前的方式是行不通的。构造函数为私有了，就无法创建对象了。那我再给他加一个友元函数，这样对象也可以创建了。 可是题目的要求是正常使用这个类，显然通过一个友元函数是不符合我们正常使用类的方式。 这个时候，正真正确的思路就出来了。我们借用一个中间类。例如：我们不能被继承的类是man，我们创建一个 私有构造函数的父类person，同时将 man定义为person的友元类。这样man就可以正常访问person的私有构造函数了。接着我们让 man虚继承person，到这里我们就完成了这个题目。 让man虚继承person是为了让继承man的类，都需要在man的父类，即person中调用构造函数，但只有man是person的友元类，其他的类都不能访问person的构造函数。因此man就成为了不能被继承的类，而man本身可以正常使用。 代码如下：123456789101112131415161718192021222324252627282930313233343536include &lt;iostream&gt;using namespace std;//设计一个不能被继承的类class person&#123; public: friend class man; private: //构造函数为private person()&#123;&#125;&#125;;//man虚拟继承personclass man:virtual public person &#123; public: man()&#123; age = 18; &#125; void show()&#123; cout &lt;&lt; age &lt;&lt; endl; &#125; private: int age;&#125;;// class son:public man&#123;// public:// son()&#123;&#125;// &#125;;int main()&#123; man bob; system( \"clear\" ); bob.show(); //son tom; return 0;&#125; 不定义man的继承类son，正常输出man的age = 18 定义man的继承类son失败","categories":[{"name":"practice","slug":"practice","permalink":"http://www.jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://www.jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"位运算实现Add","slug":"位运算实现Add","date":"2018-01-28T05:30:43.000Z","updated":"2018-02-08T06:20:27.616Z","comments":true,"path":"位运算实现Add.html","link":"","permalink":"http://www.jingxxn.cn/位运算实现Add.html","excerpt":"题目：实现一个Add函数，让两个整数相加，不能够使用+-*/、++、-- 思路： 正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，15+5=20先将位进行相加，不进行进位，得到10，再将进位加上，个位没有进位，十位进1，得到20。","text":"题目：实现一个Add函数，让两个整数相加，不能够使用+-*/、++、-- 思路： 正常实现两个数相加，有两个步骤，第一将两个数对应位相加，第二相加之后有进位，将进位值与对应位相加。举个例子，15+5=20先将位进行相加，不进行进位，得到10，再将进位加上，个位没有进位，十位进1，得到20。 题目要求不能使用+-*/，所以想到了位运算。15的二进制是1111，5的二进制是0101。根据上面的思路，我们先进行不进位相加，得到1010。(这个运算方式正好对应^)然后将进位加上(只求进位的运算正好对应&amp;再左移一位)，例子中只有第四位、第二位数值有进位值。得到10100，这个值就是20。 代码如下123456789101112131415161718192021222324//1、递归实现，每次将不进位相加的值赋给a，将计算出来的进位值赋给b，递归进行两者的分步相加，直到进位值`b=0`，返回a。long long Add( int a, int b )&#123; if( b == 0 ) return a; int sum = a^b; b = (a&amp;b)&lt;&lt;1; a = sum; return Add( a, b );&#125;int main()&#123; system( \"clear\" ); cout &lt;&lt; Add(3, 7) &lt;&lt; endl; //2、同时可以用迭代实现(非函数)，思路一样，进位值b最后肯定会等于0，因为总有进位结束的时候。 int a = 49; int b = 4; while( b != 0 )&#123; int sum = a^b; b = (a&amp;b)&lt;&lt;1; a = sum; &#125; cout &lt;&lt; a &lt;&lt; endl; return 0;&#125;","categories":[{"name":"practice","slug":"practice","permalink":"http://www.jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://www.jingxxn.cn/categories/practice/C-C/"}],"tags":[]},{"title":"1+2+……+n的特殊求法","slug":"1-……-n的特殊求法","date":"2018-01-26T16:44:40.000Z","updated":"2018-02-08T06:20:15.815Z","comments":true,"path":"1-……-n的特殊求法.html","link":"","permalink":"http://www.jingxxn.cn/1-……-n的特殊求法.html","excerpt":"题目：求1+2+3+…+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。 自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&amp;&amp;的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。 更新：18.1.28发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了柔性数组，这种数组的长度的可变的，不需要用常量定义。","text":"题目：求1+2+3+…+n，要求不能使用乘除法，for,while，if,else,switch,case等关键字以及条件判断语句。 自己思考想到了一种方法，递归的思路，但是判断终止的条件不是if，利用了&amp;&amp;的性质，当前操作数为假的时候，不再进行后操作数的运算。然后在网上查阅，得到了其他的做法。 更新：18.1.28发现了一个时间复杂度为O(1)的做法，这种做法只能在GCC、C99标准中使用，因为它使用了柔性数组，这种数组的长度的可变的，不需要用常量定义。 123456789101112class Solution&#123; public: int Sum_Solution( int n )&#123; bool a[n][n+1]; return sizeof(a)&gt;&gt;1; &#125;&#125;;int main()&#123; Solution s; cout &lt;&lt; s.Sum_Solution(10) &lt;&lt; endl; return 0;&#125; 原文： 利用&amp;&amp;操作符，|| 也一样的做法。思路：当result = 0 的时候，&amp;&amp;不再判断右操作数，递归停止。 123456789int sum( int n )&#123; int result = n; result &amp;&amp; (result += sum(n-1)); return result;&#125;int main()&#123; cout &lt;&lt; sum(100) &lt;&lt; endl; return 0;&#125; 利用构造函数以及静态成员变量思路：构造N次对象，每次对静态变量sum++，对n赋值。利用静态变量对所有同类对象有效的特点。 1234567891011121314151617181920212223242526272829303132333435class tmp&#123;public: //构造 tmp( )&#123; ++n; sum += n; &#125; //初始化 void static init()&#123; n = 0; sum = 0; &#125; //获得sum int static getsum()&#123; return sum; &#125;private: static int n; static int sum;&#125;;int tmp::n = 0;int tmp::sum = 0;//运行的函数int count(int n)&#123; tmp::init(); tmp* a = new tmp[n]; delete[] a; a = NULL; tmp::getsum();&#125;int main()&#123; cout &lt;&lt; count(100) &lt;&lt; endl; return 0;&#125; 利用虚函数、继承和函数指针思路： 定义两个类，A是基类，B是子类。 定义一个A* Array[2],其中Array[0]存放A对象的地址，Array[1]存放B对象的地址。 调用函数Sum中调用Sum的递归。同时对变量n两次取反Array[!!n]-&gt;Sum(n-1)+n,这样当n不为0的时候，得到bool值1。Array[!!n] = Array[1] 当n=0调用基类A的sum。充分利用虚函数参数与类型有关的性质。 12345678910111213141516171819202122232425262728293031323334353637383940414243//1、虚函数#include &lt;iostream&gt;using namespace std;class A;A* Array[2];class A&#123;public: virtual int Sum( int n )&#123; return 0; &#125;&#125;;class B:public A&#123;public: virtual int Sum( int n )&#123; //当 n != 0, !!n = 1 return Array[!!n]-&gt;Sum(n-1)+n; &#125;&#125;;int Sum2( int n )&#123; A a; B b; Array[0] = &amp;a; Array[1] = &amp;b; //调用虚函数 int value = Array[1]-&gt;Sum(n); return value;&#125;int main()&#123; cout &lt;&lt; Sum2(100) &lt;&lt; endl; return 0;&#125;//2、同上，这里利用函数指针来实现。typedef int (*fun)(int);int Sum( int i )&#123; return 0;&#125;int Sum2( int i )&#123; fun f[2] = &#123; Sum, Sum2 &#125;; return i + f[!!n](i-1);&#125; 利用异常处理的机制思路：try接收到的异常会在catch中捕获。 1234567891011int sum(int n)&#123; try&#123; //n = 2 的时候，出现异常，程序流跳转到catch int[] array = new int[n-2]; return n+sum(n-1); &#125; catch(Exception e)&#123; //返回1到上一个递归处，n = 2处。 return 1; &#125;&#125; 利用模板思路：利用了模板的特化作为递归结束的条件，并借用枚举类型。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;template &lt;unsigned N&gt;class Sum&#123; public: enum&#123; sum = N+Sum&lt;N-1&gt;::sum &#125;;&#125;;//模板特化，当N=1 的时候，调用template&lt;&gt;class Sum&lt;1&gt;&#123; public: enum&#123; sum = 1 &#125;;&#125;;int main()&#123; cout &lt;&lt; Sum&lt;100&gt;::sum &lt;&lt; endl; return 0;&#125; 方法来源地址","categories":[{"name":"practice","slug":"practice","permalink":"http://www.jingxxn.cn/categories/practice/"},{"name":"C/C++","slug":"practice/C-C","permalink":"http://www.jingxxn.cn/categories/practice/C-C/"}],"tags":[]}]}